/*! For license information please see bundle.50d3c3356f2ffbfa.js.LICENSE.txt */
(() => {
  "use strict";
  var t = {
      14: (t, e, n) => {
        const s = 100,
          i = 301,
          r = 302,
          o = 306,
          a = 1e3,
          c = 1001,
          u = 1002,
          d = 1003,
          l = 1004,
          h = 1005,
          f = 1006,
          m = 1008,
          p = 1009,
          g = 1012,
          x = 1014,
          v = 1015,
          y = 1016,
          w = 1020,
          _ = 1022,
          b = 1023,
          M = 1026,
          S = 1027,
          T = 2300,
          E = 2301,
          C = 2302,
          A = 2400,
          L = 2401,
          R = 2402,
          P = 3e3,
          I = 3001,
          D = 3007,
          N = 3002,
          O = 7680,
          k = 35044,
          U = 35048,
          z = "300 es";
        class F {
          addEventListener(t, e) {
            void 0 === this._listeners && (this._listeners = {});
            const n = this._listeners;
            void 0 === n[t] && (n[t] = []),
              -1 === n[t].indexOf(e) && n[t].push(e);
          }
          hasEventListener(t, e) {
            if (void 0 === this._listeners) return !1;
            const n = this._listeners;
            return void 0 !== n[t] && -1 !== n[t].indexOf(e);
          }
          removeEventListener(t, e) {
            if (void 0 === this._listeners) return;
            const n = this._listeners[t];
            if (void 0 !== n) {
              const t = n.indexOf(e);
              -1 !== t && n.splice(t, 1);
            }
          }
          dispatchEvent(t) {
            if (void 0 === this._listeners) return;
            const e = this._listeners[t.type];
            if (void 0 !== e) {
              t.target = this;
              const n = e.slice(0);
              for (let e = 0, s = n.length; e < s; e++) n[e].call(this, t);
              t.target = null;
            }
          }
        }
        let B = 1234567;
        const H = Math.PI / 180,
          G = 180 / Math.PI,
          V = [];
        for (let t = 0; t < 256; t++)
          V[t] = (t < 16 ? "0" : "") + t.toString(16);
        const W = "undefined" != typeof crypto && "randomUUID" in crypto;
        function j() {
          if (W) return crypto.randomUUID().toUpperCase();
          const t = (4294967295 * Math.random()) | 0,
            e = (4294967295 * Math.random()) | 0,
            n = (4294967295 * Math.random()) | 0,
            s = (4294967295 * Math.random()) | 0;
          return (
            V[255 & t] +
            V[(t >> 8) & 255] +
            V[(t >> 16) & 255] +
            V[(t >> 24) & 255] +
            "-" +
            V[255 & e] +
            V[(e >> 8) & 255] +
            "-" +
            V[((e >> 16) & 15) | 64] +
            V[(e >> 24) & 255] +
            "-" +
            V[(63 & n) | 128] +
            V[(n >> 8) & 255] +
            "-" +
            V[(n >> 16) & 255] +
            V[(n >> 24) & 255] +
            V[255 & s] +
            V[(s >> 8) & 255] +
            V[(s >> 16) & 255] +
            V[(s >> 24) & 255]
          ).toUpperCase();
        }
        function X(t, e, n) {
          return Math.max(e, Math.min(n, t));
        }
        function q(t, e) {
          return ((t % e) + e) % e;
        }
        function Y(t, e, n) {
          return (1 - n) * t + n * e;
        }
        function J(t) {
          return 0 == (t & (t - 1)) && 0 !== t;
        }
        function Z(t) {
          return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
        }
        function $(t) {
          return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
        }
        var K = Object.freeze({
          __proto__: null,
          DEG2RAD: H,
          RAD2DEG: G,
          generateUUID: j,
          clamp: X,
          euclideanModulo: q,
          mapLinear: function (t, e, n, s, i) {
            return s + ((t - e) * (i - s)) / (n - e);
          },
          inverseLerp: function (t, e, n) {
            return t !== e ? (n - t) / (e - t) : 0;
          },
          lerp: Y,
          damp: function (t, e, n, s) {
            return Y(t, e, 1 - Math.exp(-n * s));
          },
          pingpong: function (t, e = 1) {
            return e - Math.abs(q(t, 2 * e) - e);
          },
          smoothstep: function (t, e, n) {
            return t <= e
              ? 0
              : t >= n
              ? 1
              : (t = (t - e) / (n - e)) * t * (3 - 2 * t);
          },
          smootherstep: function (t, e, n) {
            return t <= e
              ? 0
              : t >= n
              ? 1
              : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10);
          },
          randInt: function (t, e) {
            return t + Math.floor(Math.random() * (e - t + 1));
          },
          randFloat: function (t, e) {
            return t + Math.random() * (e - t);
          },
          randFloatSpread: function (t) {
            return t * (0.5 - Math.random());
          },
          seededRandom: function (t) {
            return (
              void 0 !== t && (B = t % 2147483647),
              (B = (16807 * B) % 2147483647),
              (B - 1) / 2147483646
            );
          },
          degToRad: function (t) {
            return t * H;
          },
          radToDeg: function (t) {
            return t * G;
          },
          isPowerOfTwo: J,
          ceilPowerOfTwo: Z,
          floorPowerOfTwo: $,
          setQuaternionFromProperEuler: function (t, e, n, s, i) {
            const r = Math.cos,
              o = Math.sin,
              a = r(n / 2),
              c = o(n / 2),
              u = r((e + s) / 2),
              d = o((e + s) / 2),
              l = r((e - s) / 2),
              h = o((e - s) / 2),
              f = r((s - e) / 2),
              m = o((s - e) / 2);
            switch (i) {
              case "XYX":
                t.set(a * d, c * l, c * h, a * u);
                break;
              case "YZY":
                t.set(c * h, a * d, c * l, a * u);
                break;
              case "ZXZ":
                t.set(c * l, c * h, a * d, a * u);
                break;
              case "XZX":
                t.set(a * d, c * m, c * f, a * u);
                break;
              case "YXY":
                t.set(c * f, a * d, c * m, a * u);
                break;
              case "ZYZ":
                t.set(c * m, c * f, a * d, a * u);
                break;
              default:
                console.warn(
                  "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                    i
                );
            }
          },
        });
        class Q {
          constructor(t = 0, e = 0) {
            (this.x = t), (this.y = e);
          }
          get width() {
            return this.x;
          }
          set width(t) {
            this.x = t;
          }
          get height() {
            return this.y;
          }
          set height(t) {
            this.y = t;
          }
          set(t, e) {
            return (this.x = t), (this.y = e), this;
          }
          setScalar(t) {
            return (this.x = t), (this.y = t), this;
          }
          setX(t) {
            return (this.x = t), this;
          }
          setY(t) {
            return (this.y = t), this;
          }
          setComponent(t, e) {
            switch (t) {
              case 0:
                this.x = e;
                break;
              case 1:
                this.y = e;
                break;
              default:
                throw new Error("index is out of range: " + t);
            }
            return this;
          }
          getComponent(t) {
            switch (t) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              default:
                throw new Error("index is out of range: " + t);
            }
          }
          clone() {
            return new this.constructor(this.x, this.y);
          }
          copy(t) {
            return (this.x = t.x), (this.y = t.y), this;
          }
          add(t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
                ),
                this.addVectors(t, e))
              : ((this.x += t.x), (this.y += t.y), this);
          }
          addScalar(t) {
            return (this.x += t), (this.y += t), this;
          }
          addVectors(t, e) {
            return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
          }
          addScaledVector(t, e) {
            return (this.x += t.x * e), (this.y += t.y * e), this;
          }
          sub(t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
                ),
                this.subVectors(t, e))
              : ((this.x -= t.x), (this.y -= t.y), this);
          }
          subScalar(t) {
            return (this.x -= t), (this.y -= t), this;
          }
          subVectors(t, e) {
            return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
          }
          multiply(t) {
            return (this.x *= t.x), (this.y *= t.y), this;
          }
          multiplyScalar(t) {
            return (this.x *= t), (this.y *= t), this;
          }
          divide(t) {
            return (this.x /= t.x), (this.y /= t.y), this;
          }
          divideScalar(t) {
            return this.multiplyScalar(1 / t);
          }
          applyMatrix3(t) {
            const e = this.x,
              n = this.y,
              s = t.elements;
            return (
              (this.x = s[0] * e + s[3] * n + s[6]),
              (this.y = s[1] * e + s[4] * n + s[7]),
              this
            );
          }
          min(t) {
            return (
              (this.x = Math.min(this.x, t.x)),
              (this.y = Math.min(this.y, t.y)),
              this
            );
          }
          max(t) {
            return (
              (this.x = Math.max(this.x, t.x)),
              (this.y = Math.max(this.y, t.y)),
              this
            );
          }
          clamp(t, e) {
            return (
              (this.x = Math.max(t.x, Math.min(e.x, this.x))),
              (this.y = Math.max(t.y, Math.min(e.y, this.y))),
              this
            );
          }
          clampScalar(t, e) {
            return (
              (this.x = Math.max(t, Math.min(e, this.x))),
              (this.y = Math.max(t, Math.min(e, this.y))),
              this
            );
          }
          clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(
              Math.max(t, Math.min(e, n))
            );
          }
          floor() {
            return (
              (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
            );
          }
          ceil() {
            return (
              (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
            );
          }
          round() {
            return (
              (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
            );
          }
          roundToZero() {
            return (
              (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
              (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
              this
            );
          }
          negate() {
            return (this.x = -this.x), (this.y = -this.y), this;
          }
          dot(t) {
            return this.x * t.x + this.y * t.y;
          }
          cross(t) {
            return this.x * t.y - this.y * t.x;
          }
          lengthSq() {
            return this.x * this.x + this.y * this.y;
          }
          length() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          }
          manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y);
          }
          normalize() {
            return this.divideScalar(this.length() || 1);
          }
          angle() {
            return Math.atan2(-this.y, -this.x) + Math.PI;
          }
          distanceTo(t) {
            return Math.sqrt(this.distanceToSquared(t));
          }
          distanceToSquared(t) {
            const e = this.x - t.x,
              n = this.y - t.y;
            return e * e + n * n;
          }
          manhattanDistanceTo(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
          }
          setLength(t) {
            return this.normalize().multiplyScalar(t);
          }
          lerp(t, e) {
            return (
              (this.x += (t.x - this.x) * e),
              (this.y += (t.y - this.y) * e),
              this
            );
          }
          lerpVectors(t, e, n) {
            return (
              (this.x = t.x + (e.x - t.x) * n),
              (this.y = t.y + (e.y - t.y) * n),
              this
            );
          }
          equals(t) {
            return t.x === this.x && t.y === this.y;
          }
          fromArray(t, e = 0) {
            return (this.x = t[e]), (this.y = t[e + 1]), this;
          }
          toArray(t = [], e = 0) {
            return (t[e] = this.x), (t[e + 1] = this.y), t;
          }
          fromBufferAttribute(t, e, n) {
            return (
              void 0 !== n &&
                console.warn(
                  "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
                ),
              (this.x = t.getX(e)),
              (this.y = t.getY(e)),
              this
            );
          }
          rotateAround(t, e) {
            const n = Math.cos(e),
              s = Math.sin(e),
              i = this.x - t.x,
              r = this.y - t.y;
            return (
              (this.x = i * n - r * s + t.x),
              (this.y = i * s + r * n + t.y),
              this
            );
          }
          random() {
            return (this.x = Math.random()), (this.y = Math.random()), this;
          }
          *[Symbol.iterator]() {
            yield this.x, yield this.y;
          }
        }
        Q.prototype.isVector2 = !0;
        class tt {
          constructor() {
            (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
              arguments.length > 0 &&
                console.error(
                  "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
                );
          }
          set(t, e, n, s, i, r, o, a, c) {
            const u = this.elements;
            return (
              (u[0] = t),
              (u[1] = s),
              (u[2] = o),
              (u[3] = e),
              (u[4] = i),
              (u[5] = a),
              (u[6] = n),
              (u[7] = r),
              (u[8] = c),
              this
            );
          }
          identity() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
          }
          copy(t) {
            const e = this.elements,
              n = t.elements;
            return (
              (e[0] = n[0]),
              (e[1] = n[1]),
              (e[2] = n[2]),
              (e[3] = n[3]),
              (e[4] = n[4]),
              (e[5] = n[5]),
              (e[6] = n[6]),
              (e[7] = n[7]),
              (e[8] = n[8]),
              this
            );
          }
          extractBasis(t, e, n) {
            return (
              t.setFromMatrix3Column(this, 0),
              e.setFromMatrix3Column(this, 1),
              n.setFromMatrix3Column(this, 2),
              this
            );
          }
          setFromMatrix4(t) {
            const e = t.elements;
            return (
              this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
              this
            );
          }
          multiply(t) {
            return this.multiplyMatrices(this, t);
          }
          premultiply(t) {
            return this.multiplyMatrices(t, this);
          }
          multiplyMatrices(t, e) {
            const n = t.elements,
              s = e.elements,
              i = this.elements,
              r = n[0],
              o = n[3],
              a = n[6],
              c = n[1],
              u = n[4],
              d = n[7],
              l = n[2],
              h = n[5],
              f = n[8],
              m = s[0],
              p = s[3],
              g = s[6],
              x = s[1],
              v = s[4],
              y = s[7],
              w = s[2],
              _ = s[5],
              b = s[8];
            return (
              (i[0] = r * m + o * x + a * w),
              (i[3] = r * p + o * v + a * _),
              (i[6] = r * g + o * y + a * b),
              (i[1] = c * m + u * x + d * w),
              (i[4] = c * p + u * v + d * _),
              (i[7] = c * g + u * y + d * b),
              (i[2] = l * m + h * x + f * w),
              (i[5] = l * p + h * v + f * _),
              (i[8] = l * g + h * y + f * b),
              this
            );
          }
          multiplyScalar(t) {
            const e = this.elements;
            return (
              (e[0] *= t),
              (e[3] *= t),
              (e[6] *= t),
              (e[1] *= t),
              (e[4] *= t),
              (e[7] *= t),
              (e[2] *= t),
              (e[5] *= t),
              (e[8] *= t),
              this
            );
          }
          determinant() {
            const t = this.elements,
              e = t[0],
              n = t[1],
              s = t[2],
              i = t[3],
              r = t[4],
              o = t[5],
              a = t[6],
              c = t[7],
              u = t[8];
            return (
              e * r * u -
              e * o * c -
              n * i * u +
              n * o * a +
              s * i * c -
              s * r * a
            );
          }
          invert() {
            const t = this.elements,
              e = t[0],
              n = t[1],
              s = t[2],
              i = t[3],
              r = t[4],
              o = t[5],
              a = t[6],
              c = t[7],
              u = t[8],
              d = u * r - o * c,
              l = o * a - u * i,
              h = c * i - r * a,
              f = e * d + n * l + s * h;
            if (0 === f) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            const m = 1 / f;
            return (
              (t[0] = d * m),
              (t[1] = (s * c - u * n) * m),
              (t[2] = (o * n - s * r) * m),
              (t[3] = l * m),
              (t[4] = (u * e - s * a) * m),
              (t[5] = (s * i - o * e) * m),
              (t[6] = h * m),
              (t[7] = (n * a - c * e) * m),
              (t[8] = (r * e - n * i) * m),
              this
            );
          }
          transpose() {
            let t;
            const e = this.elements;
            return (
              (t = e[1]),
              (e[1] = e[3]),
              (e[3] = t),
              (t = e[2]),
              (e[2] = e[6]),
              (e[6] = t),
              (t = e[5]),
              (e[5] = e[7]),
              (e[7] = t),
              this
            );
          }
          getNormalMatrix(t) {
            return this.setFromMatrix4(t).invert().transpose();
          }
          transposeIntoArray(t) {
            const e = this.elements;
            return (
              (t[0] = e[0]),
              (t[1] = e[3]),
              (t[2] = e[6]),
              (t[3] = e[1]),
              (t[4] = e[4]),
              (t[5] = e[7]),
              (t[6] = e[2]),
              (t[7] = e[5]),
              (t[8] = e[8]),
              this
            );
          }
          setUvTransform(t, e, n, s, i, r, o) {
            const a = Math.cos(i),
              c = Math.sin(i);
            return (
              this.set(
                n * a,
                n * c,
                -n * (a * r + c * o) + r + t,
                -s * c,
                s * a,
                -s * (-c * r + a * o) + o + e,
                0,
                0,
                1
              ),
              this
            );
          }
          scale(t, e) {
            const n = this.elements;
            return (
              (n[0] *= t),
              (n[3] *= t),
              (n[6] *= t),
              (n[1] *= e),
              (n[4] *= e),
              (n[7] *= e),
              this
            );
          }
          rotate(t) {
            const e = Math.cos(t),
              n = Math.sin(t),
              s = this.elements,
              i = s[0],
              r = s[3],
              o = s[6],
              a = s[1],
              c = s[4],
              u = s[7];
            return (
              (s[0] = e * i + n * a),
              (s[3] = e * r + n * c),
              (s[6] = e * o + n * u),
              (s[1] = -n * i + e * a),
              (s[4] = -n * r + e * c),
              (s[7] = -n * o + e * u),
              this
            );
          }
          translate(t, e) {
            const n = this.elements;
            return (
              (n[0] += t * n[2]),
              (n[3] += t * n[5]),
              (n[6] += t * n[8]),
              (n[1] += e * n[2]),
              (n[4] += e * n[5]),
              (n[7] += e * n[8]),
              this
            );
          }
          equals(t) {
            const e = this.elements,
              n = t.elements;
            for (let t = 0; t < 9; t++) if (e[t] !== n[t]) return !1;
            return !0;
          }
          fromArray(t, e = 0) {
            for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
            return this;
          }
          toArray(t = [], e = 0) {
            const n = this.elements;
            return (
              (t[e] = n[0]),
              (t[e + 1] = n[1]),
              (t[e + 2] = n[2]),
              (t[e + 3] = n[3]),
              (t[e + 4] = n[4]),
              (t[e + 5] = n[5]),
              (t[e + 6] = n[6]),
              (t[e + 7] = n[7]),
              (t[e + 8] = n[8]),
              t
            );
          }
          clone() {
            return new this.constructor().fromArray(this.elements);
          }
        }
        function et(t) {
          if (0 === t.length) return -1 / 0;
          let e = t[0];
          for (let n = 1, s = t.length; n < s; ++n) t[n] > e && (e = t[n]);
          return e;
        }
        function nt(t) {
          return document.createElementNS("http://www.w3.org/1999/xhtml", t);
        }
        function st(t, e = 0) {
          let n = 3735928559 ^ e,
            s = 1103547991 ^ e;
          for (let e, i = 0; i < t.length; i++)
            (e = t.charCodeAt(i)),
              (n = Math.imul(n ^ e, 2654435761)),
              (s = Math.imul(s ^ e, 1597334677));
          return (
            (n =
              Math.imul(n ^ (n >>> 16), 2246822507) ^
              Math.imul(s ^ (s >>> 13), 3266489909)),
            (s =
              Math.imul(s ^ (s >>> 16), 2246822507) ^
              Math.imul(n ^ (n >>> 13), 3266489909)),
            4294967296 * (2097151 & s) + (n >>> 0)
          );
        }
        let it;
        (tt.prototype.isMatrix3 = !0),
          Int8Array,
          Uint8Array,
          Uint8ClampedArray,
          Int16Array,
          Uint16Array,
          Int32Array,
          Uint32Array,
          Float32Array,
          Float64Array;
        class rt {
          static getDataURL(t) {
            if (/^data:/i.test(t.src)) return t.src;
            if ("undefined" == typeof HTMLCanvasElement) return t.src;
            let e;
            if (t instanceof HTMLCanvasElement) e = t;
            else {
              void 0 === it && (it = nt("canvas")),
                (it.width = t.width),
                (it.height = t.height);
              const n = it.getContext("2d");
              t instanceof ImageData
                ? n.putImageData(t, 0, 0)
                : n.drawImage(t, 0, 0, t.width, t.height),
                (e = it);
            }
            return e.width > 2048 || e.height > 2048
              ? (console.warn(
                  "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                  t
                ),
                e.toDataURL("image/jpeg", 0.6))
              : e.toDataURL("image/png");
          }
        }
        let ot = 0;
        class at extends F {
          constructor(
            t = at.DEFAULT_IMAGE,
            e = at.DEFAULT_MAPPING,
            n = 1001,
            s = 1001,
            i = 1006,
            r = 1008,
            o = 1023,
            a = 1009,
            c = 1,
            u = 3e3
          ) {
            super(),
              Object.defineProperty(this, "id", { value: ot++ }),
              (this.uuid = j()),
              (this.name = ""),
              (this.image = t),
              (this.mipmaps = []),
              (this.mapping = e),
              (this.wrapS = n),
              (this.wrapT = s),
              (this.magFilter = i),
              (this.minFilter = r),
              (this.anisotropy = c),
              (this.format = o),
              (this.internalFormat = null),
              (this.type = a),
              (this.offset = new Q(0, 0)),
              (this.repeat = new Q(1, 1)),
              (this.center = new Q(0, 0)),
              (this.rotation = 0),
              (this.matrixAutoUpdate = !0),
              (this.matrix = new tt()),
              (this.generateMipmaps = !0),
              (this.premultiplyAlpha = !1),
              (this.flipY = !0),
              (this.unpackAlignment = 4),
              (this.encoding = u),
              (this.userData = {}),
              (this.version = 0),
              (this.onUpdate = null),
              (this.isRenderTargetTexture = !1);
          }
          updateMatrix() {
            this.matrix.setUvTransform(
              this.offset.x,
              this.offset.y,
              this.repeat.x,
              this.repeat.y,
              this.rotation,
              this.center.x,
              this.center.y
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return (
              (this.name = t.name),
              (this.image = t.image),
              (this.mipmaps = t.mipmaps.slice(0)),
              (this.mapping = t.mapping),
              (this.wrapS = t.wrapS),
              (this.wrapT = t.wrapT),
              (this.magFilter = t.magFilter),
              (this.minFilter = t.minFilter),
              (this.anisotropy = t.anisotropy),
              (this.format = t.format),
              (this.internalFormat = t.internalFormat),
              (this.type = t.type),
              this.offset.copy(t.offset),
              this.repeat.copy(t.repeat),
              this.center.copy(t.center),
              (this.rotation = t.rotation),
              (this.matrixAutoUpdate = t.matrixAutoUpdate),
              this.matrix.copy(t.matrix),
              (this.generateMipmaps = t.generateMipmaps),
              (this.premultiplyAlpha = t.premultiplyAlpha),
              (this.flipY = t.flipY),
              (this.unpackAlignment = t.unpackAlignment),
              (this.encoding = t.encoding),
              (this.userData = JSON.parse(JSON.stringify(t.userData))),
              this
            );
          }
          toJSON(t) {
            const e = void 0 === t || "string" == typeof t;
            if (!e && void 0 !== t.textures[this.uuid])
              return t.textures[this.uuid];
            const n = {
              metadata: {
                version: 4.5,
                type: "Texture",
                generator: "Texture.toJSON",
              },
              uuid: this.uuid,
              name: this.name,
              mapping: this.mapping,
              repeat: [this.repeat.x, this.repeat.y],
              offset: [this.offset.x, this.offset.y],
              center: [this.center.x, this.center.y],
              rotation: this.rotation,
              wrap: [this.wrapS, this.wrapT],
              format: this.format,
              type: this.type,
              encoding: this.encoding,
              minFilter: this.minFilter,
              magFilter: this.magFilter,
              anisotropy: this.anisotropy,
              flipY: this.flipY,
              premultiplyAlpha: this.premultiplyAlpha,
              unpackAlignment: this.unpackAlignment,
            };
            if (void 0 !== this.image) {
              const s = this.image;
              if (
                (void 0 === s.uuid && (s.uuid = j()),
                !e && void 0 === t.images[s.uuid])
              ) {
                let e;
                if (Array.isArray(s)) {
                  e = [];
                  for (let t = 0, n = s.length; t < n; t++)
                    s[t].isDataTexture
                      ? e.push(ct(s[t].image))
                      : e.push(ct(s[t]));
                } else e = ct(s);
                t.images[s.uuid] = { uuid: s.uuid, url: e };
              }
              n.image = s.uuid;
            }
            return (
              "{}" !== JSON.stringify(this.userData) &&
                (n.userData = this.userData),
              e || (t.textures[this.uuid] = n),
              n
            );
          }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
          transformUv(t) {
            if (300 !== this.mapping) return t;
            if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
              switch (this.wrapS) {
                case a:
                  t.x = t.x - Math.floor(t.x);
                  break;
                case c:
                  t.x = t.x < 0 ? 0 : 1;
                  break;
                case u:
                  1 === Math.abs(Math.floor(t.x) % 2)
                    ? (t.x = Math.ceil(t.x) - t.x)
                    : (t.x = t.x - Math.floor(t.x));
              }
            if (t.y < 0 || t.y > 1)
              switch (this.wrapT) {
                case a:
                  t.y = t.y - Math.floor(t.y);
                  break;
                case c:
                  t.y = t.y < 0 ? 0 : 1;
                  break;
                case u:
                  1 === Math.abs(Math.floor(t.y) % 2)
                    ? (t.y = Math.ceil(t.y) - t.y)
                    : (t.y = t.y - Math.floor(t.y));
              }
            return this.flipY && (t.y = 1 - t.y), t;
          }
          set needsUpdate(t) {
            !0 === t && this.version++;
          }
        }
        function ct(t) {
          return ("undefined" != typeof HTMLImageElement &&
            t instanceof HTMLImageElement) ||
            ("undefined" != typeof HTMLCanvasElement &&
              t instanceof HTMLCanvasElement) ||
            ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
            ? rt.getDataURL(t)
            : t.data
            ? {
                data: Array.prototype.slice.call(t.data),
                width: t.width,
                height: t.height,
                type: t.data.constructor.name,
              }
            : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
        }
        (at.DEFAULT_IMAGE = void 0),
          (at.DEFAULT_MAPPING = 300),
          (at.prototype.isTexture = !0);
        class ut {
          constructor(t = 0, e = 0, n = 0, s = 1) {
            (this.x = t), (this.y = e), (this.z = n), (this.w = s);
          }
          get width() {
            return this.z;
          }
          set width(t) {
            this.z = t;
          }
          get height() {
            return this.w;
          }
          set height(t) {
            this.w = t;
          }
          set(t, e, n, s) {
            return (this.x = t), (this.y = e), (this.z = n), (this.w = s), this;
          }
          setScalar(t) {
            return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
          }
          setX(t) {
            return (this.x = t), this;
          }
          setY(t) {
            return (this.y = t), this;
          }
          setZ(t) {
            return (this.z = t), this;
          }
          setW(t) {
            return (this.w = t), this;
          }
          setComponent(t, e) {
            switch (t) {
              case 0:
                this.x = e;
                break;
              case 1:
                this.y = e;
                break;
              case 2:
                this.z = e;
                break;
              case 3:
                this.w = e;
                break;
              default:
                throw new Error("index is out of range: " + t);
            }
            return this;
          }
          getComponent(t) {
            switch (t) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              case 2:
                return this.z;
              case 3:
                return this.w;
              default:
                throw new Error("index is out of range: " + t);
            }
          }
          clone() {
            return new this.constructor(this.x, this.y, this.z, this.w);
          }
          copy(t) {
            return (
              (this.x = t.x),
              (this.y = t.y),
              (this.z = t.z),
              (this.w = void 0 !== t.w ? t.w : 1),
              this
            );
          }
          add(t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
                ),
                this.addVectors(t, e))
              : ((this.x += t.x),
                (this.y += t.y),
                (this.z += t.z),
                (this.w += t.w),
                this);
          }
          addScalar(t) {
            return (
              (this.x += t), (this.y += t), (this.z += t), (this.w += t), this
            );
          }
          addVectors(t, e) {
            return (
              (this.x = t.x + e.x),
              (this.y = t.y + e.y),
              (this.z = t.z + e.z),
              (this.w = t.w + e.w),
              this
            );
          }
          addScaledVector(t, e) {
            return (
              (this.x += t.x * e),
              (this.y += t.y * e),
              (this.z += t.z * e),
              (this.w += t.w * e),
              this
            );
          }
          sub(t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
                ),
                this.subVectors(t, e))
              : ((this.x -= t.x),
                (this.y -= t.y),
                (this.z -= t.z),
                (this.w -= t.w),
                this);
          }
          subScalar(t) {
            return (
              (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this
            );
          }
          subVectors(t, e) {
            return (
              (this.x = t.x - e.x),
              (this.y = t.y - e.y),
              (this.z = t.z - e.z),
              (this.w = t.w - e.w),
              this
            );
          }
          multiply(t) {
            return (
              (this.x *= t.x),
              (this.y *= t.y),
              (this.z *= t.z),
              (this.w *= t.w),
              this
            );
          }
          multiplyScalar(t) {
            return (
              (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this
            );
          }
          applyMatrix4(t) {
            const e = this.x,
              n = this.y,
              s = this.z,
              i = this.w,
              r = t.elements;
            return (
              (this.x = r[0] * e + r[4] * n + r[8] * s + r[12] * i),
              (this.y = r[1] * e + r[5] * n + r[9] * s + r[13] * i),
              (this.z = r[2] * e + r[6] * n + r[10] * s + r[14] * i),
              (this.w = r[3] * e + r[7] * n + r[11] * s + r[15] * i),
              this
            );
          }
          divideScalar(t) {
            return this.multiplyScalar(1 / t);
          }
          setAxisAngleFromQuaternion(t) {
            this.w = 2 * Math.acos(t.w);
            const e = Math.sqrt(1 - t.w * t.w);
            return (
              e < 1e-4
                ? ((this.x = 1), (this.y = 0), (this.z = 0))
                : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
              this
            );
          }
          setAxisAngleFromRotationMatrix(t) {
            let e, n, s, i;
            const r = 0.01,
              o = 0.1,
              a = t.elements,
              c = a[0],
              u = a[4],
              d = a[8],
              l = a[1],
              h = a[5],
              f = a[9],
              m = a[2],
              p = a[6],
              g = a[10];
            if (
              Math.abs(u - l) < r &&
              Math.abs(d - m) < r &&
              Math.abs(f - p) < r
            ) {
              if (
                Math.abs(u + l) < o &&
                Math.abs(d + m) < o &&
                Math.abs(f + p) < o &&
                Math.abs(c + h + g - 3) < o
              )
                return this.set(1, 0, 0, 0), this;
              e = Math.PI;
              const t = (c + 1) / 2,
                a = (h + 1) / 2,
                x = (g + 1) / 2,
                v = (u + l) / 4,
                y = (d + m) / 4,
                w = (f + p) / 4;
              return (
                t > a && t > x
                  ? t < r
                    ? ((n = 0), (s = 0.707106781), (i = 0.707106781))
                    : ((n = Math.sqrt(t)), (s = v / n), (i = y / n))
                  : a > x
                  ? a < r
                    ? ((n = 0.707106781), (s = 0), (i = 0.707106781))
                    : ((s = Math.sqrt(a)), (n = v / s), (i = w / s))
                  : x < r
                  ? ((n = 0.707106781), (s = 0.707106781), (i = 0))
                  : ((i = Math.sqrt(x)), (n = y / i), (s = w / i)),
                this.set(n, s, i, e),
                this
              );
            }
            let x = Math.sqrt(
              (p - f) * (p - f) + (d - m) * (d - m) + (l - u) * (l - u)
            );
            return (
              Math.abs(x) < 0.001 && (x = 1),
              (this.x = (p - f) / x),
              (this.y = (d - m) / x),
              (this.z = (l - u) / x),
              (this.w = Math.acos((c + h + g - 1) / 2)),
              this
            );
          }
          min(t) {
            return (
              (this.x = Math.min(this.x, t.x)),
              (this.y = Math.min(this.y, t.y)),
              (this.z = Math.min(this.z, t.z)),
              (this.w = Math.min(this.w, t.w)),
              this
            );
          }
          max(t) {
            return (
              (this.x = Math.max(this.x, t.x)),
              (this.y = Math.max(this.y, t.y)),
              (this.z = Math.max(this.z, t.z)),
              (this.w = Math.max(this.w, t.w)),
              this
            );
          }
          clamp(t, e) {
            return (
              (this.x = Math.max(t.x, Math.min(e.x, this.x))),
              (this.y = Math.max(t.y, Math.min(e.y, this.y))),
              (this.z = Math.max(t.z, Math.min(e.z, this.z))),
              (this.w = Math.max(t.w, Math.min(e.w, this.w))),
              this
            );
          }
          clampScalar(t, e) {
            return (
              (this.x = Math.max(t, Math.min(e, this.x))),
              (this.y = Math.max(t, Math.min(e, this.y))),
              (this.z = Math.max(t, Math.min(e, this.z))),
              (this.w = Math.max(t, Math.min(e, this.w))),
              this
            );
          }
          clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(
              Math.max(t, Math.min(e, n))
            );
          }
          floor() {
            return (
              (this.x = Math.floor(this.x)),
              (this.y = Math.floor(this.y)),
              (this.z = Math.floor(this.z)),
              (this.w = Math.floor(this.w)),
              this
            );
          }
          ceil() {
            return (
              (this.x = Math.ceil(this.x)),
              (this.y = Math.ceil(this.y)),
              (this.z = Math.ceil(this.z)),
              (this.w = Math.ceil(this.w)),
              this
            );
          }
          round() {
            return (
              (this.x = Math.round(this.x)),
              (this.y = Math.round(this.y)),
              (this.z = Math.round(this.z)),
              (this.w = Math.round(this.w)),
              this
            );
          }
          roundToZero() {
            return (
              (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
              (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
              (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
              (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
              this
            );
          }
          negate() {
            return (
              (this.x = -this.x),
              (this.y = -this.y),
              (this.z = -this.z),
              (this.w = -this.w),
              this
            );
          }
          dot(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
          }
          lengthSq() {
            return (
              this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
            );
          }
          length() {
            return Math.sqrt(
              this.x * this.x +
                this.y * this.y +
                this.z * this.z +
                this.w * this.w
            );
          }
          manhattanLength() {
            return (
              Math.abs(this.x) +
              Math.abs(this.y) +
              Math.abs(this.z) +
              Math.abs(this.w)
            );
          }
          normalize() {
            return this.divideScalar(this.length() || 1);
          }
          setLength(t) {
            return this.normalize().multiplyScalar(t);
          }
          lerp(t, e) {
            return (
              (this.x += (t.x - this.x) * e),
              (this.y += (t.y - this.y) * e),
              (this.z += (t.z - this.z) * e),
              (this.w += (t.w - this.w) * e),
              this
            );
          }
          lerpVectors(t, e, n) {
            return (
              (this.x = t.x + (e.x - t.x) * n),
              (this.y = t.y + (e.y - t.y) * n),
              (this.z = t.z + (e.z - t.z) * n),
              (this.w = t.w + (e.w - t.w) * n),
              this
            );
          }
          equals(t) {
            return (
              t.x === this.x &&
              t.y === this.y &&
              t.z === this.z &&
              t.w === this.w
            );
          }
          fromArray(t, e = 0) {
            return (
              (this.x = t[e]),
              (this.y = t[e + 1]),
              (this.z = t[e + 2]),
              (this.w = t[e + 3]),
              this
            );
          }
          toArray(t = [], e = 0) {
            return (
              (t[e] = this.x),
              (t[e + 1] = this.y),
              (t[e + 2] = this.z),
              (t[e + 3] = this.w),
              t
            );
          }
          fromBufferAttribute(t, e, n) {
            return (
              void 0 !== n &&
                console.warn(
                  "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
                ),
              (this.x = t.getX(e)),
              (this.y = t.getY(e)),
              (this.z = t.getZ(e)),
              (this.w = t.getW(e)),
              this
            );
          }
          random() {
            return (
              (this.x = Math.random()),
              (this.y = Math.random()),
              (this.z = Math.random()),
              (this.w = Math.random()),
              this
            );
          }
          *[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z, yield this.w;
          }
        }
        ut.prototype.isVector4 = !0;
        class dt extends F {
          constructor(t, e, n = {}) {
            super(),
              (this.width = t),
              (this.height = e),
              (this.depth = 1),
              (this.scissor = new ut(0, 0, t, e)),
              (this.scissorTest = !1),
              (this.viewport = new ut(0, 0, t, e)),
              (this.texture = new at(
                void 0,
                n.mapping,
                n.wrapS,
                n.wrapT,
                n.magFilter,
                n.minFilter,
                n.format,
                n.type,
                n.anisotropy,
                n.encoding
              )),
              (this.texture.isRenderTargetTexture = !0),
              (this.texture.image = { width: t, height: e, depth: 1 }),
              (this.texture.generateMipmaps =
                void 0 !== n.generateMipmaps && n.generateMipmaps),
              (this.texture.internalFormat =
                void 0 !== n.internalFormat ? n.internalFormat : null),
              (this.texture.minFilter =
                void 0 !== n.minFilter ? n.minFilter : f),
              (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
              (this.stencilBuffer =
                void 0 !== n.stencilBuffer && n.stencilBuffer),
              (this.depthTexture =
                void 0 !== n.depthTexture ? n.depthTexture : null);
          }
          setTexture(t) {
            (t.image = {
              width: this.width,
              height: this.height,
              depth: this.depth,
            }),
              (this.texture = t);
          }
          setSize(t, e, n = 1) {
            (this.width === t && this.height === e && this.depth === n) ||
              ((this.width = t),
              (this.height = e),
              (this.depth = n),
              (this.texture.image.width = t),
              (this.texture.image.height = e),
              (this.texture.image.depth = n),
              this.dispose()),
              this.viewport.set(0, 0, t, e),
              this.scissor.set(0, 0, t, e);
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return (
              (this.width = t.width),
              (this.height = t.height),
              (this.depth = t.depth),
              this.viewport.copy(t.viewport),
              (this.texture = t.texture.clone()),
              (this.texture.image = { ...this.texture.image }),
              (this.depthBuffer = t.depthBuffer),
              (this.stencilBuffer = t.stencilBuffer),
              (this.depthTexture = t.depthTexture),
              this
            );
          }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
        }
        (dt.prototype.isWebGLRenderTarget = !0),
          (class extends dt {
            constructor(t, e, n) {
              super(t, e);
              const s = this.texture;
              this.texture = [];
              for (let t = 0; t < n; t++) this.texture[t] = s.clone();
            }
            setSize(t, e, n = 1) {
              if (this.width !== t || this.height !== e || this.depth !== n) {
                (this.width = t), (this.height = e), (this.depth = n);
                for (let s = 0, i = this.texture.length; s < i; s++)
                  (this.texture[s].image.width = t),
                    (this.texture[s].image.height = e),
                    (this.texture[s].image.depth = n);
                this.dispose();
              }
              return (
                this.viewport.set(0, 0, t, e),
                this.scissor.set(0, 0, t, e),
                this
              );
            }
            copy(t) {
              this.dispose(),
                (this.width = t.width),
                (this.height = t.height),
                (this.depth = t.depth),
                this.viewport.set(0, 0, this.width, this.height),
                this.scissor.set(0, 0, this.width, this.height),
                (this.depthBuffer = t.depthBuffer),
                (this.stencilBuffer = t.stencilBuffer),
                (this.depthTexture = t.depthTexture),
                (this.texture.length = 0);
              for (let e = 0, n = t.texture.length; e < n; e++)
                this.texture[e] = t.texture[e].clone();
              return this;
            }
          }.prototype.isWebGLMultipleRenderTargets = !0);
        class lt extends dt {
          constructor(t, e, n) {
            super(t, e, n), (this.samples = 4);
          }
          copy(t) {
            return super.copy.call(this, t), (this.samples = t.samples), this;
          }
        }
        lt.prototype.isWebGLMultisampleRenderTarget = !0;
        class ht {
          constructor(t = 0, e = 0, n = 0, s = 1) {
            (this._x = t), (this._y = e), (this._z = n), (this._w = s);
          }
          static slerp(t, e, n, s) {
            return (
              console.warn(
                "THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."
              ),
              n.slerpQuaternions(t, e, s)
            );
          }
          static slerpFlat(t, e, n, s, i, r, o) {
            let a = n[s + 0],
              c = n[s + 1],
              u = n[s + 2],
              d = n[s + 3];
            const l = i[r + 0],
              h = i[r + 1],
              f = i[r + 2],
              m = i[r + 3];
            if (0 === o)
              return (
                (t[e + 0] = a),
                (t[e + 1] = c),
                (t[e + 2] = u),
                void (t[e + 3] = d)
              );
            if (1 === o)
              return (
                (t[e + 0] = l),
                (t[e + 1] = h),
                (t[e + 2] = f),
                void (t[e + 3] = m)
              );
            if (d !== m || a !== l || c !== h || u !== f) {
              let t = 1 - o;
              const e = a * l + c * h + u * f + d * m,
                n = e >= 0 ? 1 : -1,
                s = 1 - e * e;
              if (s > Number.EPSILON) {
                const i = Math.sqrt(s),
                  r = Math.atan2(i, e * n);
                (t = Math.sin(t * r) / i), (o = Math.sin(o * r) / i);
              }
              const i = o * n;
              if (
                ((a = a * t + l * i),
                (c = c * t + h * i),
                (u = u * t + f * i),
                (d = d * t + m * i),
                t === 1 - o)
              ) {
                const t = 1 / Math.sqrt(a * a + c * c + u * u + d * d);
                (a *= t), (c *= t), (u *= t), (d *= t);
              }
            }
            (t[e] = a), (t[e + 1] = c), (t[e + 2] = u), (t[e + 3] = d);
          }
          static multiplyQuaternionsFlat(t, e, n, s, i, r) {
            const o = n[s],
              a = n[s + 1],
              c = n[s + 2],
              u = n[s + 3],
              d = i[r],
              l = i[r + 1],
              h = i[r + 2],
              f = i[r + 3];
            return (
              (t[e] = o * f + u * d + a * h - c * l),
              (t[e + 1] = a * f + u * l + c * d - o * h),
              (t[e + 2] = c * f + u * h + o * l - a * d),
              (t[e + 3] = u * f - o * d - a * l - c * h),
              t
            );
          }
          get x() {
            return this._x;
          }
          set x(t) {
            (this._x = t), this._onChangeCallback();
          }
          get y() {
            return this._y;
          }
          set y(t) {
            (this._y = t), this._onChangeCallback();
          }
          get z() {
            return this._z;
          }
          set z(t) {
            (this._z = t), this._onChangeCallback();
          }
          get w() {
            return this._w;
          }
          set w(t) {
            (this._w = t), this._onChangeCallback();
          }
          set(t, e, n, s) {
            return (
              (this._x = t),
              (this._y = e),
              (this._z = n),
              (this._w = s),
              this._onChangeCallback(),
              this
            );
          }
          clone() {
            return new this.constructor(this._x, this._y, this._z, this._w);
          }
          copy(t) {
            return (
              (this._x = t.x),
              (this._y = t.y),
              (this._z = t.z),
              (this._w = t.w),
              this._onChangeCallback(),
              this
            );
          }
          setFromEuler(t, e) {
            if (!t || !t.isEuler)
              throw new Error(
                "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
              );
            const n = t._x,
              s = t._y,
              i = t._z,
              r = t._order,
              o = Math.cos,
              a = Math.sin,
              c = o(n / 2),
              u = o(s / 2),
              d = o(i / 2),
              l = a(n / 2),
              h = a(s / 2),
              f = a(i / 2);
            switch (r) {
              case "XYZ":
                (this._x = l * u * d + c * h * f),
                  (this._y = c * h * d - l * u * f),
                  (this._z = c * u * f + l * h * d),
                  (this._w = c * u * d - l * h * f);
                break;
              case "YXZ":
                (this._x = l * u * d + c * h * f),
                  (this._y = c * h * d - l * u * f),
                  (this._z = c * u * f - l * h * d),
                  (this._w = c * u * d + l * h * f);
                break;
              case "ZXY":
                (this._x = l * u * d - c * h * f),
                  (this._y = c * h * d + l * u * f),
                  (this._z = c * u * f + l * h * d),
                  (this._w = c * u * d - l * h * f);
                break;
              case "ZYX":
                (this._x = l * u * d - c * h * f),
                  (this._y = c * h * d + l * u * f),
                  (this._z = c * u * f - l * h * d),
                  (this._w = c * u * d + l * h * f);
                break;
              case "YZX":
                (this._x = l * u * d + c * h * f),
                  (this._y = c * h * d + l * u * f),
                  (this._z = c * u * f - l * h * d),
                  (this._w = c * u * d - l * h * f);
                break;
              case "XZY":
                (this._x = l * u * d - c * h * f),
                  (this._y = c * h * d - l * u * f),
                  (this._z = c * u * f + l * h * d),
                  (this._w = c * u * d + l * h * f);
                break;
              default:
                console.warn(
                  "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                    r
                );
            }
            return !1 !== e && this._onChangeCallback(), this;
          }
          setFromAxisAngle(t, e) {
            const n = e / 2,
              s = Math.sin(n);
            return (
              (this._x = t.x * s),
              (this._y = t.y * s),
              (this._z = t.z * s),
              (this._w = Math.cos(n)),
              this._onChangeCallback(),
              this
            );
          }
          setFromRotationMatrix(t) {
            const e = t.elements,
              n = e[0],
              s = e[4],
              i = e[8],
              r = e[1],
              o = e[5],
              a = e[9],
              c = e[2],
              u = e[6],
              d = e[10],
              l = n + o + d;
            if (l > 0) {
              const t = 0.5 / Math.sqrt(l + 1);
              (this._w = 0.25 / t),
                (this._x = (u - a) * t),
                (this._y = (i - c) * t),
                (this._z = (r - s) * t);
            } else if (n > o && n > d) {
              const t = 2 * Math.sqrt(1 + n - o - d);
              (this._w = (u - a) / t),
                (this._x = 0.25 * t),
                (this._y = (s + r) / t),
                (this._z = (i + c) / t);
            } else if (o > d) {
              const t = 2 * Math.sqrt(1 + o - n - d);
              (this._w = (i - c) / t),
                (this._x = (s + r) / t),
                (this._y = 0.25 * t),
                (this._z = (a + u) / t);
            } else {
              const t = 2 * Math.sqrt(1 + d - n - o);
              (this._w = (r - s) / t),
                (this._x = (i + c) / t),
                (this._y = (a + u) / t),
                (this._z = 0.25 * t);
            }
            return this._onChangeCallback(), this;
          }
          setFromUnitVectors(t, e) {
            let n = t.dot(e) + 1;
            return (
              n < Number.EPSILON
                ? ((n = 0),
                  Math.abs(t.x) > Math.abs(t.z)
                    ? ((this._x = -t.y),
                      (this._y = t.x),
                      (this._z = 0),
                      (this._w = n))
                    : ((this._x = 0),
                      (this._y = -t.z),
                      (this._z = t.y),
                      (this._w = n)))
                : ((this._x = t.y * e.z - t.z * e.y),
                  (this._y = t.z * e.x - t.x * e.z),
                  (this._z = t.x * e.y - t.y * e.x),
                  (this._w = n)),
              this.normalize()
            );
          }
          angleTo(t) {
            return 2 * Math.acos(Math.abs(X(this.dot(t), -1, 1)));
          }
          rotateTowards(t, e) {
            const n = this.angleTo(t);
            if (0 === n) return this;
            const s = Math.min(1, e / n);
            return this.slerp(t, s), this;
          }
          identity() {
            return this.set(0, 0, 0, 1);
          }
          invert() {
            return this.conjugate();
          }
          conjugate() {
            return (
              (this._x *= -1),
              (this._y *= -1),
              (this._z *= -1),
              this._onChangeCallback(),
              this
            );
          }
          dot(t) {
            return (
              this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            );
          }
          lengthSq() {
            return (
              this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
            );
          }
          length() {
            return Math.sqrt(
              this._x * this._x +
                this._y * this._y +
                this._z * this._z +
                this._w * this._w
            );
          }
          normalize() {
            let t = this.length();
            return (
              0 === t
                ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
                : ((t = 1 / t),
                  (this._x = this._x * t),
                  (this._y = this._y * t),
                  (this._z = this._z * t),
                  (this._w = this._w * t)),
              this._onChangeCallback(),
              this
            );
          }
          multiply(t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
                ),
                this.multiplyQuaternions(t, e))
              : this.multiplyQuaternions(this, t);
          }
          premultiply(t) {
            return this.multiplyQuaternions(t, this);
          }
          multiplyQuaternions(t, e) {
            const n = t._x,
              s = t._y,
              i = t._z,
              r = t._w,
              o = e._x,
              a = e._y,
              c = e._z,
              u = e._w;
            return (
              (this._x = n * u + r * o + s * c - i * a),
              (this._y = s * u + r * a + i * o - n * c),
              (this._z = i * u + r * c + n * a - s * o),
              (this._w = r * u - n * o - s * a - i * c),
              this._onChangeCallback(),
              this
            );
          }
          slerp(t, e) {
            if (0 === e) return this;
            if (1 === e) return this.copy(t);
            const n = this._x,
              s = this._y,
              i = this._z,
              r = this._w;
            let o = r * t._w + n * t._x + s * t._y + i * t._z;
            if (
              (o < 0
                ? ((this._w = -t._w),
                  (this._x = -t._x),
                  (this._y = -t._y),
                  (this._z = -t._z),
                  (o = -o))
                : this.copy(t),
              o >= 1)
            )
              return (
                (this._w = r), (this._x = n), (this._y = s), (this._z = i), this
              );
            const a = 1 - o * o;
            if (a <= Number.EPSILON) {
              const t = 1 - e;
              return (
                (this._w = t * r + e * this._w),
                (this._x = t * n + e * this._x),
                (this._y = t * s + e * this._y),
                (this._z = t * i + e * this._z),
                this.normalize(),
                this._onChangeCallback(),
                this
              );
            }
            const c = Math.sqrt(a),
              u = Math.atan2(c, o),
              d = Math.sin((1 - e) * u) / c,
              l = Math.sin(e * u) / c;
            return (
              (this._w = r * d + this._w * l),
              (this._x = n * d + this._x * l),
              (this._y = s * d + this._y * l),
              (this._z = i * d + this._z * l),
              this._onChangeCallback(),
              this
            );
          }
          slerpQuaternions(t, e, n) {
            this.copy(t).slerp(e, n);
          }
          random() {
            const t = Math.random(),
              e = Math.sqrt(1 - t),
              n = Math.sqrt(t),
              s = 2 * Math.PI * Math.random(),
              i = 2 * Math.PI * Math.random();
            return this.set(
              e * Math.cos(s),
              n * Math.sin(i),
              n * Math.cos(i),
              e * Math.sin(s)
            );
          }
          equals(t) {
            return (
              t._x === this._x &&
              t._y === this._y &&
              t._z === this._z &&
              t._w === this._w
            );
          }
          fromArray(t, e = 0) {
            return (
              (this._x = t[e]),
              (this._y = t[e + 1]),
              (this._z = t[e + 2]),
              (this._w = t[e + 3]),
              this._onChangeCallback(),
              this
            );
          }
          toArray(t = [], e = 0) {
            return (
              (t[e] = this._x),
              (t[e + 1] = this._y),
              (t[e + 2] = this._z),
              (t[e + 3] = this._w),
              t
            );
          }
          fromBufferAttribute(t, e) {
            return (
              (this._x = t.getX(e)),
              (this._y = t.getY(e)),
              (this._z = t.getZ(e)),
              (this._w = t.getW(e)),
              this
            );
          }
          _onChange(t) {
            return (this._onChangeCallback = t), this;
          }
          _onChangeCallback() {}
        }
        ht.prototype.isQuaternion = !0;
        class ft {
          constructor(t = 0, e = 0, n = 0) {
            (this.x = t), (this.y = e), (this.z = n);
          }
          set(t, e, n) {
            return (
              void 0 === n && (n = this.z),
              (this.x = t),
              (this.y = e),
              (this.z = n),
              this
            );
          }
          setScalar(t) {
            return (this.x = t), (this.y = t), (this.z = t), this;
          }
          setX(t) {
            return (this.x = t), this;
          }
          setY(t) {
            return (this.y = t), this;
          }
          setZ(t) {
            return (this.z = t), this;
          }
          setComponent(t, e) {
            switch (t) {
              case 0:
                this.x = e;
                break;
              case 1:
                this.y = e;
                break;
              case 2:
                this.z = e;
                break;
              default:
                throw new Error("index is out of range: " + t);
            }
            return this;
          }
          getComponent(t) {
            switch (t) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              case 2:
                return this.z;
              default:
                throw new Error("index is out of range: " + t);
            }
          }
          clone() {
            return new this.constructor(this.x, this.y, this.z);
          }
          copy(t) {
            return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
          }
          add(t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
                ),
                this.addVectors(t, e))
              : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this);
          }
          addScalar(t) {
            return (this.x += t), (this.y += t), (this.z += t), this;
          }
          addVectors(t, e) {
            return (
              (this.x = t.x + e.x),
              (this.y = t.y + e.y),
              (this.z = t.z + e.z),
              this
            );
          }
          addScaledVector(t, e) {
            return (
              (this.x += t.x * e),
              (this.y += t.y * e),
              (this.z += t.z * e),
              this
            );
          }
          sub(t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
                ),
                this.subVectors(t, e))
              : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this);
          }
          subScalar(t) {
            return (this.x -= t), (this.y -= t), (this.z -= t), this;
          }
          subVectors(t, e) {
            return (
              (this.x = t.x - e.x),
              (this.y = t.y - e.y),
              (this.z = t.z - e.z),
              this
            );
          }
          multiply(t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
                ),
                this.multiplyVectors(t, e))
              : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this);
          }
          multiplyScalar(t) {
            return (this.x *= t), (this.y *= t), (this.z *= t), this;
          }
          multiplyVectors(t, e) {
            return (
              (this.x = t.x * e.x),
              (this.y = t.y * e.y),
              (this.z = t.z * e.z),
              this
            );
          }
          applyEuler(t) {
            return (
              (t && t.isEuler) ||
                console.error(
                  "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
                ),
              this.applyQuaternion(pt.setFromEuler(t))
            );
          }
          applyAxisAngle(t, e) {
            return this.applyQuaternion(pt.setFromAxisAngle(t, e));
          }
          applyMatrix3(t) {
            const e = this.x,
              n = this.y,
              s = this.z,
              i = t.elements;
            return (
              (this.x = i[0] * e + i[3] * n + i[6] * s),
              (this.y = i[1] * e + i[4] * n + i[7] * s),
              (this.z = i[2] * e + i[5] * n + i[8] * s),
              this
            );
          }
          applyNormalMatrix(t) {
            return this.applyMatrix3(t).normalize();
          }
          applyMatrix4(t) {
            const e = this.x,
              n = this.y,
              s = this.z,
              i = t.elements,
              r = 1 / (i[3] * e + i[7] * n + i[11] * s + i[15]);
            return (
              (this.x = (i[0] * e + i[4] * n + i[8] * s + i[12]) * r),
              (this.y = (i[1] * e + i[5] * n + i[9] * s + i[13]) * r),
              (this.z = (i[2] * e + i[6] * n + i[10] * s + i[14]) * r),
              this
            );
          }
          applyQuaternion(t) {
            const e = this.x,
              n = this.y,
              s = this.z,
              i = t.x,
              r = t.y,
              o = t.z,
              a = t.w,
              c = a * e + r * s - o * n,
              u = a * n + o * e - i * s,
              d = a * s + i * n - r * e,
              l = -i * e - r * n - o * s;
            return (
              (this.x = c * a + l * -i + u * -o - d * -r),
              (this.y = u * a + l * -r + d * -i - c * -o),
              (this.z = d * a + l * -o + c * -r - u * -i),
              this
            );
          }
          project(t) {
            return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
              t.projectionMatrix
            );
          }
          unproject(t) {
            return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
              t.matrixWorld
            );
          }
          transformDirection(t) {
            const e = this.x,
              n = this.y,
              s = this.z,
              i = t.elements;
            return (
              (this.x = i[0] * e + i[4] * n + i[8] * s),
              (this.y = i[1] * e + i[5] * n + i[9] * s),
              (this.z = i[2] * e + i[6] * n + i[10] * s),
              this.normalize()
            );
          }
          divide(t) {
            return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
          }
          divideScalar(t) {
            return this.multiplyScalar(1 / t);
          }
          min(t) {
            return (
              (this.x = Math.min(this.x, t.x)),
              (this.y = Math.min(this.y, t.y)),
              (this.z = Math.min(this.z, t.z)),
              this
            );
          }
          max(t) {
            return (
              (this.x = Math.max(this.x, t.x)),
              (this.y = Math.max(this.y, t.y)),
              (this.z = Math.max(this.z, t.z)),
              this
            );
          }
          clamp(t, e) {
            return (
              (this.x = Math.max(t.x, Math.min(e.x, this.x))),
              (this.y = Math.max(t.y, Math.min(e.y, this.y))),
              (this.z = Math.max(t.z, Math.min(e.z, this.z))),
              this
            );
          }
          clampScalar(t, e) {
            return (
              (this.x = Math.max(t, Math.min(e, this.x))),
              (this.y = Math.max(t, Math.min(e, this.y))),
              (this.z = Math.max(t, Math.min(e, this.z))),
              this
            );
          }
          clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(
              Math.max(t, Math.min(e, n))
            );
          }
          floor() {
            return (
              (this.x = Math.floor(this.x)),
              (this.y = Math.floor(this.y)),
              (this.z = Math.floor(this.z)),
              this
            );
          }
          ceil() {
            return (
              (this.x = Math.ceil(this.x)),
              (this.y = Math.ceil(this.y)),
              (this.z = Math.ceil(this.z)),
              this
            );
          }
          round() {
            return (
              (this.x = Math.round(this.x)),
              (this.y = Math.round(this.y)),
              (this.z = Math.round(this.z)),
              this
            );
          }
          roundToZero() {
            return (
              (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
              (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
              (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
              this
            );
          }
          negate() {
            return (
              (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
            );
          }
          dot(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z;
          }
          lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
          }
          length() {
            return Math.sqrt(
              this.x * this.x + this.y * this.y + this.z * this.z
            );
          }
          manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
          }
          normalize() {
            return this.divideScalar(this.length() || 1);
          }
          setLength(t) {
            return this.normalize().multiplyScalar(t);
          }
          lerp(t, e) {
            return (
              (this.x += (t.x - this.x) * e),
              (this.y += (t.y - this.y) * e),
              (this.z += (t.z - this.z) * e),
              this
            );
          }
          lerpVectors(t, e, n) {
            return (
              (this.x = t.x + (e.x - t.x) * n),
              (this.y = t.y + (e.y - t.y) * n),
              (this.z = t.z + (e.z - t.z) * n),
              this
            );
          }
          cross(t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
                ),
                this.crossVectors(t, e))
              : this.crossVectors(this, t);
          }
          crossVectors(t, e) {
            const n = t.x,
              s = t.y,
              i = t.z,
              r = e.x,
              o = e.y,
              a = e.z;
            return (
              (this.x = s * a - i * o),
              (this.y = i * r - n * a),
              (this.z = n * o - s * r),
              this
            );
          }
          projectOnVector(t) {
            const e = t.lengthSq();
            if (0 === e) return this.set(0, 0, 0);
            const n = t.dot(this) / e;
            return this.copy(t).multiplyScalar(n);
          }
          projectOnPlane(t) {
            return mt.copy(this).projectOnVector(t), this.sub(mt);
          }
          reflect(t) {
            return this.sub(mt.copy(t).multiplyScalar(2 * this.dot(t)));
          }
          angleTo(t) {
            const e = Math.sqrt(this.lengthSq() * t.lengthSq());
            if (0 === e) return Math.PI / 2;
            const n = this.dot(t) / e;
            return Math.acos(X(n, -1, 1));
          }
          distanceTo(t) {
            return Math.sqrt(this.distanceToSquared(t));
          }
          distanceToSquared(t) {
            const e = this.x - t.x,
              n = this.y - t.y,
              s = this.z - t.z;
            return e * e + n * n + s * s;
          }
          manhattanDistanceTo(t) {
            return (
              Math.abs(this.x - t.x) +
              Math.abs(this.y - t.y) +
              Math.abs(this.z - t.z)
            );
          }
          setFromSpherical(t) {
            return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
          }
          setFromSphericalCoords(t, e, n) {
            const s = Math.sin(e) * t;
            return (
              (this.x = s * Math.sin(n)),
              (this.y = Math.cos(e) * t),
              (this.z = s * Math.cos(n)),
              this
            );
          }
          setFromCylindrical(t) {
            return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
          }
          setFromCylindricalCoords(t, e, n) {
            return (
              (this.x = t * Math.sin(e)),
              (this.y = n),
              (this.z = t * Math.cos(e)),
              this
            );
          }
          setFromMatrixPosition(t) {
            const e = t.elements;
            return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
          }
          setFromMatrixScale(t) {
            const e = this.setFromMatrixColumn(t, 0).length(),
              n = this.setFromMatrixColumn(t, 1).length(),
              s = this.setFromMatrixColumn(t, 2).length();
            return (this.x = e), (this.y = n), (this.z = s), this;
          }
          setFromMatrixColumn(t, e) {
            return this.fromArray(t.elements, 4 * e);
          }
          setFromMatrix3Column(t, e) {
            return this.fromArray(t.elements, 3 * e);
          }
          equals(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z;
          }
          fromArray(t, e = 0) {
            return (
              (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this
            );
          }
          toArray(t = [], e = 0) {
            return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;
          }
          fromBufferAttribute(t, e, n) {
            return (
              void 0 !== n &&
                console.warn(
                  "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
                ),
              (this.x = t.getX(e)),
              (this.y = t.getY(e)),
              (this.z = t.getZ(e)),
              this
            );
          }
          random() {
            return (
              (this.x = Math.random()),
              (this.y = Math.random()),
              (this.z = Math.random()),
              this
            );
          }
          randomDirection() {
            const t = 2 * (Math.random() - 0.5),
              e = Math.random() * Math.PI * 2,
              n = Math.sqrt(1 - t ** 2);
            return (
              (this.x = n * Math.cos(e)),
              (this.y = n * Math.sin(e)),
              (this.z = t),
              this
            );
          }
          *[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z;
          }
        }
        ft.prototype.isVector3 = !0;
        const mt = new ft(),
          pt = new ht();
        class gt {
          constructor(
            t = new ft(1 / 0, 1 / 0, 1 / 0),
            e = new ft(-1 / 0, -1 / 0, -1 / 0)
          ) {
            (this.min = t), (this.max = e);
          }
          set(t, e) {
            return this.min.copy(t), this.max.copy(e), this;
          }
          setFromArray(t) {
            let e = 1 / 0,
              n = 1 / 0,
              s = 1 / 0,
              i = -1 / 0,
              r = -1 / 0,
              o = -1 / 0;
            for (let a = 0, c = t.length; a < c; a += 3) {
              const c = t[a],
                u = t[a + 1],
                d = t[a + 2];
              c < e && (e = c),
                u < n && (n = u),
                d < s && (s = d),
                c > i && (i = c),
                u > r && (r = u),
                d > o && (o = d);
            }
            return this.min.set(e, n, s), this.max.set(i, r, o), this;
          }
          setFromBufferAttribute(t) {
            let e = 1 / 0,
              n = 1 / 0,
              s = 1 / 0,
              i = -1 / 0,
              r = -1 / 0,
              o = -1 / 0;
            for (let a = 0, c = t.count; a < c; a++) {
              const c = t.getX(a),
                u = t.getY(a),
                d = t.getZ(a);
              c < e && (e = c),
                u < n && (n = u),
                d < s && (s = d),
                c > i && (i = c),
                u > r && (r = u),
                d > o && (o = d);
            }
            return this.min.set(e, n, s), this.max.set(i, r, o), this;
          }
          setFromPoints(t) {
            this.makeEmpty();
            for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
            return this;
          }
          setFromCenterAndSize(t, e) {
            const n = vt.copy(e).multiplyScalar(0.5);
            return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
          }
          setFromObject(t) {
            return this.makeEmpty(), this.expandByObject(t);
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return this.min.copy(t.min), this.max.copy(t.max), this;
          }
          makeEmpty() {
            return (
              (this.min.x = this.min.y = this.min.z = 1 / 0),
              (this.max.x = this.max.y = this.max.z = -1 / 0),
              this
            );
          }
          isEmpty() {
            return (
              this.max.x < this.min.x ||
              this.max.y < this.min.y ||
              this.max.z < this.min.z
            );
          }
          getCenter(t) {
            return this.isEmpty()
              ? t.set(0, 0, 0)
              : t.addVectors(this.min, this.max).multiplyScalar(0.5);
          }
          getSize(t) {
            return this.isEmpty()
              ? t.set(0, 0, 0)
              : t.subVectors(this.max, this.min);
          }
          expandByPoint(t) {
            return this.min.min(t), this.max.max(t), this;
          }
          expandByVector(t) {
            return this.min.sub(t), this.max.add(t), this;
          }
          expandByScalar(t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this;
          }
          expandByObject(t) {
            t.updateWorldMatrix(!1, !1);
            const e = t.geometry;
            void 0 !== e &&
              (null === e.boundingBox && e.computeBoundingBox(),
              yt.copy(e.boundingBox),
              yt.applyMatrix4(t.matrixWorld),
              this.union(yt));
            const n = t.children;
            for (let t = 0, e = n.length; t < e; t++) this.expandByObject(n[t]);
            return this;
          }
          containsPoint(t) {
            return !(
              t.x < this.min.x ||
              t.x > this.max.x ||
              t.y < this.min.y ||
              t.y > this.max.y ||
              t.z < this.min.z ||
              t.z > this.max.z
            );
          }
          containsBox(t) {
            return (
              this.min.x <= t.min.x &&
              t.max.x <= this.max.x &&
              this.min.y <= t.min.y &&
              t.max.y <= this.max.y &&
              this.min.z <= t.min.z &&
              t.max.z <= this.max.z
            );
          }
          getParameter(t, e) {
            return e.set(
              (t.x - this.min.x) / (this.max.x - this.min.x),
              (t.y - this.min.y) / (this.max.y - this.min.y),
              (t.z - this.min.z) / (this.max.z - this.min.z)
            );
          }
          intersectsBox(t) {
            return !(
              t.max.x < this.min.x ||
              t.min.x > this.max.x ||
              t.max.y < this.min.y ||
              t.min.y > this.max.y ||
              t.max.z < this.min.z ||
              t.min.z > this.max.z
            );
          }
          intersectsSphere(t) {
            return (
              this.clampPoint(t.center, vt),
              vt.distanceToSquared(t.center) <= t.radius * t.radius
            );
          }
          intersectsPlane(t) {
            let e, n;
            return (
              t.normal.x > 0
                ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
                : ((e = t.normal.x * this.max.x),
                  (n = t.normal.x * this.min.x)),
              t.normal.y > 0
                ? ((e += t.normal.y * this.min.y),
                  (n += t.normal.y * this.max.y))
                : ((e += t.normal.y * this.max.y),
                  (n += t.normal.y * this.min.y)),
              t.normal.z > 0
                ? ((e += t.normal.z * this.min.z),
                  (n += t.normal.z * this.max.z))
                : ((e += t.normal.z * this.max.z),
                  (n += t.normal.z * this.min.z)),
              e <= -t.constant && n >= -t.constant
            );
          }
          intersectsTriangle(t) {
            if (this.isEmpty()) return !1;
            this.getCenter(Et),
              Ct.subVectors(this.max, Et),
              wt.subVectors(t.a, Et),
              _t.subVectors(t.b, Et),
              bt.subVectors(t.c, Et),
              Mt.subVectors(_t, wt),
              St.subVectors(bt, _t),
              Tt.subVectors(wt, bt);
            let e = [
              0,
              -Mt.z,
              Mt.y,
              0,
              -St.z,
              St.y,
              0,
              -Tt.z,
              Tt.y,
              Mt.z,
              0,
              -Mt.x,
              St.z,
              0,
              -St.x,
              Tt.z,
              0,
              -Tt.x,
              -Mt.y,
              Mt.x,
              0,
              -St.y,
              St.x,
              0,
              -Tt.y,
              Tt.x,
              0,
            ];
            return (
              !!Rt(e, wt, _t, bt, Ct) &&
              ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
              !!Rt(e, wt, _t, bt, Ct) &&
                (At.crossVectors(Mt, St),
                (e = [At.x, At.y, At.z]),
                Rt(e, wt, _t, bt, Ct)))
            );
          }
          clampPoint(t, e) {
            return e.copy(t).clamp(this.min, this.max);
          }
          distanceToPoint(t) {
            return vt.copy(t).clamp(this.min, this.max).sub(t).length();
          }
          getBoundingSphere(t) {
            return (
              this.getCenter(t.center),
              (t.radius = 0.5 * this.getSize(vt).length()),
              t
            );
          }
          intersect(t) {
            return (
              this.min.max(t.min),
              this.max.min(t.max),
              this.isEmpty() && this.makeEmpty(),
              this
            );
          }
          union(t) {
            return this.min.min(t.min), this.max.max(t.max), this;
          }
          applyMatrix4(t) {
            return (
              this.isEmpty() ||
                (xt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
                xt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
                xt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
                xt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
                xt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
                xt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
                xt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
                xt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
                this.setFromPoints(xt)),
              this
            );
          }
          translate(t) {
            return this.min.add(t), this.max.add(t), this;
          }
          equals(t) {
            return t.min.equals(this.min) && t.max.equals(this.max);
          }
        }
        gt.prototype.isBox3 = !0;
        const xt = [
            new ft(),
            new ft(),
            new ft(),
            new ft(),
            new ft(),
            new ft(),
            new ft(),
            new ft(),
          ],
          vt = new ft(),
          yt = new gt(),
          wt = new ft(),
          _t = new ft(),
          bt = new ft(),
          Mt = new ft(),
          St = new ft(),
          Tt = new ft(),
          Et = new ft(),
          Ct = new ft(),
          At = new ft(),
          Lt = new ft();
        function Rt(t, e, n, s, i) {
          for (let r = 0, o = t.length - 3; r <= o; r += 3) {
            Lt.fromArray(t, r);
            const o =
                i.x * Math.abs(Lt.x) +
                i.y * Math.abs(Lt.y) +
                i.z * Math.abs(Lt.z),
              a = e.dot(Lt),
              c = n.dot(Lt),
              u = s.dot(Lt);
            if (Math.max(-Math.max(a, c, u), Math.min(a, c, u)) > o) return !1;
          }
          return !0;
        }
        const Pt = new gt(),
          It = new ft(),
          Dt = new ft(),
          Nt = new ft();
        class Ot {
          constructor(t = new ft(), e = -1) {
            (this.center = t), (this.radius = e);
          }
          set(t, e) {
            return this.center.copy(t), (this.radius = e), this;
          }
          setFromPoints(t, e) {
            const n = this.center;
            void 0 !== e ? n.copy(e) : Pt.setFromPoints(t).getCenter(n);
            let s = 0;
            for (let e = 0, i = t.length; e < i; e++)
              s = Math.max(s, n.distanceToSquared(t[e]));
            return (this.radius = Math.sqrt(s)), this;
          }
          copy(t) {
            return this.center.copy(t.center), (this.radius = t.radius), this;
          }
          isEmpty() {
            return this.radius < 0;
          }
          makeEmpty() {
            return this.center.set(0, 0, 0), (this.radius = -1), this;
          }
          containsPoint(t) {
            return (
              t.distanceToSquared(this.center) <= this.radius * this.radius
            );
          }
          distanceToPoint(t) {
            return t.distanceTo(this.center) - this.radius;
          }
          intersectsSphere(t) {
            const e = this.radius + t.radius;
            return t.center.distanceToSquared(this.center) <= e * e;
          }
          intersectsBox(t) {
            return t.intersectsSphere(this);
          }
          intersectsPlane(t) {
            return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
          }
          clampPoint(t, e) {
            const n = this.center.distanceToSquared(t);
            return (
              e.copy(t),
              n > this.radius * this.radius &&
                (e.sub(this.center).normalize(),
                e.multiplyScalar(this.radius).add(this.center)),
              e
            );
          }
          getBoundingBox(t) {
            return this.isEmpty()
              ? (t.makeEmpty(), t)
              : (t.set(this.center, this.center),
                t.expandByScalar(this.radius),
                t);
          }
          applyMatrix4(t) {
            return (
              this.center.applyMatrix4(t),
              (this.radius = this.radius * t.getMaxScaleOnAxis()),
              this
            );
          }
          translate(t) {
            return this.center.add(t), this;
          }
          expandByPoint(t) {
            Nt.subVectors(t, this.center);
            const e = Nt.lengthSq();
            if (e > this.radius * this.radius) {
              const t = Math.sqrt(e),
                n = 0.5 * (t - this.radius);
              this.center.add(Nt.multiplyScalar(n / t)), (this.radius += n);
            }
            return this;
          }
          union(t) {
            return (
              Dt.subVectors(t.center, this.center)
                .normalize()
                .multiplyScalar(t.radius),
              this.expandByPoint(It.copy(t.center).add(Dt)),
              this.expandByPoint(It.copy(t.center).sub(Dt)),
              this
            );
          }
          equals(t) {
            return t.center.equals(this.center) && t.radius === this.radius;
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        const kt = new ft(),
          Ut = new ft(),
          zt = new ft(),
          Ft = new ft(),
          Bt = new ft(),
          Ht = new ft(),
          Gt = new ft();
        class Vt {
          constructor(t = new ft(), e = new ft(0, 0, -1)) {
            (this.origin = t), (this.direction = e);
          }
          set(t, e) {
            return this.origin.copy(t), this.direction.copy(e), this;
          }
          copy(t) {
            return (
              this.origin.copy(t.origin), this.direction.copy(t.direction), this
            );
          }
          at(t, e) {
            return e.copy(this.direction).multiplyScalar(t).add(this.origin);
          }
          lookAt(t) {
            return this.direction.copy(t).sub(this.origin).normalize(), this;
          }
          recast(t) {
            return this.origin.copy(this.at(t, kt)), this;
          }
          closestPointToPoint(t, e) {
            e.subVectors(t, this.origin);
            const n = e.dot(this.direction);
            return n < 0
              ? e.copy(this.origin)
              : e.copy(this.direction).multiplyScalar(n).add(this.origin);
          }
          distanceToPoint(t) {
            return Math.sqrt(this.distanceSqToPoint(t));
          }
          distanceSqToPoint(t) {
            const e = kt.subVectors(t, this.origin).dot(this.direction);
            return e < 0
              ? this.origin.distanceToSquared(t)
              : (kt.copy(this.direction).multiplyScalar(e).add(this.origin),
                kt.distanceToSquared(t));
          }
          distanceSqToSegment(t, e, n, s) {
            Ut.copy(t).add(e).multiplyScalar(0.5),
              zt.copy(e).sub(t).normalize(),
              Ft.copy(this.origin).sub(Ut);
            const i = 0.5 * t.distanceTo(e),
              r = -this.direction.dot(zt),
              o = Ft.dot(this.direction),
              a = -Ft.dot(zt),
              c = Ft.lengthSq(),
              u = Math.abs(1 - r * r);
            let d, l, h, f;
            if (u > 0)
              if (((d = r * a - o), (l = r * o - a), (f = i * u), d >= 0))
                if (l >= -f)
                  if (l <= f) {
                    const t = 1 / u;
                    (d *= t),
                      (l *= t),
                      (h =
                        d * (d + r * l + 2 * o) + l * (r * d + l + 2 * a) + c);
                  } else
                    (l = i),
                      (d = Math.max(0, -(r * l + o))),
                      (h = -d * d + l * (l + 2 * a) + c);
                else
                  (l = -i),
                    (d = Math.max(0, -(r * l + o))),
                    (h = -d * d + l * (l + 2 * a) + c);
              else
                l <= -f
                  ? ((d = Math.max(0, -(-r * i + o))),
                    (l = d > 0 ? -i : Math.min(Math.max(-i, -a), i)),
                    (h = -d * d + l * (l + 2 * a) + c))
                  : l <= f
                  ? ((d = 0),
                    (l = Math.min(Math.max(-i, -a), i)),
                    (h = l * (l + 2 * a) + c))
                  : ((d = Math.max(0, -(r * i + o))),
                    (l = d > 0 ? i : Math.min(Math.max(-i, -a), i)),
                    (h = -d * d + l * (l + 2 * a) + c));
            else
              (l = r > 0 ? -i : i),
                (d = Math.max(0, -(r * l + o))),
                (h = -d * d + l * (l + 2 * a) + c);
            return (
              n && n.copy(this.direction).multiplyScalar(d).add(this.origin),
              s && s.copy(zt).multiplyScalar(l).add(Ut),
              h
            );
          }
          intersectSphere(t, e) {
            kt.subVectors(t.center, this.origin);
            const n = kt.dot(this.direction),
              s = kt.dot(kt) - n * n,
              i = t.radius * t.radius;
            if (s > i) return null;
            const r = Math.sqrt(i - s),
              o = n - r,
              a = n + r;
            return o < 0 && a < 0
              ? null
              : o < 0
              ? this.at(a, e)
              : this.at(o, e);
          }
          intersectsSphere(t) {
            return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
          }
          distanceToPlane(t) {
            const e = t.normal.dot(this.direction);
            if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
            const n = -(this.origin.dot(t.normal) + t.constant) / e;
            return n >= 0 ? n : null;
          }
          intersectPlane(t, e) {
            const n = this.distanceToPlane(t);
            return null === n ? null : this.at(n, e);
          }
          intersectsPlane(t) {
            const e = t.distanceToPoint(this.origin);
            return 0 === e || t.normal.dot(this.direction) * e < 0;
          }
          intersectBox(t, e) {
            let n, s, i, r, o, a;
            const c = 1 / this.direction.x,
              u = 1 / this.direction.y,
              d = 1 / this.direction.z,
              l = this.origin;
            return (
              c >= 0
                ? ((n = (t.min.x - l.x) * c), (s = (t.max.x - l.x) * c))
                : ((n = (t.max.x - l.x) * c), (s = (t.min.x - l.x) * c)),
              u >= 0
                ? ((i = (t.min.y - l.y) * u), (r = (t.max.y - l.y) * u))
                : ((i = (t.max.y - l.y) * u), (r = (t.min.y - l.y) * u)),
              n > r || i > s
                ? null
                : ((i > n || n != n) && (n = i),
                  (r < s || s != s) && (s = r),
                  d >= 0
                    ? ((o = (t.min.z - l.z) * d), (a = (t.max.z - l.z) * d))
                    : ((o = (t.max.z - l.z) * d), (a = (t.min.z - l.z) * d)),
                  n > a || o > s
                    ? null
                    : ((o > n || n != n) && (n = o),
                      (a < s || s != s) && (s = a),
                      s < 0 ? null : this.at(n >= 0 ? n : s, e)))
            );
          }
          intersectsBox(t) {
            return null !== this.intersectBox(t, kt);
          }
          intersectTriangle(t, e, n, s, i) {
            Bt.subVectors(e, t), Ht.subVectors(n, t), Gt.crossVectors(Bt, Ht);
            let r,
              o = this.direction.dot(Gt);
            if (o > 0) {
              if (s) return null;
              r = 1;
            } else {
              if (!(o < 0)) return null;
              (r = -1), (o = -o);
            }
            Ft.subVectors(this.origin, t);
            const a = r * this.direction.dot(Ht.crossVectors(Ft, Ht));
            if (a < 0) return null;
            const c = r * this.direction.dot(Bt.cross(Ft));
            if (c < 0) return null;
            if (a + c > o) return null;
            const u = -r * Ft.dot(Gt);
            return u < 0 ? null : this.at(u / o, i);
          }
          applyMatrix4(t) {
            return (
              this.origin.applyMatrix4(t),
              this.direction.transformDirection(t),
              this
            );
          }
          equals(t) {
            return (
              t.origin.equals(this.origin) && t.direction.equals(this.direction)
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        class Wt {
          constructor() {
            (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
              arguments.length > 0 &&
                console.error(
                  "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
                );
          }
          set(t, e, n, s, i, r, o, a, c, u, d, l, h, f, m, p) {
            const g = this.elements;
            return (
              (g[0] = t),
              (g[4] = e),
              (g[8] = n),
              (g[12] = s),
              (g[1] = i),
              (g[5] = r),
              (g[9] = o),
              (g[13] = a),
              (g[2] = c),
              (g[6] = u),
              (g[10] = d),
              (g[14] = l),
              (g[3] = h),
              (g[7] = f),
              (g[11] = m),
              (g[15] = p),
              this
            );
          }
          identity() {
            return (
              this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            );
          }
          clone() {
            return new Wt().fromArray(this.elements);
          }
          copy(t) {
            const e = this.elements,
              n = t.elements;
            return (
              (e[0] = n[0]),
              (e[1] = n[1]),
              (e[2] = n[2]),
              (e[3] = n[3]),
              (e[4] = n[4]),
              (e[5] = n[5]),
              (e[6] = n[6]),
              (e[7] = n[7]),
              (e[8] = n[8]),
              (e[9] = n[9]),
              (e[10] = n[10]),
              (e[11] = n[11]),
              (e[12] = n[12]),
              (e[13] = n[13]),
              (e[14] = n[14]),
              (e[15] = n[15]),
              this
            );
          }
          copyPosition(t) {
            const e = this.elements,
              n = t.elements;
            return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
          }
          setFromMatrix3(t) {
            const e = t.elements;
            return (
              this.set(
                e[0],
                e[3],
                e[6],
                0,
                e[1],
                e[4],
                e[7],
                0,
                e[2],
                e[5],
                e[8],
                0,
                0,
                0,
                0,
                1
              ),
              this
            );
          }
          extractBasis(t, e, n) {
            return (
              t.setFromMatrixColumn(this, 0),
              e.setFromMatrixColumn(this, 1),
              n.setFromMatrixColumn(this, 2),
              this
            );
          }
          makeBasis(t, e, n) {
            return (
              this.set(
                t.x,
                e.x,
                n.x,
                0,
                t.y,
                e.y,
                n.y,
                0,
                t.z,
                e.z,
                n.z,
                0,
                0,
                0,
                0,
                1
              ),
              this
            );
          }
          extractRotation(t) {
            const e = this.elements,
              n = t.elements,
              s = 1 / jt.setFromMatrixColumn(t, 0).length(),
              i = 1 / jt.setFromMatrixColumn(t, 1).length(),
              r = 1 / jt.setFromMatrixColumn(t, 2).length();
            return (
              (e[0] = n[0] * s),
              (e[1] = n[1] * s),
              (e[2] = n[2] * s),
              (e[3] = 0),
              (e[4] = n[4] * i),
              (e[5] = n[5] * i),
              (e[6] = n[6] * i),
              (e[7] = 0),
              (e[8] = n[8] * r),
              (e[9] = n[9] * r),
              (e[10] = n[10] * r),
              (e[11] = 0),
              (e[12] = 0),
              (e[13] = 0),
              (e[14] = 0),
              (e[15] = 1),
              this
            );
          }
          makeRotationFromEuler(t) {
            (t && t.isEuler) ||
              console.error(
                "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
              );
            const e = this.elements,
              n = t.x,
              s = t.y,
              i = t.z,
              r = Math.cos(n),
              o = Math.sin(n),
              a = Math.cos(s),
              c = Math.sin(s),
              u = Math.cos(i),
              d = Math.sin(i);
            if ("XYZ" === t.order) {
              const t = r * u,
                n = r * d,
                s = o * u,
                i = o * d;
              (e[0] = a * u),
                (e[4] = -a * d),
                (e[8] = c),
                (e[1] = n + s * c),
                (e[5] = t - i * c),
                (e[9] = -o * a),
                (e[2] = i - t * c),
                (e[6] = s + n * c),
                (e[10] = r * a);
            } else if ("YXZ" === t.order) {
              const t = a * u,
                n = a * d,
                s = c * u,
                i = c * d;
              (e[0] = t + i * o),
                (e[4] = s * o - n),
                (e[8] = r * c),
                (e[1] = r * d),
                (e[5] = r * u),
                (e[9] = -o),
                (e[2] = n * o - s),
                (e[6] = i + t * o),
                (e[10] = r * a);
            } else if ("ZXY" === t.order) {
              const t = a * u,
                n = a * d,
                s = c * u,
                i = c * d;
              (e[0] = t - i * o),
                (e[4] = -r * d),
                (e[8] = s + n * o),
                (e[1] = n + s * o),
                (e[5] = r * u),
                (e[9] = i - t * o),
                (e[2] = -r * c),
                (e[6] = o),
                (e[10] = r * a);
            } else if ("ZYX" === t.order) {
              const t = r * u,
                n = r * d,
                s = o * u,
                i = o * d;
              (e[0] = a * u),
                (e[4] = s * c - n),
                (e[8] = t * c + i),
                (e[1] = a * d),
                (e[5] = i * c + t),
                (e[9] = n * c - s),
                (e[2] = -c),
                (e[6] = o * a),
                (e[10] = r * a);
            } else if ("YZX" === t.order) {
              const t = r * a,
                n = r * c,
                s = o * a,
                i = o * c;
              (e[0] = a * u),
                (e[4] = i - t * d),
                (e[8] = s * d + n),
                (e[1] = d),
                (e[5] = r * u),
                (e[9] = -o * u),
                (e[2] = -c * u),
                (e[6] = n * d + s),
                (e[10] = t - i * d);
            } else if ("XZY" === t.order) {
              const t = r * a,
                n = r * c,
                s = o * a,
                i = o * c;
              (e[0] = a * u),
                (e[4] = -d),
                (e[8] = c * u),
                (e[1] = t * d + i),
                (e[5] = r * u),
                (e[9] = n * d - s),
                (e[2] = s * d - n),
                (e[6] = o * u),
                (e[10] = i * d + t);
            }
            return (
              (e[3] = 0),
              (e[7] = 0),
              (e[11] = 0),
              (e[12] = 0),
              (e[13] = 0),
              (e[14] = 0),
              (e[15] = 1),
              this
            );
          }
          makeRotationFromQuaternion(t) {
            return this.compose(qt, t, Yt);
          }
          lookAt(t, e, n) {
            const s = this.elements;
            return (
              $t.subVectors(t, e),
              0 === $t.lengthSq() && ($t.z = 1),
              $t.normalize(),
              Jt.crossVectors(n, $t),
              0 === Jt.lengthSq() &&
                (1 === Math.abs(n.z) ? ($t.x += 1e-4) : ($t.z += 1e-4),
                $t.normalize(),
                Jt.crossVectors(n, $t)),
              Jt.normalize(),
              Zt.crossVectors($t, Jt),
              (s[0] = Jt.x),
              (s[4] = Zt.x),
              (s[8] = $t.x),
              (s[1] = Jt.y),
              (s[5] = Zt.y),
              (s[9] = $t.y),
              (s[2] = Jt.z),
              (s[6] = Zt.z),
              (s[10] = $t.z),
              this
            );
          }
          multiply(t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
                ),
                this.multiplyMatrices(t, e))
              : this.multiplyMatrices(this, t);
          }
          premultiply(t) {
            return this.multiplyMatrices(t, this);
          }
          multiplyMatrices(t, e) {
            const n = t.elements,
              s = e.elements,
              i = this.elements,
              r = n[0],
              o = n[4],
              a = n[8],
              c = n[12],
              u = n[1],
              d = n[5],
              l = n[9],
              h = n[13],
              f = n[2],
              m = n[6],
              p = n[10],
              g = n[14],
              x = n[3],
              v = n[7],
              y = n[11],
              w = n[15],
              _ = s[0],
              b = s[4],
              M = s[8],
              S = s[12],
              T = s[1],
              E = s[5],
              C = s[9],
              A = s[13],
              L = s[2],
              R = s[6],
              P = s[10],
              I = s[14],
              D = s[3],
              N = s[7],
              O = s[11],
              k = s[15];
            return (
              (i[0] = r * _ + o * T + a * L + c * D),
              (i[4] = r * b + o * E + a * R + c * N),
              (i[8] = r * M + o * C + a * P + c * O),
              (i[12] = r * S + o * A + a * I + c * k),
              (i[1] = u * _ + d * T + l * L + h * D),
              (i[5] = u * b + d * E + l * R + h * N),
              (i[9] = u * M + d * C + l * P + h * O),
              (i[13] = u * S + d * A + l * I + h * k),
              (i[2] = f * _ + m * T + p * L + g * D),
              (i[6] = f * b + m * E + p * R + g * N),
              (i[10] = f * M + m * C + p * P + g * O),
              (i[14] = f * S + m * A + p * I + g * k),
              (i[3] = x * _ + v * T + y * L + w * D),
              (i[7] = x * b + v * E + y * R + w * N),
              (i[11] = x * M + v * C + y * P + w * O),
              (i[15] = x * S + v * A + y * I + w * k),
              this
            );
          }
          multiplyScalar(t) {
            const e = this.elements;
            return (
              (e[0] *= t),
              (e[4] *= t),
              (e[8] *= t),
              (e[12] *= t),
              (e[1] *= t),
              (e[5] *= t),
              (e[9] *= t),
              (e[13] *= t),
              (e[2] *= t),
              (e[6] *= t),
              (e[10] *= t),
              (e[14] *= t),
              (e[3] *= t),
              (e[7] *= t),
              (e[11] *= t),
              (e[15] *= t),
              this
            );
          }
          determinant() {
            const t = this.elements,
              e = t[0],
              n = t[4],
              s = t[8],
              i = t[12],
              r = t[1],
              o = t[5],
              a = t[9],
              c = t[13],
              u = t[2],
              d = t[6],
              l = t[10],
              h = t[14];
            return (
              t[3] *
                (+i * a * d -
                  s * c * d -
                  i * o * l +
                  n * c * l +
                  s * o * h -
                  n * a * h) +
              t[7] *
                (+e * a * h -
                  e * c * l +
                  i * r * l -
                  s * r * h +
                  s * c * u -
                  i * a * u) +
              t[11] *
                (+e * c * d -
                  e * o * h -
                  i * r * d +
                  n * r * h +
                  i * o * u -
                  n * c * u) +
              t[15] *
                (-s * o * u -
                  e * a * d +
                  e * o * l +
                  s * r * d -
                  n * r * l +
                  n * a * u)
            );
          }
          transpose() {
            const t = this.elements;
            let e;
            return (
              (e = t[1]),
              (t[1] = t[4]),
              (t[4] = e),
              (e = t[2]),
              (t[2] = t[8]),
              (t[8] = e),
              (e = t[6]),
              (t[6] = t[9]),
              (t[9] = e),
              (e = t[3]),
              (t[3] = t[12]),
              (t[12] = e),
              (e = t[7]),
              (t[7] = t[13]),
              (t[13] = e),
              (e = t[11]),
              (t[11] = t[14]),
              (t[14] = e),
              this
            );
          }
          setPosition(t, e, n) {
            const s = this.elements;
            return (
              t.isVector3
                ? ((s[12] = t.x), (s[13] = t.y), (s[14] = t.z))
                : ((s[12] = t), (s[13] = e), (s[14] = n)),
              this
            );
          }
          invert() {
            const t = this.elements,
              e = t[0],
              n = t[1],
              s = t[2],
              i = t[3],
              r = t[4],
              o = t[5],
              a = t[6],
              c = t[7],
              u = t[8],
              d = t[9],
              l = t[10],
              h = t[11],
              f = t[12],
              m = t[13],
              p = t[14],
              g = t[15],
              x =
                d * p * c -
                m * l * c +
                m * a * h -
                o * p * h -
                d * a * g +
                o * l * g,
              v =
                f * l * c -
                u * p * c -
                f * a * h +
                r * p * h +
                u * a * g -
                r * l * g,
              y =
                u * m * c -
                f * d * c +
                f * o * h -
                r * m * h -
                u * o * g +
                r * d * g,
              w =
                f * d * a -
                u * m * a -
                f * o * l +
                r * m * l +
                u * o * p -
                r * d * p,
              _ = e * x + n * v + s * y + i * w;
            if (0 === _)
              return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            const b = 1 / _;
            return (
              (t[0] = x * b),
              (t[1] =
                (m * l * i -
                  d * p * i -
                  m * s * h +
                  n * p * h +
                  d * s * g -
                  n * l * g) *
                b),
              (t[2] =
                (o * p * i -
                  m * a * i +
                  m * s * c -
                  n * p * c -
                  o * s * g +
                  n * a * g) *
                b),
              (t[3] =
                (d * a * i -
                  o * l * i -
                  d * s * c +
                  n * l * c +
                  o * s * h -
                  n * a * h) *
                b),
              (t[4] = v * b),
              (t[5] =
                (u * p * i -
                  f * l * i +
                  f * s * h -
                  e * p * h -
                  u * s * g +
                  e * l * g) *
                b),
              (t[6] =
                (f * a * i -
                  r * p * i -
                  f * s * c +
                  e * p * c +
                  r * s * g -
                  e * a * g) *
                b),
              (t[7] =
                (r * l * i -
                  u * a * i +
                  u * s * c -
                  e * l * c -
                  r * s * h +
                  e * a * h) *
                b),
              (t[8] = y * b),
              (t[9] =
                (f * d * i -
                  u * m * i -
                  f * n * h +
                  e * m * h +
                  u * n * g -
                  e * d * g) *
                b),
              (t[10] =
                (r * m * i -
                  f * o * i +
                  f * n * c -
                  e * m * c -
                  r * n * g +
                  e * o * g) *
                b),
              (t[11] =
                (u * o * i -
                  r * d * i -
                  u * n * c +
                  e * d * c +
                  r * n * h -
                  e * o * h) *
                b),
              (t[12] = w * b),
              (t[13] =
                (u * m * s -
                  f * d * s +
                  f * n * l -
                  e * m * l -
                  u * n * p +
                  e * d * p) *
                b),
              (t[14] =
                (f * o * s -
                  r * m * s -
                  f * n * a +
                  e * m * a +
                  r * n * p -
                  e * o * p) *
                b),
              (t[15] =
                (r * d * s -
                  u * o * s +
                  u * n * a -
                  e * d * a -
                  r * n * l +
                  e * o * l) *
                b),
              this
            );
          }
          scale(t) {
            const e = this.elements,
              n = t.x,
              s = t.y,
              i = t.z;
            return (
              (e[0] *= n),
              (e[4] *= s),
              (e[8] *= i),
              (e[1] *= n),
              (e[5] *= s),
              (e[9] *= i),
              (e[2] *= n),
              (e[6] *= s),
              (e[10] *= i),
              (e[3] *= n),
              (e[7] *= s),
              (e[11] *= i),
              this
            );
          }
          getMaxScaleOnAxis() {
            const t = this.elements,
              e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
              n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
              s = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
            return Math.sqrt(Math.max(e, n, s));
          }
          makeTranslation(t, e, n) {
            return (
              this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
            );
          }
          makeRotationX(t) {
            const e = Math.cos(t),
              n = Math.sin(t);
            return (
              this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
            );
          }
          makeRotationY(t) {
            const e = Math.cos(t),
              n = Math.sin(t);
            return (
              this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
            );
          }
          makeRotationZ(t) {
            const e = Math.cos(t),
              n = Math.sin(t);
            return (
              this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            );
          }
          makeRotationAxis(t, e) {
            const n = Math.cos(e),
              s = Math.sin(e),
              i = 1 - n,
              r = t.x,
              o = t.y,
              a = t.z,
              c = i * r,
              u = i * o;
            return (
              this.set(
                c * r + n,
                c * o - s * a,
                c * a + s * o,
                0,
                c * o + s * a,
                u * o + n,
                u * a - s * r,
                0,
                c * a - s * o,
                u * a + s * r,
                i * a * a + n,
                0,
                0,
                0,
                0,
                1
              ),
              this
            );
          }
          makeScale(t, e, n) {
            return (
              this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
            );
          }
          makeShear(t, e, n, s, i, r) {
            return (
              this.set(1, n, i, 0, t, 1, r, 0, e, s, 1, 0, 0, 0, 0, 1), this
            );
          }
          compose(t, e, n) {
            const s = this.elements,
              i = e._x,
              r = e._y,
              o = e._z,
              a = e._w,
              c = i + i,
              u = r + r,
              d = o + o,
              l = i * c,
              h = i * u,
              f = i * d,
              m = r * u,
              p = r * d,
              g = o * d,
              x = a * c,
              v = a * u,
              y = a * d,
              w = n.x,
              _ = n.y,
              b = n.z;
            return (
              (s[0] = (1 - (m + g)) * w),
              (s[1] = (h + y) * w),
              (s[2] = (f - v) * w),
              (s[3] = 0),
              (s[4] = (h - y) * _),
              (s[5] = (1 - (l + g)) * _),
              (s[6] = (p + x) * _),
              (s[7] = 0),
              (s[8] = (f + v) * b),
              (s[9] = (p - x) * b),
              (s[10] = (1 - (l + m)) * b),
              (s[11] = 0),
              (s[12] = t.x),
              (s[13] = t.y),
              (s[14] = t.z),
              (s[15] = 1),
              this
            );
          }
          decompose(t, e, n) {
            const s = this.elements;
            let i = jt.set(s[0], s[1], s[2]).length();
            const r = jt.set(s[4], s[5], s[6]).length(),
              o = jt.set(s[8], s[9], s[10]).length();
            this.determinant() < 0 && (i = -i),
              (t.x = s[12]),
              (t.y = s[13]),
              (t.z = s[14]),
              Xt.copy(this);
            const a = 1 / i,
              c = 1 / r,
              u = 1 / o;
            return (
              (Xt.elements[0] *= a),
              (Xt.elements[1] *= a),
              (Xt.elements[2] *= a),
              (Xt.elements[4] *= c),
              (Xt.elements[5] *= c),
              (Xt.elements[6] *= c),
              (Xt.elements[8] *= u),
              (Xt.elements[9] *= u),
              (Xt.elements[10] *= u),
              e.setFromRotationMatrix(Xt),
              (n.x = i),
              (n.y = r),
              (n.z = o),
              this
            );
          }
          makePerspective(t, e, n, s, i, r) {
            void 0 === r &&
              console.warn(
                "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
              );
            const o = this.elements,
              a = (2 * i) / (e - t),
              c = (2 * i) / (n - s),
              u = (e + t) / (e - t),
              d = (n + s) / (n - s),
              l = -(r + i) / (r - i),
              h = (-2 * r * i) / (r - i);
            return (
              (o[0] = a),
              (o[4] = 0),
              (o[8] = u),
              (o[12] = 0),
              (o[1] = 0),
              (o[5] = c),
              (o[9] = d),
              (o[13] = 0),
              (o[2] = 0),
              (o[6] = 0),
              (o[10] = l),
              (o[14] = h),
              (o[3] = 0),
              (o[7] = 0),
              (o[11] = -1),
              (o[15] = 0),
              this
            );
          }
          makeOrthographic(t, e, n, s, i, r) {
            const o = this.elements,
              a = 1 / (e - t),
              c = 1 / (n - s),
              u = 1 / (r - i),
              d = (e + t) * a,
              l = (n + s) * c,
              h = (r + i) * u;
            return (
              (o[0] = 2 * a),
              (o[4] = 0),
              (o[8] = 0),
              (o[12] = -d),
              (o[1] = 0),
              (o[5] = 2 * c),
              (o[9] = 0),
              (o[13] = -l),
              (o[2] = 0),
              (o[6] = 0),
              (o[10] = -2 * u),
              (o[14] = -h),
              (o[3] = 0),
              (o[7] = 0),
              (o[11] = 0),
              (o[15] = 1),
              this
            );
          }
          equals(t) {
            const e = this.elements,
              n = t.elements;
            for (let t = 0; t < 16; t++) if (e[t] !== n[t]) return !1;
            return !0;
          }
          fromArray(t, e = 0) {
            for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
            return this;
          }
          toArray(t = [], e = 0) {
            const n = this.elements;
            return (
              (t[e] = n[0]),
              (t[e + 1] = n[1]),
              (t[e + 2] = n[2]),
              (t[e + 3] = n[3]),
              (t[e + 4] = n[4]),
              (t[e + 5] = n[5]),
              (t[e + 6] = n[6]),
              (t[e + 7] = n[7]),
              (t[e + 8] = n[8]),
              (t[e + 9] = n[9]),
              (t[e + 10] = n[10]),
              (t[e + 11] = n[11]),
              (t[e + 12] = n[12]),
              (t[e + 13] = n[13]),
              (t[e + 14] = n[14]),
              (t[e + 15] = n[15]),
              t
            );
          }
        }
        Wt.prototype.isMatrix4 = !0;
        const jt = new ft(),
          Xt = new Wt(),
          qt = new ft(0, 0, 0),
          Yt = new ft(1, 1, 1),
          Jt = new ft(),
          Zt = new ft(),
          $t = new ft(),
          Kt = new Wt(),
          Qt = new ht();
        class te {
          constructor(t = 0, e = 0, n = 0, s = te.DefaultOrder) {
            (this._x = t), (this._y = e), (this._z = n), (this._order = s);
          }
          get x() {
            return this._x;
          }
          set x(t) {
            (this._x = t), this._onChangeCallback();
          }
          get y() {
            return this._y;
          }
          set y(t) {
            (this._y = t), this._onChangeCallback();
          }
          get z() {
            return this._z;
          }
          set z(t) {
            (this._z = t), this._onChangeCallback();
          }
          get order() {
            return this._order;
          }
          set order(t) {
            (this._order = t), this._onChangeCallback();
          }
          set(t, e, n, s = this._order) {
            return (
              (this._x = t),
              (this._y = e),
              (this._z = n),
              (this._order = s),
              this._onChangeCallback(),
              this
            );
          }
          clone() {
            return new this.constructor(this._x, this._y, this._z, this._order);
          }
          copy(t) {
            return (
              (this._x = t._x),
              (this._y = t._y),
              (this._z = t._z),
              (this._order = t._order),
              this._onChangeCallback(),
              this
            );
          }
          setFromRotationMatrix(t, e = this._order, n = !0) {
            const s = t.elements,
              i = s[0],
              r = s[4],
              o = s[8],
              a = s[1],
              c = s[5],
              u = s[9],
              d = s[2],
              l = s[6],
              h = s[10];
            switch (e) {
              case "XYZ":
                (this._y = Math.asin(X(o, -1, 1))),
                  Math.abs(o) < 0.9999999
                    ? ((this._x = Math.atan2(-u, h)),
                      (this._z = Math.atan2(-r, i)))
                    : ((this._x = Math.atan2(l, c)), (this._z = 0));
                break;
              case "YXZ":
                (this._x = Math.asin(-X(u, -1, 1))),
                  Math.abs(u) < 0.9999999
                    ? ((this._y = Math.atan2(o, h)),
                      (this._z = Math.atan2(a, c)))
                    : ((this._y = Math.atan2(-d, i)), (this._z = 0));
                break;
              case "ZXY":
                (this._x = Math.asin(X(l, -1, 1))),
                  Math.abs(l) < 0.9999999
                    ? ((this._y = Math.atan2(-d, h)),
                      (this._z = Math.atan2(-r, c)))
                    : ((this._y = 0), (this._z = Math.atan2(a, i)));
                break;
              case "ZYX":
                (this._y = Math.asin(-X(d, -1, 1))),
                  Math.abs(d) < 0.9999999
                    ? ((this._x = Math.atan2(l, h)),
                      (this._z = Math.atan2(a, i)))
                    : ((this._x = 0), (this._z = Math.atan2(-r, c)));
                break;
              case "YZX":
                (this._z = Math.asin(X(a, -1, 1))),
                  Math.abs(a) < 0.9999999
                    ? ((this._x = Math.atan2(-u, c)),
                      (this._y = Math.atan2(-d, i)))
                    : ((this._x = 0), (this._y = Math.atan2(o, h)));
                break;
              case "XZY":
                (this._z = Math.asin(-X(r, -1, 1))),
                  Math.abs(r) < 0.9999999
                    ? ((this._x = Math.atan2(l, c)),
                      (this._y = Math.atan2(o, i)))
                    : ((this._x = Math.atan2(-u, h)), (this._y = 0));
                break;
              default:
                console.warn(
                  "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                    e
                );
            }
            return (
              (this._order = e), !0 === n && this._onChangeCallback(), this
            );
          }
          setFromQuaternion(t, e, n) {
            return (
              Kt.makeRotationFromQuaternion(t),
              this.setFromRotationMatrix(Kt, e, n)
            );
          }
          setFromVector3(t, e = this._order) {
            return this.set(t.x, t.y, t.z, e);
          }
          reorder(t) {
            return Qt.setFromEuler(this), this.setFromQuaternion(Qt, t);
          }
          equals(t) {
            return (
              t._x === this._x &&
              t._y === this._y &&
              t._z === this._z &&
              t._order === this._order
            );
          }
          fromArray(t) {
            return (
              (this._x = t[0]),
              (this._y = t[1]),
              (this._z = t[2]),
              void 0 !== t[3] && (this._order = t[3]),
              this._onChangeCallback(),
              this
            );
          }
          toArray(t = [], e = 0) {
            return (
              (t[e] = this._x),
              (t[e + 1] = this._y),
              (t[e + 2] = this._z),
              (t[e + 3] = this._order),
              t
            );
          }
          toVector3(t) {
            return t
              ? t.set(this._x, this._y, this._z)
              : new ft(this._x, this._y, this._z);
          }
          _onChange(t) {
            return (this._onChangeCallback = t), this;
          }
          _onChangeCallback() {}
        }
        (te.prototype.isEuler = !0),
          (te.DefaultOrder = "XYZ"),
          (te.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]);
        class ee {
          constructor() {
            this.mask = 1;
          }
          set(t) {
            this.mask = (1 << t) | 0;
          }
          enable(t) {
            this.mask |= (1 << t) | 0;
          }
          enableAll() {
            this.mask = -1;
          }
          toggle(t) {
            this.mask ^= (1 << t) | 0;
          }
          disable(t) {
            this.mask &= ~((1 << t) | 0);
          }
          disableAll() {
            this.mask = 0;
          }
          test(t) {
            return 0 != (this.mask & t.mask);
          }
        }
        let ne = 0;
        const se = new ft(),
          ie = new ht(),
          re = new Wt(),
          oe = new ft(),
          ae = new ft(),
          ce = new ft(),
          ue = new ht(),
          de = new ft(1, 0, 0),
          le = new ft(0, 1, 0),
          he = new ft(0, 0, 1),
          fe = { type: "added" },
          me = { type: "removed" };
        class pe extends F {
          constructor() {
            super(),
              Object.defineProperty(this, "id", { value: ne++ }),
              (this.uuid = j()),
              (this.name = ""),
              (this.type = "Object3D"),
              (this.parent = null),
              (this.children = []),
              (this.up = pe.DefaultUp.clone());
            const t = new ft(),
              e = new te(),
              n = new ht(),
              s = new ft(1, 1, 1);
            e._onChange(function () {
              n.setFromEuler(e, !1);
            }),
              n._onChange(function () {
                e.setFromQuaternion(n, void 0, !1);
              }),
              Object.defineProperties(this, {
                position: { configurable: !0, enumerable: !0, value: t },
                rotation: { configurable: !0, enumerable: !0, value: e },
                quaternion: { configurable: !0, enumerable: !0, value: n },
                scale: { configurable: !0, enumerable: !0, value: s },
                modelViewMatrix: { value: new Wt() },
                normalMatrix: { value: new tt() },
              }),
              (this.matrix = new Wt()),
              (this.matrixWorld = new Wt()),
              (this.matrixAutoUpdate = pe.DefaultMatrixAutoUpdate),
              (this.matrixWorldNeedsUpdate = !1),
              (this.layers = new ee()),
              (this.visible = !0),
              (this.castShadow = !1),
              (this.receiveShadow = !1),
              (this.frustumCulled = !0),
              (this.renderOrder = 0),
              (this.animations = []),
              (this.userData = {});
          }
          onBeforeRender() {}
          onAfterRender() {}
          applyMatrix4(t) {
            this.matrixAutoUpdate && this.updateMatrix(),
              this.matrix.premultiply(t),
              this.matrix.decompose(this.position, this.quaternion, this.scale);
          }
          applyQuaternion(t) {
            return this.quaternion.premultiply(t), this;
          }
          setRotationFromAxisAngle(t, e) {
            this.quaternion.setFromAxisAngle(t, e);
          }
          setRotationFromEuler(t) {
            this.quaternion.setFromEuler(t, !0);
          }
          setRotationFromMatrix(t) {
            this.quaternion.setFromRotationMatrix(t);
          }
          setRotationFromQuaternion(t) {
            this.quaternion.copy(t);
          }
          rotateOnAxis(t, e) {
            return (
              ie.setFromAxisAngle(t, e), this.quaternion.multiply(ie), this
            );
          }
          rotateOnWorldAxis(t, e) {
            return (
              ie.setFromAxisAngle(t, e), this.quaternion.premultiply(ie), this
            );
          }
          rotateX(t) {
            return this.rotateOnAxis(de, t);
          }
          rotateY(t) {
            return this.rotateOnAxis(le, t);
          }
          rotateZ(t) {
            return this.rotateOnAxis(he, t);
          }
          translateOnAxis(t, e) {
            return (
              se.copy(t).applyQuaternion(this.quaternion),
              this.position.add(se.multiplyScalar(e)),
              this
            );
          }
          translateX(t) {
            return this.translateOnAxis(de, t);
          }
          translateY(t) {
            return this.translateOnAxis(le, t);
          }
          translateZ(t) {
            return this.translateOnAxis(he, t);
          }
          localToWorld(t) {
            return t.applyMatrix4(this.matrixWorld);
          }
          worldToLocal(t) {
            return t.applyMatrix4(re.copy(this.matrixWorld).invert());
          }
          lookAt(t, e, n) {
            t.isVector3 ? oe.copy(t) : oe.set(t, e, n);
            const s = this.parent;
            this.updateWorldMatrix(!0, !1),
              ae.setFromMatrixPosition(this.matrixWorld),
              this.isCamera || this.isLight
                ? re.lookAt(ae, oe, this.up)
                : re.lookAt(oe, ae, this.up),
              this.quaternion.setFromRotationMatrix(re),
              s &&
                (re.extractRotation(s.matrixWorld),
                ie.setFromRotationMatrix(re),
                this.quaternion.premultiply(ie.invert()));
          }
          add(t) {
            if (arguments.length > 1) {
              for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
              return this;
            }
            return t === this
              ? (console.error(
                  "THREE.Object3D.add: object can't be added as a child of itself.",
                  t
                ),
                this)
              : (t && t.isObject3D
                  ? (null !== t.parent && t.parent.remove(t),
                    (t.parent = this),
                    this.children.push(t),
                    t.dispatchEvent(fe))
                  : console.error(
                      "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                      t
                    ),
                this);
          }
          remove(t) {
            if (arguments.length > 1) {
              for (let t = 0; t < arguments.length; t++)
                this.remove(arguments[t]);
              return this;
            }
            const e = this.children.indexOf(t);
            return (
              -1 !== e &&
                ((t.parent = null),
                this.children.splice(e, 1),
                t.dispatchEvent(me)),
              this
            );
          }
          removeFromParent() {
            const t = this.parent;
            return null !== t && t.remove(this), this;
          }
          clear() {
            for (let t = 0; t < this.children.length; t++) {
              const e = this.children[t];
              (e.parent = null), e.dispatchEvent(me);
            }
            return (this.children.length = 0), this;
          }
          attach(t) {
            return (
              this.updateWorldMatrix(!0, !1),
              re.copy(this.matrixWorld).invert(),
              null !== t.parent &&
                (t.parent.updateWorldMatrix(!0, !1),
                re.multiply(t.parent.matrixWorld)),
              t.applyMatrix4(re),
              this.add(t),
              t.updateWorldMatrix(!1, !0),
              this
            );
          }
          getObjectById(t) {
            return this.getObjectByProperty("id", t);
          }
          getObjectByName(t) {
            return this.getObjectByProperty("name", t);
          }
          getObjectByProperty(t, e) {
            if (this[t] === e) return this;
            for (let n = 0, s = this.children.length; n < s; n++) {
              const s = this.children[n].getObjectByProperty(t, e);
              if (void 0 !== s) return s;
            }
          }
          getWorldPosition(t) {
            return (
              this.updateWorldMatrix(!0, !1),
              t.setFromMatrixPosition(this.matrixWorld)
            );
          }
          getWorldQuaternion(t) {
            return (
              this.updateWorldMatrix(!0, !1),
              this.matrixWorld.decompose(ae, t, ce),
              t
            );
          }
          getWorldScale(t) {
            return (
              this.updateWorldMatrix(!0, !1),
              this.matrixWorld.decompose(ae, ue, t),
              t
            );
          }
          getWorldDirection(t) {
            this.updateWorldMatrix(!0, !1);
            const e = this.matrixWorld.elements;
            return t.set(e[8], e[9], e[10]).normalize();
          }
          raycast() {}
          traverse(t) {
            t(this);
            const e = this.children;
            for (let n = 0, s = e.length; n < s; n++) e[n].traverse(t);
          }
          traverseVisible(t) {
            if (!1 === this.visible) return;
            t(this);
            const e = this.children;
            for (let n = 0, s = e.length; n < s; n++) e[n].traverseVisible(t);
          }
          traverseAncestors(t) {
            const e = this.parent;
            null !== e && (t(e), e.traverseAncestors(t));
          }
          updateMatrix() {
            this.matrix.compose(this.position, this.quaternion, this.scale),
              (this.matrixWorldNeedsUpdate = !0);
          }
          updateMatrixWorld(t) {
            this.matrixAutoUpdate && this.updateMatrix(),
              (this.matrixWorldNeedsUpdate || t) &&
                (null === this.parent
                  ? this.matrixWorld.copy(this.matrix)
                  : this.matrixWorld.multiplyMatrices(
                      this.parent.matrixWorld,
                      this.matrix
                    ),
                (this.matrixWorldNeedsUpdate = !1),
                (t = !0));
            const e = this.children;
            for (let n = 0, s = e.length; n < s; n++) e[n].updateMatrixWorld(t);
          }
          updateWorldMatrix(t, e) {
            const n = this.parent;
            if (
              (!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
              this.matrixAutoUpdate && this.updateMatrix(),
              null === this.parent
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix
                  ),
              !0 === e)
            ) {
              const t = this.children;
              for (let e = 0, n = t.length; e < n; e++)
                t[e].updateWorldMatrix(!1, !0);
            }
          }
          toJSON(t) {
            const e = void 0 === t || "string" == typeof t,
              n = {};
            e &&
              ((t = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {},
              }),
              (n.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON",
              }));
            const s = {};
            function i(e, n) {
              return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
            }
            if (
              ((s.uuid = this.uuid),
              (s.type = this.type),
              "" !== this.name && (s.name = this.name),
              !0 === this.castShadow && (s.castShadow = !0),
              !0 === this.receiveShadow && (s.receiveShadow = !0),
              !1 === this.visible && (s.visible = !1),
              !1 === this.frustumCulled && (s.frustumCulled = !1),
              0 !== this.renderOrder && (s.renderOrder = this.renderOrder),
              "{}" !== JSON.stringify(this.userData) &&
                (s.userData = this.userData),
              (s.layers = this.layers.mask),
              (s.matrix = this.matrix.toArray()),
              !1 === this.matrixAutoUpdate && (s.matrixAutoUpdate = !1),
              this.isInstancedMesh &&
                ((s.type = "InstancedMesh"),
                (s.count = this.count),
                (s.instanceMatrix = this.instanceMatrix.toJSON()),
                null !== this.instanceColor &&
                  (s.instanceColor = this.instanceColor.toJSON())),
              this.isScene)
            )
              this.background &&
                (this.background.isColor
                  ? (s.background = this.background.toJSON())
                  : this.background.isTexture &&
                    (s.background = this.background.toJSON(t).uuid)),
                this.environment &&
                  this.environment.isTexture &&
                  (s.environment = this.environment.toJSON(t).uuid);
            else if (this.isMesh || this.isLine || this.isPoints) {
              s.geometry = i(t.geometries, this.geometry);
              const e = this.geometry.parameters;
              if (void 0 !== e && void 0 !== e.shapes) {
                const n = e.shapes;
                if (Array.isArray(n))
                  for (let e = 0, s = n.length; e < s; e++) {
                    const s = n[e];
                    i(t.shapes, s);
                  }
                else i(t.shapes, n);
              }
            }
            if (
              (this.isSkinnedMesh &&
                ((s.bindMode = this.bindMode),
                (s.bindMatrix = this.bindMatrix.toArray()),
                void 0 !== this.skeleton &&
                  (i(t.skeletons, this.skeleton),
                  (s.skeleton = this.skeleton.uuid))),
              void 0 !== this.material)
            )
              if (Array.isArray(this.material)) {
                const e = [];
                for (let n = 0, s = this.material.length; n < s; n++)
                  e.push(i(t.materials, this.material[n]));
                s.material = e;
              } else s.material = i(t.materials, this.material);
            if (this.children.length > 0) {
              s.children = [];
              for (let e = 0; e < this.children.length; e++)
                s.children.push(this.children[e].toJSON(t).object);
            }
            if (this.animations.length > 0) {
              s.animations = [];
              for (let e = 0; e < this.animations.length; e++) {
                const n = this.animations[e];
                s.animations.push(i(t.animations, n));
              }
            }
            if (e) {
              const e = r(t.geometries),
                s = r(t.materials),
                i = r(t.textures),
                o = r(t.images),
                a = r(t.shapes),
                c = r(t.skeletons),
                u = r(t.animations);
              e.length > 0 && (n.geometries = e),
                s.length > 0 && (n.materials = s),
                i.length > 0 && (n.textures = i),
                o.length > 0 && (n.images = o),
                a.length > 0 && (n.shapes = a),
                c.length > 0 && (n.skeletons = c),
                u.length > 0 && (n.animations = u);
            }
            return (n.object = s), n;
            function r(t) {
              const e = [];
              for (const n in t) {
                const s = t[n];
                delete s.metadata, e.push(s);
              }
              return e;
            }
          }
          clone(t) {
            return new this.constructor().copy(this, t);
          }
          copy(t, e = !0) {
            if (
              ((this.name = t.name),
              this.up.copy(t.up),
              this.position.copy(t.position),
              (this.rotation.order = t.rotation.order),
              this.quaternion.copy(t.quaternion),
              this.scale.copy(t.scale),
              this.matrix.copy(t.matrix),
              this.matrixWorld.copy(t.matrixWorld),
              (this.matrixAutoUpdate = t.matrixAutoUpdate),
              (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
              (this.layers.mask = t.layers.mask),
              (this.visible = t.visible),
              (this.castShadow = t.castShadow),
              (this.receiveShadow = t.receiveShadow),
              (this.frustumCulled = t.frustumCulled),
              (this.renderOrder = t.renderOrder),
              (this.userData = JSON.parse(JSON.stringify(t.userData))),
              !0 === e)
            )
              for (let e = 0; e < t.children.length; e++) {
                const n = t.children[e];
                this.add(n.clone());
              }
            return this;
          }
        }
        (pe.DefaultUp = new ft(0, 1, 0)),
          (pe.DefaultMatrixAutoUpdate = !0),
          (pe.prototype.isObject3D = !0);
        const ge = new ft(),
          xe = new ft(),
          ve = new ft(),
          ye = new ft(),
          we = new ft(),
          _e = new ft(),
          be = new ft(),
          Me = new ft(),
          Se = new ft(),
          Te = new ft();
        class Ee {
          constructor(t = new ft(), e = new ft(), n = new ft()) {
            (this.a = t), (this.b = e), (this.c = n);
          }
          static getNormal(t, e, n, s) {
            s.subVectors(n, e), ge.subVectors(t, e), s.cross(ge);
            const i = s.lengthSq();
            return i > 0 ? s.multiplyScalar(1 / Math.sqrt(i)) : s.set(0, 0, 0);
          }
          static getBarycoord(t, e, n, s, i) {
            ge.subVectors(s, e), xe.subVectors(n, e), ve.subVectors(t, e);
            const r = ge.dot(ge),
              o = ge.dot(xe),
              a = ge.dot(ve),
              c = xe.dot(xe),
              u = xe.dot(ve),
              d = r * c - o * o;
            if (0 === d) return i.set(-2, -1, -1);
            const l = 1 / d,
              h = (c * a - o * u) * l,
              f = (r * u - o * a) * l;
            return i.set(1 - h - f, f, h);
          }
          static containsPoint(t, e, n, s) {
            return (
              this.getBarycoord(t, e, n, s, ye),
              ye.x >= 0 && ye.y >= 0 && ye.x + ye.y <= 1
            );
          }
          static getUV(t, e, n, s, i, r, o, a) {
            return (
              this.getBarycoord(t, e, n, s, ye),
              a.set(0, 0),
              a.addScaledVector(i, ye.x),
              a.addScaledVector(r, ye.y),
              a.addScaledVector(o, ye.z),
              a
            );
          }
          static isFrontFacing(t, e, n, s) {
            return (
              ge.subVectors(n, e), xe.subVectors(t, e), ge.cross(xe).dot(s) < 0
            );
          }
          set(t, e, n) {
            return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
          }
          setFromPointsAndIndices(t, e, n, s) {
            return (
              this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[s]), this
            );
          }
          setFromAttributeAndIndices(t, e, n, s) {
            return (
              this.a.fromBufferAttribute(t, e),
              this.b.fromBufferAttribute(t, n),
              this.c.fromBufferAttribute(t, s),
              this
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
          }
          getArea() {
            return (
              ge.subVectors(this.c, this.b),
              xe.subVectors(this.a, this.b),
              0.5 * ge.cross(xe).length()
            );
          }
          getMidpoint(t) {
            return t
              .addVectors(this.a, this.b)
              .add(this.c)
              .multiplyScalar(1 / 3);
          }
          getNormal(t) {
            return Ee.getNormal(this.a, this.b, this.c, t);
          }
          getPlane(t) {
            return t.setFromCoplanarPoints(this.a, this.b, this.c);
          }
          getBarycoord(t, e) {
            return Ee.getBarycoord(t, this.a, this.b, this.c, e);
          }
          getUV(t, e, n, s, i) {
            return Ee.getUV(t, this.a, this.b, this.c, e, n, s, i);
          }
          containsPoint(t) {
            return Ee.containsPoint(t, this.a, this.b, this.c);
          }
          isFrontFacing(t) {
            return Ee.isFrontFacing(this.a, this.b, this.c, t);
          }
          intersectsBox(t) {
            return t.intersectsTriangle(this);
          }
          closestPointToPoint(t, e) {
            const n = this.a,
              s = this.b,
              i = this.c;
            let r, o;
            we.subVectors(s, n), _e.subVectors(i, n), Me.subVectors(t, n);
            const a = we.dot(Me),
              c = _e.dot(Me);
            if (a <= 0 && c <= 0) return e.copy(n);
            Se.subVectors(t, s);
            const u = we.dot(Se),
              d = _e.dot(Se);
            if (u >= 0 && d <= u) return e.copy(s);
            const l = a * d - u * c;
            if (l <= 0 && a >= 0 && u <= 0)
              return (r = a / (a - u)), e.copy(n).addScaledVector(we, r);
            Te.subVectors(t, i);
            const h = we.dot(Te),
              f = _e.dot(Te);
            if (f >= 0 && h <= f) return e.copy(i);
            const m = h * c - a * f;
            if (m <= 0 && c >= 0 && f <= 0)
              return (o = c / (c - f)), e.copy(n).addScaledVector(_e, o);
            const p = u * f - h * d;
            if (p <= 0 && d - u >= 0 && h - f >= 0)
              return (
                be.subVectors(i, s),
                (o = (d - u) / (d - u + (h - f))),
                e.copy(s).addScaledVector(be, o)
              );
            const g = 1 / (p + m + l);
            return (
              (r = m * g),
              (o = l * g),
              e.copy(n).addScaledVector(we, r).addScaledVector(_e, o)
            );
          }
          equals(t) {
            return (
              t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            );
          }
        }
        let Ce = 0;
        class Ae extends F {
          constructor() {
            super(),
              Object.defineProperty(this, "id", { value: Ce++ }),
              (this.uuid = j()),
              (this.name = ""),
              (this.type = "Material"),
              (this.fog = !0),
              (this.blending = 1),
              (this.side = 0),
              (this.vertexColors = !1),
              (this.opacity = 1),
              (this.format = b),
              (this.transparent = !1),
              (this.blendSrc = 204),
              (this.blendDst = 205),
              (this.blendEquation = s),
              (this.blendSrcAlpha = null),
              (this.blendDstAlpha = null),
              (this.blendEquationAlpha = null),
              (this.depthFunc = 3),
              (this.depthTest = !0),
              (this.depthWrite = !0),
              (this.stencilWriteMask = 255),
              (this.stencilFunc = 519),
              (this.stencilRef = 0),
              (this.stencilFuncMask = 255),
              (this.stencilFail = O),
              (this.stencilZFail = O),
              (this.stencilZPass = O),
              (this.stencilWrite = !1),
              (this.clippingPlanes = null),
              (this.clipIntersection = !1),
              (this.clipShadows = !1),
              (this.shadowSide = null),
              (this.colorWrite = !0),
              (this.precision = null),
              (this.polygonOffset = !1),
              (this.polygonOffsetFactor = 0),
              (this.polygonOffsetUnits = 0),
              (this.dithering = !1),
              (this.alphaToCoverage = !1),
              (this.premultipliedAlpha = !1),
              (this.visible = !0),
              (this.toneMapped = !0),
              (this.userData = {}),
              (this.version = 0),
              (this._alphaTest = 0);
          }
          get alphaTest() {
            return this._alphaTest;
          }
          set alphaTest(t) {
            this._alphaTest > 0 != t > 0 && this.version++,
              (this._alphaTest = t);
          }
          onBuild() {}
          onBeforeRender() {}
          onBeforeCompile() {}
          customProgramCacheKey() {
            return this.onBeforeCompile.toString();
          }
          setValues(t) {
            if (void 0 !== t)
              for (const e in t) {
                const n = t[e];
                if (void 0 === n) {
                  console.warn(
                    "THREE.Material: '" + e + "' parameter is undefined."
                  );
                  continue;
                }
                if ("shading" === e) {
                  console.warn(
                    "THREE." +
                      this.type +
                      ": .shading has been removed. Use the boolean .flatShading instead."
                  ),
                    (this.flatShading = 1 === n);
                  continue;
                }
                const s = this[e];
                void 0 !== s
                  ? s && s.isColor
                    ? s.set(n)
                    : s && s.isVector3 && n && n.isVector3
                    ? s.copy(n)
                    : (this[e] = n)
                  : console.warn(
                      "THREE." +
                        this.type +
                        ": '" +
                        e +
                        "' is not a property of this material."
                    );
              }
          }
          toJSON(t) {
            const e = void 0 === t || "string" == typeof t;
            e && (t = { textures: {}, images: {} });
            const n = {
              metadata: {
                version: 4.5,
                type: "Material",
                generator: "Material.toJSON",
              },
            };
            function s(t) {
              const e = [];
              for (const n in t) {
                const s = t[n];
                delete s.metadata, e.push(s);
              }
              return e;
            }
            if (
              ((n.uuid = this.uuid),
              (n.type = this.type),
              "" !== this.name && (n.name = this.name),
              this.color &&
                this.color.isColor &&
                (n.color = this.color.getHex()),
              void 0 !== this.roughness && (n.roughness = this.roughness),
              void 0 !== this.metalness && (n.metalness = this.metalness),
              void 0 !== this.sheen && (n.sheen = this.sheen),
              this.sheenColor &&
                this.sheenColor.isColor &&
                (n.sheenColor = this.sheenColor.getHex()),
              void 0 !== this.sheenRoughness &&
                (n.sheenRoughness = this.sheenRoughness),
              this.emissive &&
                this.emissive.isColor &&
                (n.emissive = this.emissive.getHex()),
              this.emissiveIntensity &&
                1 !== this.emissiveIntensity &&
                (n.emissiveIntensity = this.emissiveIntensity),
              this.specular &&
                this.specular.isColor &&
                (n.specular = this.specular.getHex()),
              void 0 !== this.specularIntensity &&
                (n.specularIntensity = this.specularIntensity),
              this.specularColor &&
                this.specularColor.isColor &&
                (n.specularColor = this.specularColor.getHex()),
              void 0 !== this.shininess && (n.shininess = this.shininess),
              void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
              void 0 !== this.clearcoatRoughness &&
                (n.clearcoatRoughness = this.clearcoatRoughness),
              this.clearcoatMap &&
                this.clearcoatMap.isTexture &&
                (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
              this.clearcoatRoughnessMap &&
                this.clearcoatRoughnessMap.isTexture &&
                (n.clearcoatRoughnessMap =
                  this.clearcoatRoughnessMap.toJSON(t).uuid),
              this.clearcoatNormalMap &&
                this.clearcoatNormalMap.isTexture &&
                ((n.clearcoatNormalMap =
                  this.clearcoatNormalMap.toJSON(t).uuid),
                (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
              this.map &&
                this.map.isTexture &&
                (n.map = this.map.toJSON(t).uuid),
              this.matcap &&
                this.matcap.isTexture &&
                (n.matcap = this.matcap.toJSON(t).uuid),
              this.alphaMap &&
                this.alphaMap.isTexture &&
                (n.alphaMap = this.alphaMap.toJSON(t).uuid),
              this.lightMap &&
                this.lightMap.isTexture &&
                ((n.lightMap = this.lightMap.toJSON(t).uuid),
                (n.lightMapIntensity = this.lightMapIntensity)),
              this.aoMap &&
                this.aoMap.isTexture &&
                ((n.aoMap = this.aoMap.toJSON(t).uuid),
                (n.aoMapIntensity = this.aoMapIntensity)),
              this.bumpMap &&
                this.bumpMap.isTexture &&
                ((n.bumpMap = this.bumpMap.toJSON(t).uuid),
                (n.bumpScale = this.bumpScale)),
              this.normalMap &&
                this.normalMap.isTexture &&
                ((n.normalMap = this.normalMap.toJSON(t).uuid),
                (n.normalMapType = this.normalMapType),
                (n.normalScale = this.normalScale.toArray())),
              this.displacementMap &&
                this.displacementMap.isTexture &&
                ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
                (n.displacementScale = this.displacementScale),
                (n.displacementBias = this.displacementBias)),
              this.roughnessMap &&
                this.roughnessMap.isTexture &&
                (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
              this.metalnessMap &&
                this.metalnessMap.isTexture &&
                (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
              this.emissiveMap &&
                this.emissiveMap.isTexture &&
                (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
              this.specularMap &&
                this.specularMap.isTexture &&
                (n.specularMap = this.specularMap.toJSON(t).uuid),
              this.specularIntensityMap &&
                this.specularIntensityMap.isTexture &&
                (n.specularIntensityMap =
                  this.specularIntensityMap.toJSON(t).uuid),
              this.specularColorMap &&
                this.specularColorMap.isTexture &&
                (n.specularColorMap = this.specularColorMap.toJSON(t).uuid),
              this.envMap &&
                this.envMap.isTexture &&
                ((n.envMap = this.envMap.toJSON(t).uuid),
                void 0 !== this.combine && (n.combine = this.combine)),
              void 0 !== this.envMapIntensity &&
                (n.envMapIntensity = this.envMapIntensity),
              void 0 !== this.reflectivity &&
                (n.reflectivity = this.reflectivity),
              void 0 !== this.refractionRatio &&
                (n.refractionRatio = this.refractionRatio),
              this.gradientMap &&
                this.gradientMap.isTexture &&
                (n.gradientMap = this.gradientMap.toJSON(t).uuid),
              void 0 !== this.transmission &&
                (n.transmission = this.transmission),
              this.transmissionMap &&
                this.transmissionMap.isTexture &&
                (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),
              void 0 !== this.thickness && (n.thickness = this.thickness),
              this.thicknessMap &&
                this.thicknessMap.isTexture &&
                (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
              void 0 !== this.attenuationDistance &&
                (n.attenuationDistance = this.attenuationDistance),
              void 0 !== this.attenuationColor &&
                (n.attenuationColor = this.attenuationColor.getHex()),
              void 0 !== this.size && (n.size = this.size),
              null !== this.shadowSide && (n.shadowSide = this.shadowSide),
              void 0 !== this.sizeAttenuation &&
                (n.sizeAttenuation = this.sizeAttenuation),
              1 !== this.blending && (n.blending = this.blending),
              0 !== this.side && (n.side = this.side),
              this.vertexColors && (n.vertexColors = !0),
              this.opacity < 1 && (n.opacity = this.opacity),
              this.format !== b && (n.format = this.format),
              !0 === this.transparent && (n.transparent = this.transparent),
              (n.depthFunc = this.depthFunc),
              (n.depthTest = this.depthTest),
              (n.depthWrite = this.depthWrite),
              (n.colorWrite = this.colorWrite),
              (n.stencilWrite = this.stencilWrite),
              (n.stencilWriteMask = this.stencilWriteMask),
              (n.stencilFunc = this.stencilFunc),
              (n.stencilRef = this.stencilRef),
              (n.stencilFuncMask = this.stencilFuncMask),
              (n.stencilFail = this.stencilFail),
              (n.stencilZFail = this.stencilZFail),
              (n.stencilZPass = this.stencilZPass),
              this.rotation &&
                0 !== this.rotation &&
                (n.rotation = this.rotation),
              !0 === this.polygonOffset && (n.polygonOffset = !0),
              0 !== this.polygonOffsetFactor &&
                (n.polygonOffsetFactor = this.polygonOffsetFactor),
              0 !== this.polygonOffsetUnits &&
                (n.polygonOffsetUnits = this.polygonOffsetUnits),
              this.linewidth &&
                1 !== this.linewidth &&
                (n.linewidth = this.linewidth),
              void 0 !== this.dashSize && (n.dashSize = this.dashSize),
              void 0 !== this.gapSize && (n.gapSize = this.gapSize),
              void 0 !== this.scale && (n.scale = this.scale),
              !0 === this.dithering && (n.dithering = !0),
              this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
              !0 === this.alphaToCoverage &&
                (n.alphaToCoverage = this.alphaToCoverage),
              !0 === this.premultipliedAlpha &&
                (n.premultipliedAlpha = this.premultipliedAlpha),
              !0 === this.wireframe && (n.wireframe = this.wireframe),
              this.wireframeLinewidth > 1 &&
                (n.wireframeLinewidth = this.wireframeLinewidth),
              "round" !== this.wireframeLinecap &&
                (n.wireframeLinecap = this.wireframeLinecap),
              "round" !== this.wireframeLinejoin &&
                (n.wireframeLinejoin = this.wireframeLinejoin),
              !0 === this.flatShading && (n.flatShading = this.flatShading),
              !1 === this.visible && (n.visible = !1),
              !1 === this.toneMapped && (n.toneMapped = !1),
              "{}" !== JSON.stringify(this.userData) &&
                (n.userData = this.userData),
              e)
            ) {
              const e = s(t.textures),
                i = s(t.images);
              e.length > 0 && (n.textures = e), i.length > 0 && (n.images = i);
            }
            return n;
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            (this.name = t.name),
              (this.fog = t.fog),
              (this.blending = t.blending),
              (this.side = t.side),
              (this.vertexColors = t.vertexColors),
              (this.opacity = t.opacity),
              (this.format = t.format),
              (this.transparent = t.transparent),
              (this.blendSrc = t.blendSrc),
              (this.blendDst = t.blendDst),
              (this.blendEquation = t.blendEquation),
              (this.blendSrcAlpha = t.blendSrcAlpha),
              (this.blendDstAlpha = t.blendDstAlpha),
              (this.blendEquationAlpha = t.blendEquationAlpha),
              (this.depthFunc = t.depthFunc),
              (this.depthTest = t.depthTest),
              (this.depthWrite = t.depthWrite),
              (this.stencilWriteMask = t.stencilWriteMask),
              (this.stencilFunc = t.stencilFunc),
              (this.stencilRef = t.stencilRef),
              (this.stencilFuncMask = t.stencilFuncMask),
              (this.stencilFail = t.stencilFail),
              (this.stencilZFail = t.stencilZFail),
              (this.stencilZPass = t.stencilZPass),
              (this.stencilWrite = t.stencilWrite);
            const e = t.clippingPlanes;
            let n = null;
            if (null !== e) {
              const t = e.length;
              n = new Array(t);
              for (let s = 0; s !== t; ++s) n[s] = e[s].clone();
            }
            return (
              (this.clippingPlanes = n),
              (this.clipIntersection = t.clipIntersection),
              (this.clipShadows = t.clipShadows),
              (this.shadowSide = t.shadowSide),
              (this.colorWrite = t.colorWrite),
              (this.precision = t.precision),
              (this.polygonOffset = t.polygonOffset),
              (this.polygonOffsetFactor = t.polygonOffsetFactor),
              (this.polygonOffsetUnits = t.polygonOffsetUnits),
              (this.dithering = t.dithering),
              (this.alphaTest = t.alphaTest),
              (this.alphaToCoverage = t.alphaToCoverage),
              (this.premultipliedAlpha = t.premultipliedAlpha),
              (this.visible = t.visible),
              (this.toneMapped = t.toneMapped),
              (this.userData = JSON.parse(JSON.stringify(t.userData))),
              this
            );
          }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
          set needsUpdate(t) {
            !0 === t && this.version++;
          }
        }
        Ae.prototype.isMaterial = !0;
        const Le = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074,
          },
          Re = { h: 0, s: 0, l: 0 },
          Pe = { h: 0, s: 0, l: 0 };
        function Ie(t, e, n) {
          return (
            n < 0 && (n += 1),
            n > 1 && (n -= 1),
            n < 1 / 6
              ? t + 6 * (e - t) * n
              : n < 0.5
              ? e
              : n < 2 / 3
              ? t + 6 * (e - t) * (2 / 3 - n)
              : t
          );
        }
        function De(t) {
          return t < 0.04045
            ? 0.0773993808 * t
            : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
        }
        function Ne(t) {
          return t < 0.0031308
            ? 12.92 * t
            : 1.055 * Math.pow(t, 0.41666) - 0.055;
        }
        class Oe {
          constructor(t, e, n) {
            return void 0 === e && void 0 === n
              ? this.set(t)
              : this.setRGB(t, e, n);
          }
          set(t) {
            return (
              t && t.isColor
                ? this.copy(t)
                : "number" == typeof t
                ? this.setHex(t)
                : "string" == typeof t && this.setStyle(t),
              this
            );
          }
          setScalar(t) {
            return (this.r = t), (this.g = t), (this.b = t), this;
          }
          setHex(t) {
            return (
              (t = Math.floor(t)),
              (this.r = ((t >> 16) & 255) / 255),
              (this.g = ((t >> 8) & 255) / 255),
              (this.b = (255 & t) / 255),
              this
            );
          }
          setRGB(t, e, n) {
            return (this.r = t), (this.g = e), (this.b = n), this;
          }
          setHSL(t, e, n) {
            if (((t = q(t, 1)), (e = X(e, 0, 1)), (n = X(n, 0, 1)), 0 === e))
              this.r = this.g = this.b = n;
            else {
              const s = n <= 0.5 ? n * (1 + e) : n + e - n * e,
                i = 2 * n - s;
              (this.r = Ie(i, s, t + 1 / 3)),
                (this.g = Ie(i, s, t)),
                (this.b = Ie(i, s, t - 1 / 3));
            }
            return this;
          }
          setStyle(t) {
            function e(e) {
              void 0 !== e &&
                parseFloat(e) < 1 &&
                console.warn(
                  "THREE.Color: Alpha component of " + t + " will be ignored."
                );
            }
            let n;
            if ((n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t))) {
              let t;
              const s = n[1],
                i = n[2];
              switch (s) {
                case "rgb":
                case "rgba":
                  if (
                    (t =
                      /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                        i
                      ))
                  )
                    return (
                      (this.r = Math.min(255, parseInt(t[1], 10)) / 255),
                      (this.g = Math.min(255, parseInt(t[2], 10)) / 255),
                      (this.b = Math.min(255, parseInt(t[3], 10)) / 255),
                      e(t[4]),
                      this
                    );
                  if (
                    (t =
                      /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                        i
                      ))
                  )
                    return (
                      (this.r = Math.min(100, parseInt(t[1], 10)) / 100),
                      (this.g = Math.min(100, parseInt(t[2], 10)) / 100),
                      (this.b = Math.min(100, parseInt(t[3], 10)) / 100),
                      e(t[4]),
                      this
                    );
                  break;
                case "hsl":
                case "hsla":
                  if (
                    (t =
                      /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                        i
                      ))
                  ) {
                    const n = parseFloat(t[1]) / 360,
                      s = parseInt(t[2], 10) / 100,
                      i = parseInt(t[3], 10) / 100;
                    return e(t[4]), this.setHSL(n, s, i);
                  }
              }
            } else if ((n = /^\#([A-Fa-f\d]+)$/.exec(t))) {
              const t = n[1],
                e = t.length;
              if (3 === e)
                return (
                  (this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255),
                  (this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255),
                  (this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255),
                  this
                );
              if (6 === e)
                return (
                  (this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255),
                  (this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255),
                  (this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255),
                  this
                );
            }
            return t && t.length > 0 ? this.setColorName(t) : this;
          }
          setColorName(t) {
            const e = Le[t.toLowerCase()];
            return (
              void 0 !== e
                ? this.setHex(e)
                : console.warn("THREE.Color: Unknown color " + t),
              this
            );
          }
          clone() {
            return new this.constructor(this.r, this.g, this.b);
          }
          copy(t) {
            return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
          }
          copyGammaToLinear(t, e = 2) {
            return (
              (this.r = Math.pow(t.r, e)),
              (this.g = Math.pow(t.g, e)),
              (this.b = Math.pow(t.b, e)),
              this
            );
          }
          copyLinearToGamma(t, e = 2) {
            const n = e > 0 ? 1 / e : 1;
            return (
              (this.r = Math.pow(t.r, n)),
              (this.g = Math.pow(t.g, n)),
              (this.b = Math.pow(t.b, n)),
              this
            );
          }
          convertGammaToLinear(t) {
            return this.copyGammaToLinear(this, t), this;
          }
          convertLinearToGamma(t) {
            return this.copyLinearToGamma(this, t), this;
          }
          copySRGBToLinear(t) {
            return (
              (this.r = De(t.r)), (this.g = De(t.g)), (this.b = De(t.b)), this
            );
          }
          copyLinearToSRGB(t) {
            return (
              (this.r = Ne(t.r)), (this.g = Ne(t.g)), (this.b = Ne(t.b)), this
            );
          }
          convertSRGBToLinear() {
            return this.copySRGBToLinear(this), this;
          }
          convertLinearToSRGB() {
            return this.copyLinearToSRGB(this), this;
          }
          getHex() {
            return (
              ((255 * this.r) << 16) ^
              ((255 * this.g) << 8) ^
              ((255 * this.b) << 0)
            );
          }
          getHexString() {
            return ("000000" + this.getHex().toString(16)).slice(-6);
          }
          getHSL(t) {
            const e = this.r,
              n = this.g,
              s = this.b,
              i = Math.max(e, n, s),
              r = Math.min(e, n, s);
            let o, a;
            const c = (r + i) / 2;
            if (r === i) (o = 0), (a = 0);
            else {
              const t = i - r;
              switch (((a = c <= 0.5 ? t / (i + r) : t / (2 - i - r)), i)) {
                case e:
                  o = (n - s) / t + (n < s ? 6 : 0);
                  break;
                case n:
                  o = (s - e) / t + 2;
                  break;
                case s:
                  o = (e - n) / t + 4;
              }
              o /= 6;
            }
            return (t.h = o), (t.s = a), (t.l = c), t;
          }
          getStyle() {
            return (
              "rgb(" +
              ((255 * this.r) | 0) +
              "," +
              ((255 * this.g) | 0) +
              "," +
              ((255 * this.b) | 0) +
              ")"
            );
          }
          offsetHSL(t, e, n) {
            return (
              this.getHSL(Re),
              (Re.h += t),
              (Re.s += e),
              (Re.l += n),
              this.setHSL(Re.h, Re.s, Re.l),
              this
            );
          }
          add(t) {
            return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
          }
          addColors(t, e) {
            return (
              (this.r = t.r + e.r),
              (this.g = t.g + e.g),
              (this.b = t.b + e.b),
              this
            );
          }
          addScalar(t) {
            return (this.r += t), (this.g += t), (this.b += t), this;
          }
          sub(t) {
            return (
              (this.r = Math.max(0, this.r - t.r)),
              (this.g = Math.max(0, this.g - t.g)),
              (this.b = Math.max(0, this.b - t.b)),
              this
            );
          }
          multiply(t) {
            return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
          }
          multiplyScalar(t) {
            return (this.r *= t), (this.g *= t), (this.b *= t), this;
          }
          lerp(t, e) {
            return (
              (this.r += (t.r - this.r) * e),
              (this.g += (t.g - this.g) * e),
              (this.b += (t.b - this.b) * e),
              this
            );
          }
          lerpColors(t, e, n) {
            return (
              (this.r = t.r + (e.r - t.r) * n),
              (this.g = t.g + (e.g - t.g) * n),
              (this.b = t.b + (e.b - t.b) * n),
              this
            );
          }
          lerpHSL(t, e) {
            this.getHSL(Re), t.getHSL(Pe);
            const n = Y(Re.h, Pe.h, e),
              s = Y(Re.s, Pe.s, e),
              i = Y(Re.l, Pe.l, e);
            return this.setHSL(n, s, i), this;
          }
          equals(t) {
            return t.r === this.r && t.g === this.g && t.b === this.b;
          }
          fromArray(t, e = 0) {
            return (
              (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this
            );
          }
          toArray(t = [], e = 0) {
            return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;
          }
          fromBufferAttribute(t, e) {
            return (
              (this.r = t.getX(e)),
              (this.g = t.getY(e)),
              (this.b = t.getZ(e)),
              !0 === t.normalized &&
                ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
              this
            );
          }
          toJSON() {
            return this.getHex();
          }
        }
        (Oe.NAMES = Le),
          (Oe.prototype.isColor = !0),
          (Oe.prototype.r = 1),
          (Oe.prototype.g = 1),
          (Oe.prototype.b = 1);
        class ke extends Ae {
          constructor(t) {
            super(),
              (this.type = "MeshBasicMaterial"),
              (this.color = new Oe(16777215)),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.specularMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.combine = 0),
              (this.reflectivity = 1),
              (this.refractionRatio = 0.98),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = "round"),
              (this.wireframeLinejoin = "round"),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              (this.specularMap = t.specularMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.combine = t.combine),
              (this.reflectivity = t.reflectivity),
              (this.refractionRatio = t.refractionRatio),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              this
            );
          }
        }
        ke.prototype.isMeshBasicMaterial = !0;
        const Ue = new ft(),
          ze = new Q();
        class Fe {
          constructor(t, e, n) {
            if (Array.isArray(t))
              throw new TypeError(
                "THREE.BufferAttribute: array should be a Typed Array."
              );
            (this.name = ""),
              (this.array = t),
              (this.itemSize = e),
              (this.count = void 0 !== t ? t.length / e : 0),
              (this.normalized = !0 === n),
              (this.usage = k),
              (this.updateRange = { offset: 0, count: -1 }),
              (this.version = 0);
          }
          onUploadCallback() {}
          set needsUpdate(t) {
            !0 === t && this.version++;
          }
          setUsage(t) {
            return (this.usage = t), this;
          }
          copy(t) {
            return (
              (this.name = t.name),
              (this.array = new t.array.constructor(t.array)),
              (this.itemSize = t.itemSize),
              (this.count = t.count),
              (this.normalized = t.normalized),
              (this.usage = t.usage),
              this
            );
          }
          copyAt(t, e, n) {
            (t *= this.itemSize), (n *= e.itemSize);
            for (let s = 0, i = this.itemSize; s < i; s++)
              this.array[t + s] = e.array[n + s];
            return this;
          }
          copyArray(t) {
            return this.array.set(t), this;
          }
          copyColorsArray(t) {
            const e = this.array;
            let n = 0;
            for (let s = 0, i = t.length; s < i; s++) {
              let i = t[s];
              void 0 === i &&
                (console.warn(
                  "THREE.BufferAttribute.copyColorsArray(): color is undefined",
                  s
                ),
                (i = new Oe())),
                (e[n++] = i.r),
                (e[n++] = i.g),
                (e[n++] = i.b);
            }
            return this;
          }
          copyVector2sArray(t) {
            const e = this.array;
            let n = 0;
            for (let s = 0, i = t.length; s < i; s++) {
              let i = t[s];
              void 0 === i &&
                (console.warn(
                  "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
                  s
                ),
                (i = new Q())),
                (e[n++] = i.x),
                (e[n++] = i.y);
            }
            return this;
          }
          copyVector3sArray(t) {
            const e = this.array;
            let n = 0;
            for (let s = 0, i = t.length; s < i; s++) {
              let i = t[s];
              void 0 === i &&
                (console.warn(
                  "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
                  s
                ),
                (i = new ft())),
                (e[n++] = i.x),
                (e[n++] = i.y),
                (e[n++] = i.z);
            }
            return this;
          }
          copyVector4sArray(t) {
            const e = this.array;
            let n = 0;
            for (let s = 0, i = t.length; s < i; s++) {
              let i = t[s];
              void 0 === i &&
                (console.warn(
                  "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
                  s
                ),
                (i = new ut())),
                (e[n++] = i.x),
                (e[n++] = i.y),
                (e[n++] = i.z),
                (e[n++] = i.w);
            }
            return this;
          }
          applyMatrix3(t) {
            if (2 === this.itemSize)
              for (let e = 0, n = this.count; e < n; e++)
                ze.fromBufferAttribute(this, e),
                  ze.applyMatrix3(t),
                  this.setXY(e, ze.x, ze.y);
            else if (3 === this.itemSize)
              for (let e = 0, n = this.count; e < n; e++)
                Ue.fromBufferAttribute(this, e),
                  Ue.applyMatrix3(t),
                  this.setXYZ(e, Ue.x, Ue.y, Ue.z);
            return this;
          }
          applyMatrix4(t) {
            for (let e = 0, n = this.count; e < n; e++)
              (Ue.x = this.getX(e)),
                (Ue.y = this.getY(e)),
                (Ue.z = this.getZ(e)),
                Ue.applyMatrix4(t),
                this.setXYZ(e, Ue.x, Ue.y, Ue.z);
            return this;
          }
          applyNormalMatrix(t) {
            for (let e = 0, n = this.count; e < n; e++)
              (Ue.x = this.getX(e)),
                (Ue.y = this.getY(e)),
                (Ue.z = this.getZ(e)),
                Ue.applyNormalMatrix(t),
                this.setXYZ(e, Ue.x, Ue.y, Ue.z);
            return this;
          }
          transformDirection(t) {
            for (let e = 0, n = this.count; e < n; e++)
              (Ue.x = this.getX(e)),
                (Ue.y = this.getY(e)),
                (Ue.z = this.getZ(e)),
                Ue.transformDirection(t),
                this.setXYZ(e, Ue.x, Ue.y, Ue.z);
            return this;
          }
          set(t, e = 0) {
            return this.array.set(t, e), this;
          }
          getX(t) {
            return this.array[t * this.itemSize];
          }
          setX(t, e) {
            return (this.array[t * this.itemSize] = e), this;
          }
          getY(t) {
            return this.array[t * this.itemSize + 1];
          }
          setY(t, e) {
            return (this.array[t * this.itemSize + 1] = e), this;
          }
          getZ(t) {
            return this.array[t * this.itemSize + 2];
          }
          setZ(t, e) {
            return (this.array[t * this.itemSize + 2] = e), this;
          }
          getW(t) {
            return this.array[t * this.itemSize + 3];
          }
          setW(t, e) {
            return (this.array[t * this.itemSize + 3] = e), this;
          }
          setXY(t, e, n) {
            return (
              (t *= this.itemSize),
              (this.array[t + 0] = e),
              (this.array[t + 1] = n),
              this
            );
          }
          setXYZ(t, e, n, s) {
            return (
              (t *= this.itemSize),
              (this.array[t + 0] = e),
              (this.array[t + 1] = n),
              (this.array[t + 2] = s),
              this
            );
          }
          setXYZW(t, e, n, s, i) {
            return (
              (t *= this.itemSize),
              (this.array[t + 0] = e),
              (this.array[t + 1] = n),
              (this.array[t + 2] = s),
              (this.array[t + 3] = i),
              this
            );
          }
          onUpload(t) {
            return (this.onUploadCallback = t), this;
          }
          clone() {
            return new this.constructor(this.array, this.itemSize).copy(this);
          }
          toJSON() {
            const t = {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: Array.prototype.slice.call(this.array),
              normalized: this.normalized,
            };
            return (
              "" !== this.name && (t.name = this.name),
              this.usage !== k && (t.usage = this.usage),
              (0 === this.updateRange.offset &&
                -1 === this.updateRange.count) ||
                (t.updateRange = this.updateRange),
              t
            );
          }
        }
        Fe.prototype.isBufferAttribute = !0;
        class Be extends Fe {
          constructor(t, e, n) {
            super(new Uint16Array(t), e, n);
          }
        }
        class He extends Fe {
          constructor(t, e, n) {
            super(new Uint32Array(t), e, n);
          }
        }
        (class extends Fe {
          constructor(t, e, n) {
            super(new Uint16Array(t), e, n);
          }
        }).prototype.isFloat16BufferAttribute = !0;
        class Ge extends Fe {
          constructor(t, e, n) {
            super(new Float32Array(t), e, n);
          }
        }
        let Ve = 0;
        const We = new Wt(),
          je = new pe(),
          Xe = new ft(),
          qe = new gt(),
          Ye = new gt(),
          Je = new ft();
        class Ze extends F {
          constructor() {
            super(),
              Object.defineProperty(this, "id", { value: Ve++ }),
              (this.uuid = j()),
              (this.name = ""),
              (this.type = "BufferGeometry"),
              (this.index = null),
              (this.attributes = {}),
              (this.morphAttributes = {}),
              (this.morphTargetsRelative = !1),
              (this.groups = []),
              (this.boundingBox = null),
              (this.boundingSphere = null),
              (this.drawRange = { start: 0, count: 1 / 0 }),
              (this.userData = {});
          }
          getIndex() {
            return this.index;
          }
          setIndex(t) {
            return (
              Array.isArray(t)
                ? (this.index = new (et(t) > 65535 ? He : Be)(t, 1))
                : (this.index = t),
              this
            );
          }
          getAttribute(t) {
            return this.attributes[t];
          }
          setAttribute(t, e) {
            return (this.attributes[t] = e), this;
          }
          deleteAttribute(t) {
            return delete this.attributes[t], this;
          }
          hasAttribute(t) {
            return void 0 !== this.attributes[t];
          }
          addGroup(t, e, n = 0) {
            this.groups.push({ start: t, count: e, materialIndex: n });
          }
          clearGroups() {
            this.groups = [];
          }
          setDrawRange(t, e) {
            (this.drawRange.start = t), (this.drawRange.count = e);
          }
          applyMatrix4(t) {
            const e = this.attributes.position;
            void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
            const n = this.attributes.normal;
            if (void 0 !== n) {
              const e = new tt().getNormalMatrix(t);
              n.applyNormalMatrix(e), (n.needsUpdate = !0);
            }
            const s = this.attributes.tangent;
            return (
              void 0 !== s && (s.transformDirection(t), (s.needsUpdate = !0)),
              null !== this.boundingBox && this.computeBoundingBox(),
              null !== this.boundingSphere && this.computeBoundingSphere(),
              this
            );
          }
          applyQuaternion(t) {
            return (
              We.makeRotationFromQuaternion(t), this.applyMatrix4(We), this
            );
          }
          rotateX(t) {
            return We.makeRotationX(t), this.applyMatrix4(We), this;
          }
          rotateY(t) {
            return We.makeRotationY(t), this.applyMatrix4(We), this;
          }
          rotateZ(t) {
            return We.makeRotationZ(t), this.applyMatrix4(We), this;
          }
          translate(t, e, n) {
            return We.makeTranslation(t, e, n), this.applyMatrix4(We), this;
          }
          scale(t, e, n) {
            return We.makeScale(t, e, n), this.applyMatrix4(We), this;
          }
          lookAt(t) {
            return (
              je.lookAt(t),
              je.updateMatrix(),
              this.applyMatrix4(je.matrix),
              this
            );
          }
          center() {
            return (
              this.computeBoundingBox(),
              this.boundingBox.getCenter(Xe).negate(),
              this.translate(Xe.x, Xe.y, Xe.z),
              this
            );
          }
          setFromPoints(t) {
            const e = [];
            for (let n = 0, s = t.length; n < s; n++) {
              const s = t[n];
              e.push(s.x, s.y, s.z || 0);
            }
            return this.setAttribute("position", new Ge(e, 3)), this;
          }
          computeBoundingBox() {
            null === this.boundingBox && (this.boundingBox = new gt());
            const t = this.attributes.position,
              e = this.morphAttributes.position;
            if (t && t.isGLBufferAttribute)
              return (
                console.error(
                  'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
                  this
                ),
                void this.boundingBox.set(
                  new ft(-1 / 0, -1 / 0, -1 / 0),
                  new ft(1 / 0, 1 / 0, 1 / 0)
                )
              );
            if (void 0 !== t) {
              if ((this.boundingBox.setFromBufferAttribute(t), e))
                for (let t = 0, n = e.length; t < n; t++) {
                  const n = e[t];
                  qe.setFromBufferAttribute(n),
                    this.morphTargetsRelative
                      ? (Je.addVectors(this.boundingBox.min, qe.min),
                        this.boundingBox.expandByPoint(Je),
                        Je.addVectors(this.boundingBox.max, qe.max),
                        this.boundingBox.expandByPoint(Je))
                      : (this.boundingBox.expandByPoint(qe.min),
                        this.boundingBox.expandByPoint(qe.max));
                }
            } else this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) ||
              isNaN(this.boundingBox.min.y) ||
              isNaN(this.boundingBox.min.z)) &&
              console.error(
                'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
                this
              );
          }
          computeBoundingSphere() {
            null === this.boundingSphere && (this.boundingSphere = new Ot());
            const t = this.attributes.position,
              e = this.morphAttributes.position;
            if (t && t.isGLBufferAttribute)
              return (
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
                  this
                ),
                void this.boundingSphere.set(new ft(), 1 / 0)
              );
            if (t) {
              const n = this.boundingSphere.center;
              if ((qe.setFromBufferAttribute(t), e))
                for (let t = 0, n = e.length; t < n; t++) {
                  const n = e[t];
                  Ye.setFromBufferAttribute(n),
                    this.morphTargetsRelative
                      ? (Je.addVectors(qe.min, Ye.min),
                        qe.expandByPoint(Je),
                        Je.addVectors(qe.max, Ye.max),
                        qe.expandByPoint(Je))
                      : (qe.expandByPoint(Ye.min), qe.expandByPoint(Ye.max));
                }
              qe.getCenter(n);
              let s = 0;
              for (let e = 0, i = t.count; e < i; e++)
                Je.fromBufferAttribute(t, e),
                  (s = Math.max(s, n.distanceToSquared(Je)));
              if (e)
                for (let i = 0, r = e.length; i < r; i++) {
                  const r = e[i],
                    o = this.morphTargetsRelative;
                  for (let e = 0, i = r.count; e < i; e++)
                    Je.fromBufferAttribute(r, e),
                      o && (Xe.fromBufferAttribute(t, e), Je.add(Xe)),
                      (s = Math.max(s, n.distanceToSquared(Je)));
                }
              (this.boundingSphere.radius = Math.sqrt(s)),
                isNaN(this.boundingSphere.radius) &&
                  console.error(
                    'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                    this
                  );
            }
          }
          computeTangents() {
            const t = this.index,
              e = this.attributes;
            if (
              null === t ||
              void 0 === e.position ||
              void 0 === e.normal ||
              void 0 === e.uv
            )
              return void console.error(
                "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
              );
            const n = t.array,
              s = e.position.array,
              i = e.normal.array,
              r = e.uv.array,
              o = s.length / 3;
            void 0 === e.tangent &&
              this.setAttribute("tangent", new Fe(new Float32Array(4 * o), 4));
            const a = e.tangent.array,
              c = [],
              u = [];
            for (let t = 0; t < o; t++) (c[t] = new ft()), (u[t] = new ft());
            const d = new ft(),
              l = new ft(),
              h = new ft(),
              f = new Q(),
              m = new Q(),
              p = new Q(),
              g = new ft(),
              x = new ft();
            function v(t, e, n) {
              d.fromArray(s, 3 * t),
                l.fromArray(s, 3 * e),
                h.fromArray(s, 3 * n),
                f.fromArray(r, 2 * t),
                m.fromArray(r, 2 * e),
                p.fromArray(r, 2 * n),
                l.sub(d),
                h.sub(d),
                m.sub(f),
                p.sub(f);
              const i = 1 / (m.x * p.y - p.x * m.y);
              isFinite(i) &&
                (g
                  .copy(l)
                  .multiplyScalar(p.y)
                  .addScaledVector(h, -m.y)
                  .multiplyScalar(i),
                x
                  .copy(h)
                  .multiplyScalar(m.x)
                  .addScaledVector(l, -p.x)
                  .multiplyScalar(i),
                c[t].add(g),
                c[e].add(g),
                c[n].add(g),
                u[t].add(x),
                u[e].add(x),
                u[n].add(x));
            }
            let y = this.groups;
            0 === y.length && (y = [{ start: 0, count: n.length }]);
            for (let t = 0, e = y.length; t < e; ++t) {
              const e = y[t],
                s = e.start;
              for (let t = s, i = s + e.count; t < i; t += 3)
                v(n[t + 0], n[t + 1], n[t + 2]);
            }
            const w = new ft(),
              _ = new ft(),
              b = new ft(),
              M = new ft();
            function S(t) {
              b.fromArray(i, 3 * t), M.copy(b);
              const e = c[t];
              w.copy(e),
                w.sub(b.multiplyScalar(b.dot(e))).normalize(),
                _.crossVectors(M, e);
              const n = _.dot(u[t]) < 0 ? -1 : 1;
              (a[4 * t] = w.x),
                (a[4 * t + 1] = w.y),
                (a[4 * t + 2] = w.z),
                (a[4 * t + 3] = n);
            }
            for (let t = 0, e = y.length; t < e; ++t) {
              const e = y[t],
                s = e.start;
              for (let t = s, i = s + e.count; t < i; t += 3)
                S(n[t + 0]), S(n[t + 1]), S(n[t + 2]);
            }
          }
          computeVertexNormals() {
            const t = this.index,
              e = this.getAttribute("position");
            if (void 0 !== e) {
              let n = this.getAttribute("normal");
              if (void 0 === n)
                (n = new Fe(new Float32Array(3 * e.count), 3)),
                  this.setAttribute("normal", n);
              else
                for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
              const s = new ft(),
                i = new ft(),
                r = new ft(),
                o = new ft(),
                a = new ft(),
                c = new ft(),
                u = new ft(),
                d = new ft();
              if (t)
                for (let l = 0, h = t.count; l < h; l += 3) {
                  const h = t.getX(l + 0),
                    f = t.getX(l + 1),
                    m = t.getX(l + 2);
                  s.fromBufferAttribute(e, h),
                    i.fromBufferAttribute(e, f),
                    r.fromBufferAttribute(e, m),
                    u.subVectors(r, i),
                    d.subVectors(s, i),
                    u.cross(d),
                    o.fromBufferAttribute(n, h),
                    a.fromBufferAttribute(n, f),
                    c.fromBufferAttribute(n, m),
                    o.add(u),
                    a.add(u),
                    c.add(u),
                    n.setXYZ(h, o.x, o.y, o.z),
                    n.setXYZ(f, a.x, a.y, a.z),
                    n.setXYZ(m, c.x, c.y, c.z);
                }
              else
                for (let t = 0, o = e.count; t < o; t += 3)
                  s.fromBufferAttribute(e, t + 0),
                    i.fromBufferAttribute(e, t + 1),
                    r.fromBufferAttribute(e, t + 2),
                    u.subVectors(r, i),
                    d.subVectors(s, i),
                    u.cross(d),
                    n.setXYZ(t + 0, u.x, u.y, u.z),
                    n.setXYZ(t + 1, u.x, u.y, u.z),
                    n.setXYZ(t + 2, u.x, u.y, u.z);
              this.normalizeNormals(), (n.needsUpdate = !0);
            }
          }
          merge(t, e) {
            if (!t || !t.isBufferGeometry)
              return void console.error(
                "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
                t
              );
            void 0 === e &&
              ((e = 0),
              console.warn(
                "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
              ));
            const n = this.attributes;
            for (const s in n) {
              if (void 0 === t.attributes[s]) continue;
              const i = n[s].array,
                r = t.attributes[s],
                o = r.array,
                a = r.itemSize * e,
                c = Math.min(o.length, i.length - a);
              for (let t = 0, e = a; t < c; t++, e++) i[e] = o[t];
            }
            return this;
          }
          normalizeNormals() {
            const t = this.attributes.normal;
            for (let e = 0, n = t.count; e < n; e++)
              Je.fromBufferAttribute(t, e),
                Je.normalize(),
                t.setXYZ(e, Je.x, Je.y, Je.z);
          }
          toNonIndexed() {
            function t(t, e) {
              const n = t.array,
                s = t.itemSize,
                i = t.normalized,
                r = new n.constructor(e.length * s);
              let o = 0,
                a = 0;
              for (let i = 0, c = e.length; i < c; i++) {
                o = t.isInterleavedBufferAttribute
                  ? e[i] * t.data.stride + t.offset
                  : e[i] * s;
                for (let t = 0; t < s; t++) r[a++] = n[o++];
              }
              return new Fe(r, s, i);
            }
            if (null === this.index)
              return (
                console.warn(
                  "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
                ),
                this
              );
            const e = new Ze(),
              n = this.index.array,
              s = this.attributes;
            for (const i in s) {
              const r = t(s[i], n);
              e.setAttribute(i, r);
            }
            const i = this.morphAttributes;
            for (const s in i) {
              const r = [],
                o = i[s];
              for (let e = 0, s = o.length; e < s; e++) {
                const s = t(o[e], n);
                r.push(s);
              }
              e.morphAttributes[s] = r;
            }
            e.morphTargetsRelative = this.morphTargetsRelative;
            const r = this.groups;
            for (let t = 0, n = r.length; t < n; t++) {
              const n = r[t];
              e.addGroup(n.start, n.count, n.materialIndex);
            }
            return e;
          }
          toJSON() {
            const t = {
              metadata: {
                version: 4.5,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON",
              },
            };
            if (
              ((t.uuid = this.uuid),
              (t.type = this.type),
              "" !== this.name && (t.name = this.name),
              Object.keys(this.userData).length > 0 &&
                (t.userData = this.userData),
              void 0 !== this.parameters)
            ) {
              const e = this.parameters;
              for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
              return t;
            }
            t.data = { attributes: {} };
            const e = this.index;
            null !== e &&
              (t.data.index = {
                type: e.array.constructor.name,
                array: Array.prototype.slice.call(e.array),
              });
            const n = this.attributes;
            for (const e in n) {
              const s = n[e];
              t.data.attributes[e] = s.toJSON(t.data);
            }
            const s = {};
            let i = !1;
            for (const e in this.morphAttributes) {
              const n = this.morphAttributes[e],
                r = [];
              for (let e = 0, s = n.length; e < s; e++) {
                const s = n[e];
                r.push(s.toJSON(t.data));
              }
              r.length > 0 && ((s[e] = r), (i = !0));
            }
            i &&
              ((t.data.morphAttributes = s),
              (t.data.morphTargetsRelative = this.morphTargetsRelative));
            const r = this.groups;
            r.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(r)));
            const o = this.boundingSphere;
            return (
              null !== o &&
                (t.data.boundingSphere = {
                  center: o.center.toArray(),
                  radius: o.radius,
                }),
              t
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            (this.index = null),
              (this.attributes = {}),
              (this.morphAttributes = {}),
              (this.groups = []),
              (this.boundingBox = null),
              (this.boundingSphere = null);
            const e = {};
            this.name = t.name;
            const n = t.index;
            null !== n && this.setIndex(n.clone(e));
            const s = t.attributes;
            for (const t in s) {
              const n = s[t];
              this.setAttribute(t, n.clone(e));
            }
            const i = t.morphAttributes;
            for (const t in i) {
              const n = [],
                s = i[t];
              for (let t = 0, i = s.length; t < i; t++) n.push(s[t].clone(e));
              this.morphAttributes[t] = n;
            }
            this.morphTargetsRelative = t.morphTargetsRelative;
            const r = t.groups;
            for (let t = 0, e = r.length; t < e; t++) {
              const e = r[t];
              this.addGroup(e.start, e.count, e.materialIndex);
            }
            const o = t.boundingBox;
            null !== o && (this.boundingBox = o.clone());
            const a = t.boundingSphere;
            return (
              null !== a && (this.boundingSphere = a.clone()),
              (this.drawRange.start = t.drawRange.start),
              (this.drawRange.count = t.drawRange.count),
              (this.userData = t.userData),
              void 0 !== t.parameters &&
                (this.parameters = Object.assign({}, t.parameters)),
              this
            );
          }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
        }
        Ze.prototype.isBufferGeometry = !0;
        const $e = new Wt(),
          Ke = new Vt(),
          Qe = new Ot(),
          tn = new ft(),
          en = new ft(),
          nn = new ft(),
          sn = new ft(),
          rn = new ft(),
          on = new ft(),
          an = new ft(),
          cn = new ft(),
          un = new ft(),
          dn = new Q(),
          ln = new Q(),
          hn = new Q(),
          fn = new ft(),
          mn = new ft();
        class pn extends pe {
          constructor(t = new Ze(), e = new ke()) {
            super(),
              (this.type = "Mesh"),
              (this.geometry = t),
              (this.material = e),
              this.updateMorphTargets();
          }
          copy(t) {
            return (
              super.copy(t),
              void 0 !== t.morphTargetInfluences &&
                (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
              void 0 !== t.morphTargetDictionary &&
                (this.morphTargetDictionary = Object.assign(
                  {},
                  t.morphTargetDictionary
                )),
              (this.material = t.material),
              (this.geometry = t.geometry),
              this
            );
          }
          updateMorphTargets() {
            const t = this.geometry;
            if (t.isBufferGeometry) {
              const e = t.morphAttributes,
                n = Object.keys(e);
              if (n.length > 0) {
                const t = e[n[0]];
                if (void 0 !== t) {
                  (this.morphTargetInfluences = []),
                    (this.morphTargetDictionary = {});
                  for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e].name || String(e);
                    this.morphTargetInfluences.push(0),
                      (this.morphTargetDictionary[n] = e);
                  }
                }
              }
            } else {
              const e = t.morphTargets;
              void 0 !== e &&
                e.length > 0 &&
                console.error(
                  "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
                );
            }
          }
          raycast(t, e) {
            const n = this.geometry,
              s = this.material,
              i = this.matrixWorld;
            if (void 0 === s) return;
            if (
              (null === n.boundingSphere && n.computeBoundingSphere(),
              Qe.copy(n.boundingSphere),
              Qe.applyMatrix4(i),
              !1 === t.ray.intersectsSphere(Qe))
            )
              return;
            if (
              ($e.copy(i).invert(),
              Ke.copy(t.ray).applyMatrix4($e),
              null !== n.boundingBox && !1 === Ke.intersectsBox(n.boundingBox))
            )
              return;
            let r;
            if (n.isBufferGeometry) {
              const i = n.index,
                o = n.attributes.position,
                a = n.morphAttributes.position,
                c = n.morphTargetsRelative,
                u = n.attributes.uv,
                d = n.attributes.uv2,
                l = n.groups,
                h = n.drawRange;
              if (null !== i)
                if (Array.isArray(s))
                  for (let n = 0, f = l.length; n < f; n++) {
                    const f = l[n],
                      m = s[f.materialIndex];
                    for (
                      let n = Math.max(f.start, h.start),
                        s = Math.min(
                          i.count,
                          Math.min(f.start + f.count, h.start + h.count)
                        );
                      n < s;
                      n += 3
                    ) {
                      const s = i.getX(n),
                        l = i.getX(n + 1),
                        h = i.getX(n + 2);
                      (r = gn(this, m, t, Ke, o, a, c, u, d, s, l, h)),
                        r &&
                          ((r.faceIndex = Math.floor(n / 3)),
                          (r.face.materialIndex = f.materialIndex),
                          e.push(r));
                    }
                  }
                else
                  for (
                    let n = Math.max(0, h.start),
                      l = Math.min(i.count, h.start + h.count);
                    n < l;
                    n += 3
                  ) {
                    const l = i.getX(n),
                      h = i.getX(n + 1),
                      f = i.getX(n + 2);
                    (r = gn(this, s, t, Ke, o, a, c, u, d, l, h, f)),
                      r && ((r.faceIndex = Math.floor(n / 3)), e.push(r));
                  }
              else if (void 0 !== o)
                if (Array.isArray(s))
                  for (let n = 0, i = l.length; n < i; n++) {
                    const i = l[n],
                      f = s[i.materialIndex];
                    for (
                      let n = Math.max(i.start, h.start),
                        s = Math.min(
                          o.count,
                          Math.min(i.start + i.count, h.start + h.count)
                        );
                      n < s;
                      n += 3
                    )
                      (r = gn(this, f, t, Ke, o, a, c, u, d, n, n + 1, n + 2)),
                        r &&
                          ((r.faceIndex = Math.floor(n / 3)),
                          (r.face.materialIndex = i.materialIndex),
                          e.push(r));
                  }
                else
                  for (
                    let n = Math.max(0, h.start),
                      i = Math.min(o.count, h.start + h.count);
                    n < i;
                    n += 3
                  )
                    (r = gn(this, s, t, Ke, o, a, c, u, d, n, n + 1, n + 2)),
                      r && ((r.faceIndex = Math.floor(n / 3)), e.push(r));
            } else
              n.isGeometry &&
                console.error(
                  "THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
                );
          }
        }
        function gn(t, e, n, s, i, r, o, a, c, u, d, l) {
          tn.fromBufferAttribute(i, u),
            en.fromBufferAttribute(i, d),
            nn.fromBufferAttribute(i, l);
          const h = t.morphTargetInfluences;
          if (r && h) {
            an.set(0, 0, 0), cn.set(0, 0, 0), un.set(0, 0, 0);
            for (let t = 0, e = r.length; t < e; t++) {
              const e = h[t],
                n = r[t];
              0 !== e &&
                (sn.fromBufferAttribute(n, u),
                rn.fromBufferAttribute(n, d),
                on.fromBufferAttribute(n, l),
                o
                  ? (an.addScaledVector(sn, e),
                    cn.addScaledVector(rn, e),
                    un.addScaledVector(on, e))
                  : (an.addScaledVector(sn.sub(tn), e),
                    cn.addScaledVector(rn.sub(en), e),
                    un.addScaledVector(on.sub(nn), e)));
            }
            tn.add(an), en.add(cn), nn.add(un);
          }
          t.isSkinnedMesh &&
            (t.boneTransform(u, tn),
            t.boneTransform(d, en),
            t.boneTransform(l, nn));
          const f = (function (t, e, n, s, i, r, o, a) {
            let c;
            if (
              ((c =
                1 === e.side
                  ? s.intersectTriangle(o, r, i, !0, a)
                  : s.intersectTriangle(i, r, o, 2 !== e.side, a)),
              null === c)
            )
              return null;
            mn.copy(a), mn.applyMatrix4(t.matrixWorld);
            const u = n.ray.origin.distanceTo(mn);
            return u < n.near || u > n.far
              ? null
              : { distance: u, point: mn.clone(), object: t };
          })(t, e, n, s, tn, en, nn, fn);
          if (f) {
            a &&
              (dn.fromBufferAttribute(a, u),
              ln.fromBufferAttribute(a, d),
              hn.fromBufferAttribute(a, l),
              (f.uv = Ee.getUV(fn, tn, en, nn, dn, ln, hn, new Q()))),
              c &&
                (dn.fromBufferAttribute(c, u),
                ln.fromBufferAttribute(c, d),
                hn.fromBufferAttribute(c, l),
                (f.uv2 = Ee.getUV(fn, tn, en, nn, dn, ln, hn, new Q())));
            const t = { a: u, b: d, c: l, normal: new ft(), materialIndex: 0 };
            Ee.getNormal(tn, en, nn, t.normal), (f.face = t);
          }
          return f;
        }
        pn.prototype.isMesh = !0;
        class xn extends Ze {
          constructor(t = 1, e = 1, n = 1, s = 1, i = 1, r = 1) {
            super(),
              (this.type = "BoxGeometry"),
              (this.parameters = {
                width: t,
                height: e,
                depth: n,
                widthSegments: s,
                heightSegments: i,
                depthSegments: r,
              });
            const o = this;
            (s = Math.floor(s)), (i = Math.floor(i)), (r = Math.floor(r));
            const a = [],
              c = [],
              u = [],
              d = [];
            let l = 0,
              h = 0;
            function f(t, e, n, s, i, r, f, m, p, g, x) {
              const v = r / p,
                y = f / g,
                w = r / 2,
                _ = f / 2,
                b = m / 2,
                M = p + 1,
                S = g + 1;
              let T = 0,
                E = 0;
              const C = new ft();
              for (let r = 0; r < S; r++) {
                const o = r * y - _;
                for (let a = 0; a < M; a++) {
                  const l = a * v - w;
                  (C[t] = l * s),
                    (C[e] = o * i),
                    (C[n] = b),
                    c.push(C.x, C.y, C.z),
                    (C[t] = 0),
                    (C[e] = 0),
                    (C[n] = m > 0 ? 1 : -1),
                    u.push(C.x, C.y, C.z),
                    d.push(a / p),
                    d.push(1 - r / g),
                    (T += 1);
                }
              }
              for (let t = 0; t < g; t++)
                for (let e = 0; e < p; e++) {
                  const n = l + e + M * t,
                    s = l + e + M * (t + 1),
                    i = l + (e + 1) + M * (t + 1),
                    r = l + (e + 1) + M * t;
                  a.push(n, s, r), a.push(s, i, r), (E += 6);
                }
              o.addGroup(h, E, x), (h += E), (l += T);
            }
            f("z", "y", "x", -1, -1, n, e, t, r, i, 0),
              f("z", "y", "x", 1, -1, n, e, -t, r, i, 1),
              f("x", "z", "y", 1, 1, t, n, e, s, r, 2),
              f("x", "z", "y", 1, -1, t, n, -e, s, r, 3),
              f("x", "y", "z", 1, -1, t, e, n, s, i, 4),
              f("x", "y", "z", -1, -1, t, e, -n, s, i, 5),
              this.setIndex(a),
              this.setAttribute("position", new Ge(c, 3)),
              this.setAttribute("normal", new Ge(u, 3)),
              this.setAttribute("uv", new Ge(d, 2));
          }
          static fromJSON(t) {
            return new xn(
              t.width,
              t.height,
              t.depth,
              t.widthSegments,
              t.heightSegments,
              t.depthSegments
            );
          }
        }
        function vn(t) {
          const e = {};
          for (const n in t) {
            e[n] = {};
            for (const s in t[n]) {
              const i = t[n][s];
              i &&
              (i.isColor ||
                i.isMatrix3 ||
                i.isMatrix4 ||
                i.isVector2 ||
                i.isVector3 ||
                i.isVector4 ||
                i.isTexture ||
                i.isQuaternion)
                ? (e[n][s] = i.clone())
                : Array.isArray(i)
                ? (e[n][s] = i.slice())
                : (e[n][s] = i);
            }
          }
          return e;
        }
        function yn(t) {
          const e = {};
          for (let n = 0; n < t.length; n++) {
            const s = vn(t[n]);
            for (const t in s) e[t] = s[t];
          }
          return e;
        }
        const wn = { clone: vn, merge: yn };
        class _n extends Ae {
          constructor(t) {
            super(),
              (this.type = "ShaderMaterial"),
              (this.defines = {}),
              (this.uniforms = {}),
              (this.vertexShader =
                "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
              (this.fragmentShader =
                "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
              (this.linewidth = 1),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.fog = !1),
              (this.lights = !1),
              (this.clipping = !1),
              (this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1,
              }),
              (this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0],
              }),
              (this.index0AttributeName = void 0),
              (this.uniformsNeedUpdate = !1),
              (this.glslVersion = null),
              void 0 !== t &&
                (void 0 !== t.attributes &&
                  console.error(
                    "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
                  ),
                this.setValues(t));
          }
          copy(t) {
            return (
              super.copy(t),
              (this.fragmentShader = t.fragmentShader),
              (this.vertexShader = t.vertexShader),
              (this.uniforms = vn(t.uniforms)),
              (this.defines = Object.assign({}, t.defines)),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.lights = t.lights),
              (this.clipping = t.clipping),
              (this.extensions = Object.assign({}, t.extensions)),
              (this.glslVersion = t.glslVersion),
              this
            );
          }
          toJSON(t) {
            const e = super.toJSON(t);
            (e.glslVersion = this.glslVersion), (e.uniforms = {});
            for (const n in this.uniforms) {
              const s = this.uniforms[n].value;
              s && s.isTexture
                ? (e.uniforms[n] = { type: "t", value: s.toJSON(t).uuid })
                : s && s.isColor
                ? (e.uniforms[n] = { type: "c", value: s.getHex() })
                : s && s.isVector2
                ? (e.uniforms[n] = { type: "v2", value: s.toArray() })
                : s && s.isVector3
                ? (e.uniforms[n] = { type: "v3", value: s.toArray() })
                : s && s.isVector4
                ? (e.uniforms[n] = { type: "v4", value: s.toArray() })
                : s && s.isMatrix3
                ? (e.uniforms[n] = { type: "m3", value: s.toArray() })
                : s && s.isMatrix4
                ? (e.uniforms[n] = { type: "m4", value: s.toArray() })
                : (e.uniforms[n] = { value: s });
            }
            Object.keys(this.defines).length > 0 && (e.defines = this.defines),
              (e.vertexShader = this.vertexShader),
              (e.fragmentShader = this.fragmentShader);
            const n = {};
            for (const t in this.extensions)
              !0 === this.extensions[t] && (n[t] = !0);
            return Object.keys(n).length > 0 && (e.extensions = n), e;
          }
        }
        _n.prototype.isShaderMaterial = !0;
        class bn extends pe {
          constructor() {
            super(),
              (this.type = "Camera"),
              (this.matrixWorldInverse = new Wt()),
              (this.projectionMatrix = new Wt()),
              (this.projectionMatrixInverse = new Wt());
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              this.matrixWorldInverse.copy(t.matrixWorldInverse),
              this.projectionMatrix.copy(t.projectionMatrix),
              this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
              this
            );
          }
          getWorldDirection(t) {
            this.updateWorldMatrix(!0, !1);
            const e = this.matrixWorld.elements;
            return t.set(-e[8], -e[9], -e[10]).normalize();
          }
          updateMatrixWorld(t) {
            super.updateMatrixWorld(t),
              this.matrixWorldInverse.copy(this.matrixWorld).invert();
          }
          updateWorldMatrix(t, e) {
            super.updateWorldMatrix(t, e),
              this.matrixWorldInverse.copy(this.matrixWorld).invert();
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        bn.prototype.isCamera = !0;
        class Mn extends bn {
          constructor(t = 50, e = 1, n = 0.1, s = 2e3) {
            super(),
              (this.type = "PerspectiveCamera"),
              (this.fov = t),
              (this.zoom = 1),
              (this.near = n),
              (this.far = s),
              (this.focus = 10),
              (this.aspect = e),
              (this.view = null),
              (this.filmGauge = 35),
              (this.filmOffset = 0),
              this.updateProjectionMatrix();
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              (this.fov = t.fov),
              (this.zoom = t.zoom),
              (this.near = t.near),
              (this.far = t.far),
              (this.focus = t.focus),
              (this.aspect = t.aspect),
              (this.view = null === t.view ? null : Object.assign({}, t.view)),
              (this.filmGauge = t.filmGauge),
              (this.filmOffset = t.filmOffset),
              this
            );
          }
          setFocalLength(t) {
            const e = (0.5 * this.getFilmHeight()) / t;
            (this.fov = 2 * G * Math.atan(e)), this.updateProjectionMatrix();
          }
          getFocalLength() {
            const t = Math.tan(0.5 * H * this.fov);
            return (0.5 * this.getFilmHeight()) / t;
          }
          getEffectiveFOV() {
            return 2 * G * Math.atan(Math.tan(0.5 * H * this.fov) / this.zoom);
          }
          getFilmWidth() {
            return this.filmGauge * Math.min(this.aspect, 1);
          }
          getFilmHeight() {
            return this.filmGauge / Math.max(this.aspect, 1);
          }
          setViewOffset(t, e, n, s, i, r) {
            (this.aspect = t / e),
              null === this.view &&
                (this.view = {
                  enabled: !0,
                  fullWidth: 1,
                  fullHeight: 1,
                  offsetX: 0,
                  offsetY: 0,
                  width: 1,
                  height: 1,
                }),
              (this.view.enabled = !0),
              (this.view.fullWidth = t),
              (this.view.fullHeight = e),
              (this.view.offsetX = n),
              (this.view.offsetY = s),
              (this.view.width = i),
              (this.view.height = r),
              this.updateProjectionMatrix();
          }
          clearViewOffset() {
            null !== this.view && (this.view.enabled = !1),
              this.updateProjectionMatrix();
          }
          updateProjectionMatrix() {
            const t = this.near;
            let e = (t * Math.tan(0.5 * H * this.fov)) / this.zoom,
              n = 2 * e,
              s = this.aspect * n,
              i = -0.5 * s;
            const r = this.view;
            if (null !== this.view && this.view.enabled) {
              const t = r.fullWidth,
                o = r.fullHeight;
              (i += (r.offsetX * s) / t),
                (e -= (r.offsetY * n) / o),
                (s *= r.width / t),
                (n *= r.height / o);
            }
            const o = this.filmOffset;
            0 !== o && (i += (t * o) / this.getFilmWidth()),
              this.projectionMatrix.makePerspective(
                i,
                i + s,
                e,
                e - n,
                t,
                this.far
              ),
              this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              (e.object.fov = this.fov),
              (e.object.zoom = this.zoom),
              (e.object.near = this.near),
              (e.object.far = this.far),
              (e.object.focus = this.focus),
              (e.object.aspect = this.aspect),
              null !== this.view &&
                (e.object.view = Object.assign({}, this.view)),
              (e.object.filmGauge = this.filmGauge),
              (e.object.filmOffset = this.filmOffset),
              e
            );
          }
        }
        Mn.prototype.isPerspectiveCamera = !0;
        const Sn = 90;
        class Tn extends pe {
          constructor(t, e, n) {
            if (
              (super(),
              (this.type = "CubeCamera"),
              !0 !== n.isWebGLCubeRenderTarget)
            )
              return void console.error(
                "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
              );
            this.renderTarget = n;
            const s = new Mn(Sn, 1, t, e);
            (s.layers = this.layers),
              s.up.set(0, -1, 0),
              s.lookAt(new ft(1, 0, 0)),
              this.add(s);
            const i = new Mn(Sn, 1, t, e);
            (i.layers = this.layers),
              i.up.set(0, -1, 0),
              i.lookAt(new ft(-1, 0, 0)),
              this.add(i);
            const r = new Mn(Sn, 1, t, e);
            (r.layers = this.layers),
              r.up.set(0, 0, 1),
              r.lookAt(new ft(0, 1, 0)),
              this.add(r);
            const o = new Mn(Sn, 1, t, e);
            (o.layers = this.layers),
              o.up.set(0, 0, -1),
              o.lookAt(new ft(0, -1, 0)),
              this.add(o);
            const a = new Mn(Sn, 1, t, e);
            (a.layers = this.layers),
              a.up.set(0, -1, 0),
              a.lookAt(new ft(0, 0, 1)),
              this.add(a);
            const c = new Mn(Sn, 1, t, e);
            (c.layers = this.layers),
              c.up.set(0, -1, 0),
              c.lookAt(new ft(0, 0, -1)),
              this.add(c);
          }
          update(t, e) {
            null === this.parent && this.updateMatrixWorld();
            const n = this.renderTarget,
              [s, i, r, o, a, c] = this.children,
              u = t.xr.enabled,
              d = t.getRenderTarget();
            t.xr.enabled = !1;
            const l = n.texture.generateMipmaps;
            (n.texture.generateMipmaps = !1),
              t.setRenderTarget(n, 0),
              t.render(e, s),
              t.setRenderTarget(n, 1),
              t.render(e, i),
              t.setRenderTarget(n, 2),
              t.render(e, r),
              t.setRenderTarget(n, 3),
              t.render(e, o),
              t.setRenderTarget(n, 4),
              t.render(e, a),
              (n.texture.generateMipmaps = l),
              t.setRenderTarget(n, 5),
              t.render(e, c),
              t.setRenderTarget(d),
              (t.xr.enabled = u);
          }
        }
        class En extends at {
          constructor(t, e, n, s, r, o, a, c, u, d) {
            super(
              (t = void 0 !== t ? t : []),
              (e = void 0 !== e ? e : i),
              n,
              s,
              r,
              o,
              a,
              c,
              u,
              d
            ),
              (this.flipY = !1);
          }
          get images() {
            return this.image;
          }
          set images(t) {
            this.image = t;
          }
        }
        En.prototype.isCubeTexture = !0;
        class Cn extends dt {
          constructor(t, e, n) {
            Number.isInteger(e) &&
              (console.warn(
                "THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"
              ),
              (e = n)),
              super(t, t, e),
              (e = e || {}),
              (this.texture = new En(
                void 0,
                e.mapping,
                e.wrapS,
                e.wrapT,
                e.magFilter,
                e.minFilter,
                e.format,
                e.type,
                e.anisotropy,
                e.encoding
              )),
              (this.texture.isRenderTargetTexture = !0),
              (this.texture.generateMipmaps =
                void 0 !== e.generateMipmaps && e.generateMipmaps),
              (this.texture.minFilter =
                void 0 !== e.minFilter ? e.minFilter : f),
              (this.texture._needsFlipEnvMap = !1);
          }
          fromEquirectangularTexture(t, e) {
            (this.texture.type = e.type),
              (this.texture.format = b),
              (this.texture.encoding = e.encoding),
              (this.texture.generateMipmaps = e.generateMipmaps),
              (this.texture.minFilter = e.minFilter),
              (this.texture.magFilter = e.magFilter);
            const n = { tEquirect: { value: null } },
              s =
                "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
              i =
                "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
              r = new xn(5, 5, 5),
              o = new _n({
                name: "CubemapFromEquirect",
                uniforms: vn(n),
                vertexShader: s,
                fragmentShader: i,
                side: 1,
                blending: 0,
              });
            o.uniforms.tEquirect.value = e;
            const a = new pn(r, o),
              c = e.minFilter;
            return (
              e.minFilter === m && (e.minFilter = f),
              new Tn(1, 10, this).update(t, a),
              (e.minFilter = c),
              a.geometry.dispose(),
              a.material.dispose(),
              this
            );
          }
          clear(t, e, n, s) {
            const i = t.getRenderTarget();
            for (let i = 0; i < 6; i++)
              t.setRenderTarget(this, i), t.clear(e, n, s);
            t.setRenderTarget(i);
          }
        }
        Cn.prototype.isWebGLCubeRenderTarget = !0;
        const An = new ft(),
          Ln = new ft(),
          Rn = new tt();
        class Pn {
          constructor(t = new ft(1, 0, 0), e = 0) {
            (this.normal = t), (this.constant = e);
          }
          set(t, e) {
            return this.normal.copy(t), (this.constant = e), this;
          }
          setComponents(t, e, n, s) {
            return this.normal.set(t, e, n), (this.constant = s), this;
          }
          setFromNormalAndCoplanarPoint(t, e) {
            return (
              this.normal.copy(t), (this.constant = -e.dot(this.normal)), this
            );
          }
          setFromCoplanarPoints(t, e, n) {
            const s = An.subVectors(n, e)
              .cross(Ln.subVectors(t, e))
              .normalize();
            return this.setFromNormalAndCoplanarPoint(s, t), this;
          }
          copy(t) {
            return (
              this.normal.copy(t.normal), (this.constant = t.constant), this
            );
          }
          normalize() {
            const t = 1 / this.normal.length();
            return this.normal.multiplyScalar(t), (this.constant *= t), this;
          }
          negate() {
            return (this.constant *= -1), this.normal.negate(), this;
          }
          distanceToPoint(t) {
            return this.normal.dot(t) + this.constant;
          }
          distanceToSphere(t) {
            return this.distanceToPoint(t.center) - t.radius;
          }
          projectPoint(t, e) {
            return e
              .copy(this.normal)
              .multiplyScalar(-this.distanceToPoint(t))
              .add(t);
          }
          intersectLine(t, e) {
            const n = t.delta(An),
              s = this.normal.dot(n);
            if (0 === s)
              return 0 === this.distanceToPoint(t.start)
                ? e.copy(t.start)
                : null;
            const i = -(t.start.dot(this.normal) + this.constant) / s;
            return i < 0 || i > 1
              ? null
              : e.copy(n).multiplyScalar(i).add(t.start);
          }
          intersectsLine(t) {
            const e = this.distanceToPoint(t.start),
              n = this.distanceToPoint(t.end);
            return (e < 0 && n > 0) || (n < 0 && e > 0);
          }
          intersectsBox(t) {
            return t.intersectsPlane(this);
          }
          intersectsSphere(t) {
            return t.intersectsPlane(this);
          }
          coplanarPoint(t) {
            return t.copy(this.normal).multiplyScalar(-this.constant);
          }
          applyMatrix4(t, e) {
            const n = e || Rn.getNormalMatrix(t),
              s = this.coplanarPoint(An).applyMatrix4(t),
              i = this.normal.applyMatrix3(n).normalize();
            return (this.constant = -s.dot(i)), this;
          }
          translate(t) {
            return (this.constant -= t.dot(this.normal)), this;
          }
          equals(t) {
            return t.normal.equals(this.normal) && t.constant === this.constant;
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        Pn.prototype.isPlane = !0;
        const In = new Ot(),
          Dn = new ft();
        class Nn {
          constructor(
            t = new Pn(),
            e = new Pn(),
            n = new Pn(),
            s = new Pn(),
            i = new Pn(),
            r = new Pn()
          ) {
            this.planes = [t, e, n, s, i, r];
          }
          set(t, e, n, s, i, r) {
            const o = this.planes;
            return (
              o[0].copy(t),
              o[1].copy(e),
              o[2].copy(n),
              o[3].copy(s),
              o[4].copy(i),
              o[5].copy(r),
              this
            );
          }
          copy(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
            return this;
          }
          setFromProjectionMatrix(t) {
            const e = this.planes,
              n = t.elements,
              s = n[0],
              i = n[1],
              r = n[2],
              o = n[3],
              a = n[4],
              c = n[5],
              u = n[6],
              d = n[7],
              l = n[8],
              h = n[9],
              f = n[10],
              m = n[11],
              p = n[12],
              g = n[13],
              x = n[14],
              v = n[15];
            return (
              e[0].setComponents(o - s, d - a, m - l, v - p).normalize(),
              e[1].setComponents(o + s, d + a, m + l, v + p).normalize(),
              e[2].setComponents(o + i, d + c, m + h, v + g).normalize(),
              e[3].setComponents(o - i, d - c, m - h, v - g).normalize(),
              e[4].setComponents(o - r, d - u, m - f, v - x).normalize(),
              e[5].setComponents(o + r, d + u, m + f, v + x).normalize(),
              this
            );
          }
          intersectsObject(t) {
            const e = t.geometry;
            return (
              null === e.boundingSphere && e.computeBoundingSphere(),
              In.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
              this.intersectsSphere(In)
            );
          }
          intersectsSprite(t) {
            return (
              In.center.set(0, 0, 0),
              (In.radius = 0.7071067811865476),
              In.applyMatrix4(t.matrixWorld),
              this.intersectsSphere(In)
            );
          }
          intersectsSphere(t) {
            const e = this.planes,
              n = t.center,
              s = -t.radius;
            for (let t = 0; t < 6; t++)
              if (e[t].distanceToPoint(n) < s) return !1;
            return !0;
          }
          intersectsBox(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++) {
              const s = e[n];
              if (
                ((Dn.x = s.normal.x > 0 ? t.max.x : t.min.x),
                (Dn.y = s.normal.y > 0 ? t.max.y : t.min.y),
                (Dn.z = s.normal.z > 0 ? t.max.z : t.min.z),
                s.distanceToPoint(Dn) < 0)
              )
                return !1;
            }
            return !0;
          }
          containsPoint(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++)
              if (e[n].distanceToPoint(t) < 0) return !1;
            return !0;
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        function On() {
          let t = null,
            e = !1,
            n = null,
            s = null;
          function i(e, r) {
            n(e, r), (s = t.requestAnimationFrame(i));
          }
          return {
            start: function () {
              !0 !== e &&
                null !== n &&
                ((s = t.requestAnimationFrame(i)), (e = !0));
            },
            stop: function () {
              t.cancelAnimationFrame(s), (e = !1);
            },
            setAnimationLoop: function (t) {
              n = t;
            },
            setContext: function (e) {
              t = e;
            },
          };
        }
        function kn(t, e) {
          const n = e.isWebGL2,
            s = new WeakMap();
          return {
            get: function (t) {
              return t.isInterleavedBufferAttribute && (t = t.data), s.get(t);
            },
            remove: function (e) {
              e.isInterleavedBufferAttribute && (e = e.data);
              const n = s.get(e);
              n && (t.deleteBuffer(n.buffer), s.delete(e));
            },
            update: function (e, i) {
              if (e.isGLBufferAttribute) {
                const t = s.get(e);
                return void (
                  (!t || t.version < e.version) &&
                  s.set(e, {
                    buffer: e.buffer,
                    type: e.type,
                    bytesPerElement: e.elementSize,
                    version: e.version,
                  })
                );
              }
              e.isInterleavedBufferAttribute && (e = e.data);
              const r = s.get(e);
              void 0 === r
                ? s.set(
                    e,
                    (function (e, s) {
                      const i = e.array,
                        r = e.usage,
                        o = t.createBuffer();
                      t.bindBuffer(s, o),
                        t.bufferData(s, i, r),
                        e.onUploadCallback();
                      let a = 5126;
                      return (
                        i instanceof Float32Array
                          ? (a = 5126)
                          : i instanceof Float64Array
                          ? console.warn(
                              "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
                            )
                          : i instanceof Uint16Array
                          ? e.isFloat16BufferAttribute
                            ? n
                              ? (a = 5131)
                              : console.warn(
                                  "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                                )
                            : (a = 5123)
                          : i instanceof Int16Array
                          ? (a = 5122)
                          : i instanceof Uint32Array
                          ? (a = 5125)
                          : i instanceof Int32Array
                          ? (a = 5124)
                          : i instanceof Int8Array
                          ? (a = 5120)
                          : (i instanceof Uint8Array ||
                              i instanceof Uint8ClampedArray) &&
                            (a = 5121),
                        {
                          buffer: o,
                          type: a,
                          bytesPerElement: i.BYTES_PER_ELEMENT,
                          version: e.version,
                        }
                      );
                    })(e, i)
                  )
                : r.version < e.version &&
                  ((function (e, s, i) {
                    const r = s.array,
                      o = s.updateRange;
                    t.bindBuffer(i, e),
                      -1 === o.count
                        ? t.bufferSubData(i, 0, r)
                        : (n
                            ? t.bufferSubData(
                                i,
                                o.offset * r.BYTES_PER_ELEMENT,
                                r,
                                o.offset,
                                o.count
                              )
                            : t.bufferSubData(
                                i,
                                o.offset * r.BYTES_PER_ELEMENT,
                                r.subarray(o.offset, o.offset + o.count)
                              ),
                          (o.count = -1));
                  })(r.buffer, e, i),
                  (r.version = e.version));
            },
          };
        }
        class Un extends Ze {
          constructor(t = 1, e = 1, n = 1, s = 1) {
            super(),
              (this.type = "PlaneGeometry"),
              (this.parameters = {
                width: t,
                height: e,
                widthSegments: n,
                heightSegments: s,
              });
            const i = t / 2,
              r = e / 2,
              o = Math.floor(n),
              a = Math.floor(s),
              c = o + 1,
              u = a + 1,
              d = t / o,
              l = e / a,
              h = [],
              f = [],
              m = [],
              p = [];
            for (let t = 0; t < u; t++) {
              const e = t * l - r;
              for (let n = 0; n < c; n++) {
                const s = n * d - i;
                f.push(s, -e, 0),
                  m.push(0, 0, 1),
                  p.push(n / o),
                  p.push(1 - t / a);
              }
            }
            for (let t = 0; t < a; t++)
              for (let e = 0; e < o; e++) {
                const n = e + c * t,
                  s = e + c * (t + 1),
                  i = e + 1 + c * (t + 1),
                  r = e + 1 + c * t;
                h.push(n, s, r), h.push(s, i, r);
              }
            this.setIndex(h),
              this.setAttribute("position", new Ge(f, 3)),
              this.setAttribute("normal", new Ge(m, 3)),
              this.setAttribute("uv", new Ge(p, 2));
          }
          static fromJSON(t) {
            return new Un(t.width, t.height, t.widthSegments, t.heightSegments);
          }
        }
        const zn = {
            alphamap_fragment:
              "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
            alphamap_pars_fragment:
              "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            alphatest_fragment:
              "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
            alphatest_pars_fragment:
              "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
            aomap_fragment:
              "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
            aomap_pars_fragment:
              "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            begin_vertex: "vec3 transformed = vec3( position );",
            beginnormal_vertex:
              "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
            bsdfs:
              "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
            bumpmap_pars_fragment:
              "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
            clipping_planes_fragment:
              "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
            clipping_planes_pars_fragment:
              "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
            clipping_planes_pars_vertex:
              "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
            clipping_planes_vertex:
              "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
            color_fragment:
              "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment:
              "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_pars_vertex:
              "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_vertex:
              "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
            common:
              "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
            cube_uv_reflection_fragment:
              "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
            defaultnormal_vertex:
              "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
            displacementmap_pars_vertex:
              "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
            displacementmap_vertex:
              "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
            emissivemap_fragment:
              "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            emissivemap_pars_fragment:
              "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
            encodings_fragment:
              "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            encodings_pars_fragment:
              "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
            envmap_fragment:
              "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
            envmap_common_pars_fragment:
              "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
            envmap_pars_fragment:
              "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
            envmap_pars_vertex:
              "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
            envmap_physical_pars_fragment:
              "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
            envmap_vertex:
              "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
            fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
            fog_pars_vertex:
              "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
            fog_fragment:
              "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
            fog_pars_fragment:
              "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
            gradientmap_pars_fragment:
              "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
            lightmap_fragment:
              "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
            lightmap_pars_fragment:
              "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_vertex:
              "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
            lights_pars_begin:
              "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
            lights_toon_fragment:
              "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
            lights_toon_pars_fragment:
              "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
            lights_phong_fragment:
              "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_phong_pars_fragment:
              "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
            lights_physical_fragment:
              "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
            lights_physical_pars_fragment:
              "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
            lights_fragment_begin:
              "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
            lights_fragment_maps:
              "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
            lights_fragment_end:
              "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
            logdepthbuf_fragment:
              "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment:
              "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
            logdepthbuf_pars_vertex:
              "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
            logdepthbuf_vertex:
              "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
            map_fragment:
              "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
            map_pars_fragment:
              "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
            map_particle_fragment:
              "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
            map_particle_pars_fragment:
              "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            metalnessmap_fragment:
              "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
            metalnessmap_pars_fragment:
              "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphnormal_vertex:
              "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
            morphtarget_pars_vertex:
              "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
            morphtarget_vertex:
              "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
            normal_fragment_begin:
              "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
            normal_fragment_maps:
              "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
            normal_pars_fragment:
              "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
            normal_pars_vertex:
              "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
            normal_vertex:
              "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
            normalmap_pars_fragment:
              "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
            clearcoat_normal_fragment_begin:
              "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
            clearcoat_normal_fragment_maps:
              "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
            clearcoat_pars_fragment:
              "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
            output_fragment:
              "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
            packing:
              "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
            premultiplied_alpha_fragment:
              "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            project_vertex:
              "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
            dithering_fragment:
              "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
            dithering_pars_fragment:
              "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
            roughnessmap_fragment:
              "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
            roughnessmap_pars_fragment:
              "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment:
              "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
            shadowmap_pars_vertex:
              "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
            shadowmap_vertex:
              "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
            shadowmask_pars_fragment:
              "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
            skinbase_vertex:
              "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex:
              "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
            skinning_vertex:
              "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
            skinnormal_vertex:
              "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
            specularmap_fragment:
              "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment:
              "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment:
              "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
            tonemapping_pars_fragment:
              "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
            transmission_fragment:
              "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",
            transmission_pars_fragment:
              "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
            uv_pars_fragment:
              "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
            uv_pars_vertex:
              "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
            uv_vertex:
              "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
            uv2_pars_fragment:
              "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
            uv2_pars_vertex:
              "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
            uv2_vertex:
              "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
            worldpos_vertex:
              "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
            background_vert:
              "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
            background_frag:
              "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            cube_vert:
              "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            cube_frag:
              "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            depth_vert:
              "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
            depth_frag:
              "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
            distanceRGBA_vert:
              "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
            distanceRGBA_frag:
              "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
            equirect_vert:
              "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
            equirect_frag:
              "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            linedashed_vert:
              "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            linedashed_frag:
              "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            meshbasic_vert:
              "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
            meshbasic_frag:
              "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshlambert_vert:
              "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshlambert_frag:
              "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshmatcap_vert:
              "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
            meshmatcap_frag:
              "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshnormal_vert:
              "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
            meshnormal_frag:
              "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
            meshphong_vert:
              "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphong_frag:
              "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphysical_vert:
              "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
            meshphysical_frag:
              "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshtoon_vert:
              "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshtoon_frag:
              "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            points_vert:
              "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
            points_frag:
              "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            shadow_vert:
              "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            shadow_frag:
              "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            sprite_vert:
              "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            sprite_frag:
              "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
          },
          Fn = {
            common: {
              diffuse: { value: new Oe(16777215) },
              opacity: { value: 1 },
              map: { value: null },
              uvTransform: { value: new tt() },
              uv2Transform: { value: new tt() },
              alphaMap: { value: null },
              alphaTest: { value: 0 },
            },
            specularmap: { specularMap: { value: null } },
            envmap: {
              envMap: { value: null },
              flipEnvMap: { value: -1 },
              reflectivity: { value: 1 },
              ior: { value: 1.5 },
              refractionRatio: { value: 0.98 },
              maxMipLevel: { value: 0 },
            },
            aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
            lightmap: {
              lightMap: { value: null },
              lightMapIntensity: { value: 1 },
            },
            emissivemap: { emissiveMap: { value: null } },
            bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
            normalmap: {
              normalMap: { value: null },
              normalScale: { value: new Q(1, 1) },
            },
            displacementmap: {
              displacementMap: { value: null },
              displacementScale: { value: 1 },
              displacementBias: { value: 0 },
            },
            roughnessmap: { roughnessMap: { value: null } },
            metalnessmap: { metalnessMap: { value: null } },
            gradientmap: { gradientMap: { value: null } },
            fog: {
              fogDensity: { value: 25e-5 },
              fogNear: { value: 1 },
              fogFar: { value: 2e3 },
              fogColor: { value: new Oe(16777215) },
            },
            lights: {
              ambientLightColor: { value: [] },
              lightProbe: { value: [] },
              directionalLights: {
                value: [],
                properties: { direction: {}, color: {} },
              },
              directionalLightShadows: {
                value: [],
                properties: {
                  shadowBias: {},
                  shadowNormalBias: {},
                  shadowRadius: {},
                  shadowMapSize: {},
                },
              },
              directionalShadowMap: { value: [] },
              directionalShadowMatrix: { value: [] },
              spotLights: {
                value: [],
                properties: {
                  color: {},
                  position: {},
                  direction: {},
                  distance: {},
                  coneCos: {},
                  penumbraCos: {},
                  decay: {},
                },
              },
              spotLightShadows: {
                value: [],
                properties: {
                  shadowBias: {},
                  shadowNormalBias: {},
                  shadowRadius: {},
                  shadowMapSize: {},
                },
              },
              spotShadowMap: { value: [] },
              spotShadowMatrix: { value: [] },
              pointLights: {
                value: [],
                properties: {
                  color: {},
                  position: {},
                  decay: {},
                  distance: {},
                },
              },
              pointLightShadows: {
                value: [],
                properties: {
                  shadowBias: {},
                  shadowNormalBias: {},
                  shadowRadius: {},
                  shadowMapSize: {},
                  shadowCameraNear: {},
                  shadowCameraFar: {},
                },
              },
              pointShadowMap: { value: [] },
              pointShadowMatrix: { value: [] },
              hemisphereLights: {
                value: [],
                properties: { direction: {}, skyColor: {}, groundColor: {} },
              },
              rectAreaLights: {
                value: [],
                properties: { color: {}, position: {}, width: {}, height: {} },
              },
              ltc_1: { value: null },
              ltc_2: { value: null },
            },
            points: {
              diffuse: { value: new Oe(16777215) },
              opacity: { value: 1 },
              size: { value: 1 },
              scale: { value: 1 },
              map: { value: null },
              alphaMap: { value: null },
              alphaTest: { value: 0 },
              uvTransform: { value: new tt() },
            },
            sprite: {
              diffuse: { value: new Oe(16777215) },
              opacity: { value: 1 },
              center: { value: new Q(0.5, 0.5) },
              rotation: { value: 0 },
              map: { value: null },
              alphaMap: { value: null },
              alphaTest: { value: 0 },
              uvTransform: { value: new tt() },
            },
          },
          Bn = {
            basic: {
              uniforms: yn([
                Fn.common,
                Fn.specularmap,
                Fn.envmap,
                Fn.aomap,
                Fn.lightmap,
                Fn.fog,
              ]),
              vertexShader: zn.meshbasic_vert,
              fragmentShader: zn.meshbasic_frag,
            },
            lambert: {
              uniforms: yn([
                Fn.common,
                Fn.specularmap,
                Fn.envmap,
                Fn.aomap,
                Fn.lightmap,
                Fn.emissivemap,
                Fn.fog,
                Fn.lights,
                { emissive: { value: new Oe(0) } },
              ]),
              vertexShader: zn.meshlambert_vert,
              fragmentShader: zn.meshlambert_frag,
            },
            phong: {
              uniforms: yn([
                Fn.common,
                Fn.specularmap,
                Fn.envmap,
                Fn.aomap,
                Fn.lightmap,
                Fn.emissivemap,
                Fn.bumpmap,
                Fn.normalmap,
                Fn.displacementmap,
                Fn.fog,
                Fn.lights,
                {
                  emissive: { value: new Oe(0) },
                  specular: { value: new Oe(1118481) },
                  shininess: { value: 30 },
                },
              ]),
              vertexShader: zn.meshphong_vert,
              fragmentShader: zn.meshphong_frag,
            },
            standard: {
              uniforms: yn([
                Fn.common,
                Fn.envmap,
                Fn.aomap,
                Fn.lightmap,
                Fn.emissivemap,
                Fn.bumpmap,
                Fn.normalmap,
                Fn.displacementmap,
                Fn.roughnessmap,
                Fn.metalnessmap,
                Fn.fog,
                Fn.lights,
                {
                  emissive: { value: new Oe(0) },
                  roughness: { value: 1 },
                  metalness: { value: 0 },
                  envMapIntensity: { value: 1 },
                },
              ]),
              vertexShader: zn.meshphysical_vert,
              fragmentShader: zn.meshphysical_frag,
            },
            toon: {
              uniforms: yn([
                Fn.common,
                Fn.aomap,
                Fn.lightmap,
                Fn.emissivemap,
                Fn.bumpmap,
                Fn.normalmap,
                Fn.displacementmap,
                Fn.gradientmap,
                Fn.fog,
                Fn.lights,
                { emissive: { value: new Oe(0) } },
              ]),
              vertexShader: zn.meshtoon_vert,
              fragmentShader: zn.meshtoon_frag,
            },
            matcap: {
              uniforms: yn([
                Fn.common,
                Fn.bumpmap,
                Fn.normalmap,
                Fn.displacementmap,
                Fn.fog,
                { matcap: { value: null } },
              ]),
              vertexShader: zn.meshmatcap_vert,
              fragmentShader: zn.meshmatcap_frag,
            },
            points: {
              uniforms: yn([Fn.points, Fn.fog]),
              vertexShader: zn.points_vert,
              fragmentShader: zn.points_frag,
            },
            dashed: {
              uniforms: yn([
                Fn.common,
                Fn.fog,
                {
                  scale: { value: 1 },
                  dashSize: { value: 1 },
                  totalSize: { value: 2 },
                },
              ]),
              vertexShader: zn.linedashed_vert,
              fragmentShader: zn.linedashed_frag,
            },
            depth: {
              uniforms: yn([Fn.common, Fn.displacementmap]),
              vertexShader: zn.depth_vert,
              fragmentShader: zn.depth_frag,
            },
            normal: {
              uniforms: yn([
                Fn.common,
                Fn.bumpmap,
                Fn.normalmap,
                Fn.displacementmap,
                { opacity: { value: 1 } },
              ]),
              vertexShader: zn.meshnormal_vert,
              fragmentShader: zn.meshnormal_frag,
            },
            sprite: {
              uniforms: yn([Fn.sprite, Fn.fog]),
              vertexShader: zn.sprite_vert,
              fragmentShader: zn.sprite_frag,
            },
            background: {
              uniforms: {
                uvTransform: { value: new tt() },
                t2D: { value: null },
              },
              vertexShader: zn.background_vert,
              fragmentShader: zn.background_frag,
            },
            cube: {
              uniforms: yn([Fn.envmap, { opacity: { value: 1 } }]),
              vertexShader: zn.cube_vert,
              fragmentShader: zn.cube_frag,
            },
            equirect: {
              uniforms: { tEquirect: { value: null } },
              vertexShader: zn.equirect_vert,
              fragmentShader: zn.equirect_frag,
            },
            distanceRGBA: {
              uniforms: yn([
                Fn.common,
                Fn.displacementmap,
                {
                  referencePosition: { value: new ft() },
                  nearDistance: { value: 1 },
                  farDistance: { value: 1e3 },
                },
              ]),
              vertexShader: zn.distanceRGBA_vert,
              fragmentShader: zn.distanceRGBA_frag,
            },
            shadow: {
              uniforms: yn([
                Fn.lights,
                Fn.fog,
                { color: { value: new Oe(0) }, opacity: { value: 1 } },
              ]),
              vertexShader: zn.shadow_vert,
              fragmentShader: zn.shadow_frag,
            },
          };
        function Hn(t, e, n, s, i) {
          const r = new Oe(0);
          let a,
            c,
            u = 0,
            d = null,
            l = 0,
            h = null;
          function f(t, e) {
            n.buffers.color.setClear(t.r, t.g, t.b, e, i);
          }
          return {
            getClearColor: function () {
              return r;
            },
            setClearColor: function (t, e = 1) {
              r.set(t), (u = e), f(r, u);
            },
            getClearAlpha: function () {
              return u;
            },
            setClearAlpha: function (t) {
              (u = t), f(r, u);
            },
            render: function (n, i) {
              let m = !1,
                p = !0 === i.isScene ? i.background : null;
              p && p.isTexture && (p = e.get(p));
              const g = t.xr,
                x = g.getSession && g.getSession();
              x && "additive" === x.environmentBlendMode && (p = null),
                null === p ? f(r, u) : p && p.isColor && (f(p, 1), (m = !0)),
                (t.autoClear || m) &&
                  t.clear(
                    t.autoClearColor,
                    t.autoClearDepth,
                    t.autoClearStencil
                  ),
                p && (p.isCubeTexture || p.mapping === o)
                  ? (void 0 === c &&
                      ((c = new pn(
                        new xn(1, 1, 1),
                        new _n({
                          name: "BackgroundCubeMaterial",
                          uniforms: vn(Bn.cube.uniforms),
                          vertexShader: Bn.cube.vertexShader,
                          fragmentShader: Bn.cube.fragmentShader,
                          side: 1,
                          depthTest: !1,
                          depthWrite: !1,
                          fog: !1,
                        })
                      )),
                      c.geometry.deleteAttribute("normal"),
                      c.geometry.deleteAttribute("uv"),
                      (c.onBeforeRender = function (t, e, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld);
                      }),
                      Object.defineProperty(c.material, "envMap", {
                        get: function () {
                          return this.uniforms.envMap.value;
                        },
                      }),
                      s.update(c)),
                    (c.material.uniforms.envMap.value = p),
                    (c.material.uniforms.flipEnvMap.value =
                      p.isCubeTexture && !1 === p.isRenderTargetTexture
                        ? -1
                        : 1),
                    (d === p && l === p.version && h === t.toneMapping) ||
                      ((c.material.needsUpdate = !0),
                      (d = p),
                      (l = p.version),
                      (h = t.toneMapping)),
                    n.unshift(c, c.geometry, c.material, 0, 0, null))
                  : p &&
                    p.isTexture &&
                    (void 0 === a &&
                      ((a = new pn(
                        new Un(2, 2),
                        new _n({
                          name: "BackgroundMaterial",
                          uniforms: vn(Bn.background.uniforms),
                          vertexShader: Bn.background.vertexShader,
                          fragmentShader: Bn.background.fragmentShader,
                          side: 0,
                          depthTest: !1,
                          depthWrite: !1,
                          fog: !1,
                        })
                      )),
                      a.geometry.deleteAttribute("normal"),
                      Object.defineProperty(a.material, "map", {
                        get: function () {
                          return this.uniforms.t2D.value;
                        },
                      }),
                      s.update(a)),
                    (a.material.uniforms.t2D.value = p),
                    !0 === p.matrixAutoUpdate && p.updateMatrix(),
                    a.material.uniforms.uvTransform.value.copy(p.matrix),
                    (d === p && l === p.version && h === t.toneMapping) ||
                      ((a.material.needsUpdate = !0),
                      (d = p),
                      (l = p.version),
                      (h = t.toneMapping)),
                    n.unshift(a, a.geometry, a.material, 0, 0, null));
            },
          };
        }
        function Gn(t, e, n, s) {
          const i = t.getParameter(34921),
            r = s.isWebGL2 ? null : e.get("OES_vertex_array_object"),
            o = s.isWebGL2 || null !== r,
            a = {},
            c = h(null);
          let u = c;
          function d(e) {
            return s.isWebGL2 ? t.bindVertexArray(e) : r.bindVertexArrayOES(e);
          }
          function l(e) {
            return s.isWebGL2
              ? t.deleteVertexArray(e)
              : r.deleteVertexArrayOES(e);
          }
          function h(t) {
            const e = [],
              n = [],
              s = [];
            for (let t = 0; t < i; t++) (e[t] = 0), (n[t] = 0), (s[t] = 0);
            return {
              geometry: null,
              program: null,
              wireframe: !1,
              newAttributes: e,
              enabledAttributes: n,
              attributeDivisors: s,
              object: t,
              attributes: {},
              index: null,
            };
          }
          function f() {
            const t = u.newAttributes;
            for (let e = 0, n = t.length; e < n; e++) t[e] = 0;
          }
          function m(t) {
            p(t, 0);
          }
          function p(n, i) {
            const r = u.newAttributes,
              o = u.enabledAttributes,
              a = u.attributeDivisors;
            (r[n] = 1),
              0 === o[n] && (t.enableVertexAttribArray(n), (o[n] = 1)),
              a[n] !== i &&
                ((s.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[
                  s.isWebGL2
                    ? "vertexAttribDivisor"
                    : "vertexAttribDivisorANGLE"
                ](n, i),
                (a[n] = i));
          }
          function g() {
            const e = u.newAttributes,
              n = u.enabledAttributes;
            for (let s = 0, i = n.length; s < i; s++)
              n[s] !== e[s] && (t.disableVertexAttribArray(s), (n[s] = 0));
          }
          function x(e, n, i, r, o, a) {
            !0 !== s.isWebGL2 || (5124 !== i && 5125 !== i)
              ? t.vertexAttribPointer(e, n, i, r, o, a)
              : t.vertexAttribIPointer(e, n, i, o, a);
          }
          function v() {
            y(), u !== c && ((u = c), d(u.object));
          }
          function y() {
            (c.geometry = null), (c.program = null), (c.wireframe = !1);
          }
          return {
            setup: function (i, c, l, v, y) {
              let w = !1;
              if (o) {
                const e = (function (e, n, i) {
                  const o = !0 === i.wireframe;
                  let c = a[e.id];
                  void 0 === c && ((c = {}), (a[e.id] = c));
                  let u = c[n.id];
                  void 0 === u && ((u = {}), (c[n.id] = u));
                  let d = u[o];
                  return (
                    void 0 === d &&
                      ((d = h(
                        s.isWebGL2
                          ? t.createVertexArray()
                          : r.createVertexArrayOES()
                      )),
                      (u[o] = d)),
                    d
                  );
                })(v, l, c);
                u !== e && ((u = e), d(u.object)),
                  (w = (function (t, e) {
                    const n = u.attributes,
                      s = t.attributes;
                    let i = 0;
                    for (const t in s) {
                      const e = n[t],
                        r = s[t];
                      if (void 0 === e) return !0;
                      if (e.attribute !== r) return !0;
                      if (e.data !== r.data) return !0;
                      i++;
                    }
                    return u.attributesNum !== i || u.index !== e;
                  })(v, y)),
                  w &&
                    (function (t, e) {
                      const n = {},
                        s = t.attributes;
                      let i = 0;
                      for (const t in s) {
                        const e = s[t],
                          r = {};
                        (r.attribute = e),
                          e.data && (r.data = e.data),
                          (n[t] = r),
                          i++;
                      }
                      (u.attributes = n), (u.attributesNum = i), (u.index = e);
                    })(v, y);
              } else {
                const t = !0 === c.wireframe;
                (u.geometry === v.id &&
                  u.program === l.id &&
                  u.wireframe === t) ||
                  ((u.geometry = v.id),
                  (u.program = l.id),
                  (u.wireframe = t),
                  (w = !0));
              }
              !0 === i.isInstancedMesh && (w = !0),
                null !== y && n.update(y, 34963),
                w &&
                  ((function (i, r, o, a) {
                    if (
                      !1 === s.isWebGL2 &&
                      (i.isInstancedMesh || a.isInstancedBufferGeometry) &&
                      null === e.get("ANGLE_instanced_arrays")
                    )
                      return;
                    f();
                    const c = a.attributes,
                      u = o.getAttributes(),
                      d = r.defaultAttributeValues;
                    for (const e in u) {
                      const s = u[e];
                      if (s.location >= 0) {
                        let r = c[e];
                        if (
                          (void 0 === r &&
                            ("instanceMatrix" === e &&
                              i.instanceMatrix &&
                              (r = i.instanceMatrix),
                            "instanceColor" === e &&
                              i.instanceColor &&
                              (r = i.instanceColor)),
                          void 0 !== r)
                        ) {
                          const e = r.normalized,
                            o = r.itemSize,
                            c = n.get(r);
                          if (void 0 === c) continue;
                          const u = c.buffer,
                            d = c.type,
                            l = c.bytesPerElement;
                          if (r.isInterleavedBufferAttribute) {
                            const n = r.data,
                              c = n.stride,
                              h = r.offset;
                            if (n && n.isInstancedInterleavedBuffer) {
                              for (let t = 0; t < s.locationSize; t++)
                                p(s.location + t, n.meshPerAttribute);
                              !0 !== i.isInstancedMesh &&
                                void 0 === a._maxInstanceCount &&
                                (a._maxInstanceCount =
                                  n.meshPerAttribute * n.count);
                            } else
                              for (let t = 0; t < s.locationSize; t++)
                                m(s.location + t);
                            t.bindBuffer(34962, u);
                            for (let t = 0; t < s.locationSize; t++)
                              x(
                                s.location + t,
                                o / s.locationSize,
                                d,
                                e,
                                c * l,
                                (h + (o / s.locationSize) * t) * l
                              );
                          } else {
                            if (r.isInstancedBufferAttribute) {
                              for (let t = 0; t < s.locationSize; t++)
                                p(s.location + t, r.meshPerAttribute);
                              !0 !== i.isInstancedMesh &&
                                void 0 === a._maxInstanceCount &&
                                (a._maxInstanceCount =
                                  r.meshPerAttribute * r.count);
                            } else
                              for (let t = 0; t < s.locationSize; t++)
                                m(s.location + t);
                            t.bindBuffer(34962, u);
                            for (let t = 0; t < s.locationSize; t++)
                              x(
                                s.location + t,
                                o / s.locationSize,
                                d,
                                e,
                                o * l,
                                (o / s.locationSize) * t * l
                              );
                          }
                        } else if (void 0 !== d) {
                          const n = d[e];
                          if (void 0 !== n)
                            switch (n.length) {
                              case 2:
                                t.vertexAttrib2fv(s.location, n);
                                break;
                              case 3:
                                t.vertexAttrib3fv(s.location, n);
                                break;
                              case 4:
                                t.vertexAttrib4fv(s.location, n);
                                break;
                              default:
                                t.vertexAttrib1fv(s.location, n);
                            }
                        }
                      }
                    }
                    g();
                  })(i, c, l, v),
                  null !== y && t.bindBuffer(34963, n.get(y).buffer));
            },
            reset: v,
            resetDefaultState: y,
            dispose: function () {
              v();
              for (const t in a) {
                const e = a[t];
                for (const t in e) {
                  const n = e[t];
                  for (const t in n) l(n[t].object), delete n[t];
                  delete e[t];
                }
                delete a[t];
              }
            },
            releaseStatesOfGeometry: function (t) {
              if (void 0 === a[t.id]) return;
              const e = a[t.id];
              for (const t in e) {
                const n = e[t];
                for (const t in n) l(n[t].object), delete n[t];
                delete e[t];
              }
              delete a[t.id];
            },
            releaseStatesOfProgram: function (t) {
              for (const e in a) {
                const n = a[e];
                if (void 0 === n[t.id]) continue;
                const s = n[t.id];
                for (const t in s) l(s[t].object), delete s[t];
                delete n[t.id];
              }
            },
            initAttributes: f,
            enableAttribute: m,
            disableUnusedAttributes: g,
          };
        }
        function Vn(t, e, n, s) {
          const i = s.isWebGL2;
          let r;
          (this.setMode = function (t) {
            r = t;
          }),
            (this.render = function (e, s) {
              t.drawArrays(r, e, s), n.update(s, r, 1);
            }),
            (this.renderInstances = function (s, o, a) {
              if (0 === a) return;
              let c, u;
              if (i) (c = t), (u = "drawArraysInstanced");
              else if (
                ((c = e.get("ANGLE_instanced_arrays")),
                (u = "drawArraysInstancedANGLE"),
                null === c)
              )
                return void console.error(
                  "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                );
              c[u](r, s, o, a), n.update(o, r, a);
            });
        }
        function Wn(t, e, n) {
          let s;
          function i(e) {
            if ("highp" === e) {
              if (
                t.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
                t.getShaderPrecisionFormat(35632, 36338).precision > 0
              )
                return "highp";
              e = "mediump";
            }
            return "mediump" === e &&
              t.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
              t.getShaderPrecisionFormat(35632, 36337).precision > 0
              ? "mediump"
              : "lowp";
          }
          const r =
            ("undefined" != typeof WebGL2RenderingContext &&
              t instanceof WebGL2RenderingContext) ||
            ("undefined" != typeof WebGL2ComputeRenderingContext &&
              t instanceof WebGL2ComputeRenderingContext);
          let o = void 0 !== n.precision ? n.precision : "highp";
          const a = i(o);
          a !== o &&
            (console.warn(
              "THREE.WebGLRenderer:",
              o,
              "not supported, using",
              a,
              "instead."
            ),
            (o = a));
          const c = r || e.has("WEBGL_draw_buffers"),
            u = !0 === n.logarithmicDepthBuffer,
            d = t.getParameter(34930),
            l = t.getParameter(35660),
            h = t.getParameter(3379),
            f = t.getParameter(34076),
            m = t.getParameter(34921),
            p = t.getParameter(36347),
            g = t.getParameter(36348),
            x = t.getParameter(36349),
            v = l > 0,
            y = r || e.has("OES_texture_float");
          return {
            isWebGL2: r,
            drawBuffers: c,
            getMaxAnisotropy: function () {
              if (void 0 !== s) return s;
              if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                const n = e.get("EXT_texture_filter_anisotropic");
                s = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
              } else s = 0;
              return s;
            },
            getMaxPrecision: i,
            precision: o,
            logarithmicDepthBuffer: u,
            maxTextures: d,
            maxVertexTextures: l,
            maxTextureSize: h,
            maxCubemapSize: f,
            maxAttributes: m,
            maxVertexUniforms: p,
            maxVaryings: g,
            maxFragmentUniforms: x,
            vertexTextures: v,
            floatFragmentTextures: y,
            floatVertexTextures: v && y,
            maxSamples: r ? t.getParameter(36183) : 0,
          };
        }
        function jn(t) {
          const e = this;
          let n = null,
            s = 0,
            i = !1,
            r = !1;
          const o = new Pn(),
            a = new tt(),
            c = { value: null, needsUpdate: !1 };
          function u() {
            c.value !== n && ((c.value = n), (c.needsUpdate = s > 0)),
              (e.numPlanes = s),
              (e.numIntersection = 0);
          }
          function d(t, n, s, i) {
            const r = null !== t ? t.length : 0;
            let u = null;
            if (0 !== r) {
              if (((u = c.value), !0 !== i || null === u)) {
                const e = s + 4 * r,
                  i = n.matrixWorldInverse;
                a.getNormalMatrix(i),
                  (null === u || u.length < e) && (u = new Float32Array(e));
                for (let e = 0, n = s; e !== r; ++e, n += 4)
                  o.copy(t[e]).applyMatrix4(i, a),
                    o.normal.toArray(u, n),
                    (u[n + 3] = o.constant);
              }
              (c.value = u), (c.needsUpdate = !0);
            }
            return (e.numPlanes = r), (e.numIntersection = 0), u;
          }
          (this.uniform = c),
            (this.numPlanes = 0),
            (this.numIntersection = 0),
            (this.init = function (t, e, r) {
              const o = 0 !== t.length || e || 0 !== s || i;
              return (i = e), (n = d(t, r, 0)), (s = t.length), o;
            }),
            (this.beginShadows = function () {
              (r = !0), d(null);
            }),
            (this.endShadows = function () {
              (r = !1), u();
            }),
            (this.setState = function (e, o, a) {
              const l = e.clippingPlanes,
                h = e.clipIntersection,
                f = e.clipShadows,
                m = t.get(e);
              if (!i || null === l || 0 === l.length || (r && !f))
                r ? d(null) : u();
              else {
                const t = r ? 0 : s,
                  e = 4 * t;
                let i = m.clippingState || null;
                (c.value = i), (i = d(l, o, e, a));
                for (let t = 0; t !== e; ++t) i[t] = n[t];
                (m.clippingState = i),
                  (this.numIntersection = h ? this.numPlanes : 0),
                  (this.numPlanes += t);
              }
            });
        }
        function Xn(t) {
          let e = new WeakMap();
          function n(t, e) {
            return (
              303 === e ? (t.mapping = i) : 304 === e && (t.mapping = r), t
            );
          }
          function s(t) {
            const n = t.target;
            n.removeEventListener("dispose", s);
            const i = e.get(n);
            void 0 !== i && (e.delete(n), i.dispose());
          }
          return {
            get: function (i) {
              if (i && i.isTexture && !1 === i.isRenderTargetTexture) {
                const r = i.mapping;
                if (303 === r || 304 === r) {
                  if (e.has(i)) return n(e.get(i).texture, i.mapping);
                  {
                    const r = i.image;
                    if (r && r.height > 0) {
                      const o = t.getRenderTarget(),
                        a = new Cn(r.height / 2);
                      return (
                        a.fromEquirectangularTexture(t, i),
                        e.set(i, a),
                        t.setRenderTarget(o),
                        i.addEventListener("dispose", s),
                        n(a.texture, i.mapping)
                      );
                    }
                    return null;
                  }
                }
              }
              return i;
            },
            dispose: function () {
              e = new WeakMap();
            },
          };
        }
        Bn.physical = {
          uniforms: yn([
            Bn.standard.uniforms,
            {
              clearcoat: { value: 0 },
              clearcoatMap: { value: null },
              clearcoatRoughness: { value: 0 },
              clearcoatRoughnessMap: { value: null },
              clearcoatNormalScale: { value: new Q(1, 1) },
              clearcoatNormalMap: { value: null },
              sheen: { value: 0 },
              sheenColor: { value: new Oe(0) },
              sheenColorMap: { value: null },
              sheenRoughness: { value: 0 },
              sheenRoughnessMap: { value: null },
              transmission: { value: 0 },
              transmissionMap: { value: null },
              transmissionSamplerSize: { value: new Q() },
              transmissionSamplerMap: { value: null },
              thickness: { value: 0 },
              thicknessMap: { value: null },
              attenuationDistance: { value: 0 },
              attenuationColor: { value: new Oe(0) },
              specularIntensity: { value: 0 },
              specularIntensityMap: { value: null },
              specularColor: { value: new Oe(1, 1, 1) },
              specularColorMap: { value: null },
            },
          ]),
          vertexShader: zn.meshphysical_vert,
          fragmentShader: zn.meshphysical_frag,
        };
        class qn extends bn {
          constructor(t = -1, e = 1, n = 1, s = -1, i = 0.1, r = 2e3) {
            super(),
              (this.type = "OrthographicCamera"),
              (this.zoom = 1),
              (this.view = null),
              (this.left = t),
              (this.right = e),
              (this.top = n),
              (this.bottom = s),
              (this.near = i),
              (this.far = r),
              this.updateProjectionMatrix();
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              (this.left = t.left),
              (this.right = t.right),
              (this.top = t.top),
              (this.bottom = t.bottom),
              (this.near = t.near),
              (this.far = t.far),
              (this.zoom = t.zoom),
              (this.view = null === t.view ? null : Object.assign({}, t.view)),
              this
            );
          }
          setViewOffset(t, e, n, s, i, r) {
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
              (this.view.enabled = !0),
              (this.view.fullWidth = t),
              (this.view.fullHeight = e),
              (this.view.offsetX = n),
              (this.view.offsetY = s),
              (this.view.width = i),
              (this.view.height = r),
              this.updateProjectionMatrix();
          }
          clearViewOffset() {
            null !== this.view && (this.view.enabled = !1),
              this.updateProjectionMatrix();
          }
          updateProjectionMatrix() {
            const t = (this.right - this.left) / (2 * this.zoom),
              e = (this.top - this.bottom) / (2 * this.zoom),
              n = (this.right + this.left) / 2,
              s = (this.top + this.bottom) / 2;
            let i = n - t,
              r = n + t,
              o = s + e,
              a = s - e;
            if (null !== this.view && this.view.enabled) {
              const t =
                  (this.right - this.left) / this.view.fullWidth / this.zoom,
                e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
              (i += t * this.view.offsetX),
                (r = i + t * this.view.width),
                (o -= e * this.view.offsetY),
                (a = o - e * this.view.height);
            }
            this.projectionMatrix.makeOrthographic(
              i,
              r,
              o,
              a,
              this.near,
              this.far
            ),
              this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              (e.object.zoom = this.zoom),
              (e.object.left = this.left),
              (e.object.right = this.right),
              (e.object.top = this.top),
              (e.object.bottom = this.bottom),
              (e.object.near = this.near),
              (e.object.far = this.far),
              null !== this.view &&
                (e.object.view = Object.assign({}, this.view)),
              e
            );
          }
        }
        qn.prototype.isOrthographicCamera = !0;
        class Yn extends _n {
          constructor(t) {
            super(t), (this.type = "RawShaderMaterial");
          }
        }
        Yn.prototype.isRawShaderMaterial = !0;
        const Jn = Math.pow(2, 8),
          Zn = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
          $n = 5 + Zn.length,
          Kn = { [P]: 0, [I]: 1, [N]: 2, 3004: 3, 3005: 4, 3006: 5, [D]: 6 },
          Qn = new qn(),
          { _lodPlanes: ts, _sizeLods: es, _sigmas: ns } = ds(),
          ss = new Oe();
        let is = null;
        const rs = (1 + Math.sqrt(5)) / 2,
          os = 1 / rs,
          as = [
            new ft(1, 1, 1),
            new ft(-1, 1, 1),
            new ft(1, 1, -1),
            new ft(-1, 1, -1),
            new ft(0, rs, os),
            new ft(0, rs, -os),
            new ft(os, 0, rs),
            new ft(-os, 0, rs),
            new ft(rs, os, 0),
            new ft(-rs, os, 0),
          ];
        class cs {
          constructor(t) {
            (this._renderer = t),
              (this._pingPongRenderTarget = null),
              (this._blurMaterial = (function (t) {
                const e = new Float32Array(20),
                  n = new ft(0, 1, 0);
                return new Yn({
                  name: "SphericalGaussianBlur",
                  defines: { n: 20 },
                  uniforms: {
                    envMap: { value: null },
                    samples: { value: 1 },
                    weights: { value: e },
                    latitudinal: { value: !1 },
                    dTheta: { value: 0 },
                    mipInt: { value: 0 },
                    poleAxis: { value: n },
                    inputEncoding: { value: Kn[3e3] },
                    outputEncoding: { value: Kn[3e3] },
                  },
                  vertexShader:
                    "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                  fragmentShader:
                    "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
                  blending: 0,
                  depthTest: !1,
                  depthWrite: !1,
                });
              })()),
              (this._equirectShader = null),
              (this._cubemapShader = null),
              this._compileMaterial(this._blurMaterial);
          }
          fromScene(t, e = 0, n = 0.1, s = 100) {
            is = this._renderer.getRenderTarget();
            const i = this._allocateTargets();
            return (
              this._sceneToCubeUV(t, n, s, i),
              e > 0 && this._blur(i, 0, 0, e),
              this._applyPMREM(i),
              this._cleanup(i),
              i
            );
          }
          fromEquirectangular(t) {
            return this._fromTexture(t);
          }
          fromCubemap(t) {
            return this._fromTexture(t);
          }
          compileCubemapShader() {
            null === this._cubemapShader &&
              ((this._cubemapShader = ms()),
              this._compileMaterial(this._cubemapShader));
          }
          compileEquirectangularShader() {
            null === this._equirectShader &&
              ((this._equirectShader = fs()),
              this._compileMaterial(this._equirectShader));
          }
          dispose() {
            this._blurMaterial.dispose(),
              null !== this._cubemapShader && this._cubemapShader.dispose(),
              null !== this._equirectShader && this._equirectShader.dispose();
            for (let t = 0; t < ts.length; t++) ts[t].dispose();
          }
          _cleanup(t) {
            this._pingPongRenderTarget.dispose(),
              this._renderer.setRenderTarget(is),
              (t.scissorTest = !1),
              hs(t, 0, 0, t.width, t.height);
          }
          _fromTexture(t) {
            is = this._renderer.getRenderTarget();
            const e = this._allocateTargets(t);
            return (
              this._textureToCubeUV(t, e),
              this._applyPMREM(e),
              this._cleanup(e),
              e
            );
          }
          _allocateTargets(t) {
            const e = {
                magFilter: d,
                minFilter: d,
                generateMipmaps: !1,
                type: p,
                format: 1023,
                encoding: us(t) ? t.encoding : N,
                depthBuffer: !1,
              },
              n = ls(e);
            return (
              (n.depthBuffer = !t), (this._pingPongRenderTarget = ls(e)), n
            );
          }
          _compileMaterial(t) {
            const e = new pn(ts[0], t);
            this._renderer.compile(e, Qn);
          }
          _sceneToCubeUV(t, e, n, s) {
            const i = new Mn(90, 1, e, n),
              r = [1, -1, 1, 1, 1, 1],
              o = [1, 1, 1, -1, -1, -1],
              a = this._renderer,
              c = a.autoClear,
              u = a.outputEncoding,
              d = a.toneMapping;
            a.getClearColor(ss),
              (a.toneMapping = 0),
              (a.outputEncoding = P),
              (a.autoClear = !1);
            const l = new ke({
                name: "PMREM.Background",
                side: 1,
                depthWrite: !1,
                depthTest: !1,
              }),
              h = new pn(new xn(), l);
            let f = !1;
            const m = t.background;
            m
              ? m.isColor && (l.color.copy(m), (t.background = null), (f = !0))
              : (l.color.copy(ss), (f = !0));
            for (let e = 0; e < 6; e++) {
              const n = e % 3;
              0 == n
                ? (i.up.set(0, r[e], 0), i.lookAt(o[e], 0, 0))
                : 1 == n
                ? (i.up.set(0, 0, r[e]), i.lookAt(0, o[e], 0))
                : (i.up.set(0, r[e], 0), i.lookAt(0, 0, o[e])),
                hs(s, n * Jn, e > 2 ? Jn : 0, Jn, Jn),
                a.setRenderTarget(s),
                f && a.render(h, i),
                a.render(t, i);
            }
            h.geometry.dispose(),
              h.material.dispose(),
              (a.toneMapping = d),
              (a.outputEncoding = u),
              (a.autoClear = c),
              (t.background = m);
          }
          _setEncoding(t, e) {
            !0 === this._renderer.capabilities.isWebGL2 &&
            e.format === b &&
            e.type === p &&
            e.encoding === I
              ? (t.value = Kn[3e3])
              : (t.value = Kn[e.encoding]);
          }
          _textureToCubeUV(t, e) {
            const n = this._renderer,
              s = t.mapping === i || t.mapping === r;
            s
              ? null == this._cubemapShader && (this._cubemapShader = ms())
              : null == this._equirectShader && (this._equirectShader = fs());
            const o = s ? this._cubemapShader : this._equirectShader,
              a = new pn(ts[0], o),
              c = o.uniforms;
            (c.envMap.value = t),
              s || c.texelSize.value.set(1 / t.image.width, 1 / t.image.height),
              this._setEncoding(c.inputEncoding, t),
              this._setEncoding(c.outputEncoding, e.texture),
              hs(e, 0, 0, 3 * Jn, 2 * Jn),
              n.setRenderTarget(e),
              n.render(a, Qn);
          }
          _applyPMREM(t) {
            const e = this._renderer,
              n = e.autoClear;
            e.autoClear = !1;
            for (let e = 1; e < $n; e++) {
              const n = Math.sqrt(ns[e] * ns[e] - ns[e - 1] * ns[e - 1]),
                s = as[(e - 1) % as.length];
              this._blur(t, e - 1, e, n, s);
            }
            e.autoClear = n;
          }
          _blur(t, e, n, s, i) {
            const r = this._pingPongRenderTarget;
            this._halfBlur(t, r, e, n, s, "latitudinal", i),
              this._halfBlur(r, t, n, n, s, "longitudinal", i);
          }
          _halfBlur(t, e, n, s, i, r, o) {
            const a = this._renderer,
              c = this._blurMaterial;
            "latitudinal" !== r &&
              "longitudinal" !== r &&
              console.error(
                "blur direction must be either latitudinal or longitudinal!"
              );
            const u = new pn(ts[s], c),
              d = c.uniforms,
              l = es[n] - 1,
              h = isFinite(i) ? Math.PI / (2 * l) : (2 * Math.PI) / 39,
              f = i / h,
              m = isFinite(i) ? 1 + Math.floor(3 * f) : 20;
            m > 20 &&
              console.warn(
                `sigmaRadians, ${i}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`
              );
            const p = [];
            let g = 0;
            for (let t = 0; t < 20; ++t) {
              const e = t / f,
                n = Math.exp((-e * e) / 2);
              p.push(n), 0 == t ? (g += n) : t < m && (g += 2 * n);
            }
            for (let t = 0; t < p.length; t++) p[t] = p[t] / g;
            (d.envMap.value = t.texture),
              (d.samples.value = m),
              (d.weights.value = p),
              (d.latitudinal.value = "latitudinal" === r),
              o && (d.poleAxis.value = o),
              (d.dTheta.value = h),
              (d.mipInt.value = 8 - n),
              this._setEncoding(d.inputEncoding, t.texture),
              this._setEncoding(d.outputEncoding, t.texture);
            const x = es[s];
            hs(
              e,
              3 * Math.max(0, Jn - 2 * x),
              (0 === s ? 0 : 2 * Jn) + 2 * x * (s > 4 ? s - 8 + 4 : 0),
              3 * x,
              2 * x
            ),
              a.setRenderTarget(e),
              a.render(u, Qn);
          }
        }
        function us(t) {
          return (
            void 0 !== t &&
            t.type === p &&
            (t.encoding === P || t.encoding === I || t.encoding === D)
          );
        }
        function ds() {
          const t = [],
            e = [],
            n = [];
          let s = 8;
          for (let i = 0; i < $n; i++) {
            const r = Math.pow(2, s);
            e.push(r);
            let o = 1 / r;
            i > 4 ? (o = Zn[i - 8 + 4 - 1]) : 0 == i && (o = 0), n.push(o);
            const a = 1 / (r - 1),
              c = -a / 2,
              u = 1 + a / 2,
              d = [c, c, u, c, u, u, c, c, u, u, c, u],
              l = 6,
              h = 6,
              f = 3,
              m = 2,
              p = 1,
              g = new Float32Array(f * h * l),
              x = new Float32Array(m * h * l),
              v = new Float32Array(p * h * l);
            for (let t = 0; t < l; t++) {
              const e = ((t % 3) * 2) / 3 - 1,
                n = t > 2 ? 0 : -1,
                s = [
                  e,
                  n,
                  0,
                  e + 2 / 3,
                  n,
                  0,
                  e + 2 / 3,
                  n + 1,
                  0,
                  e,
                  n,
                  0,
                  e + 2 / 3,
                  n + 1,
                  0,
                  e,
                  n + 1,
                  0,
                ];
              g.set(s, f * h * t), x.set(d, m * h * t);
              const i = [t, t, t, t, t, t];
              v.set(i, p * h * t);
            }
            const y = new Ze();
            y.setAttribute("position", new Fe(g, f)),
              y.setAttribute("uv", new Fe(x, m)),
              y.setAttribute("faceIndex", new Fe(v, p)),
              t.push(y),
              s > 4 && s--;
          }
          return { _lodPlanes: t, _sizeLods: e, _sigmas: n };
        }
        function ls(t) {
          const e = new dt(3 * Jn, 3 * Jn, t);
          return (
            (e.texture.mapping = o),
            (e.texture.name = "PMREM.cubeUv"),
            (e.scissorTest = !0),
            e
          );
        }
        function hs(t, e, n, s, i) {
          t.viewport.set(e, n, s, i), t.scissor.set(e, n, s, i);
        }
        function fs() {
          const t = new Q(1, 1);
          return new Yn({
            name: "EquirectangularToCubeUV",
            uniforms: {
              envMap: { value: null },
              texelSize: { value: t },
              inputEncoding: { value: Kn[3e3] },
              outputEncoding: { value: Kn[3e3] },
            },
            vertexShader:
              "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
            fragmentShader:
              "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
            blending: 0,
            depthTest: !1,
            depthWrite: !1,
          });
        }
        function ms() {
          return new Yn({
            name: "CubemapToCubeUV",
            uniforms: {
              envMap: { value: null },
              inputEncoding: { value: Kn[3e3] },
              outputEncoding: { value: Kn[3e3] },
            },
            vertexShader:
              "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
            fragmentShader:
              "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
            blending: 0,
            depthTest: !1,
            depthWrite: !1,
          });
        }
        function ps(t) {
          let e = new WeakMap(),
            n = null;
          function s(t) {
            const n = t.target;
            n.removeEventListener("dispose", s);
            const i = e.get(n);
            void 0 !== i && (e.delete(n), i.dispose());
          }
          return {
            get: function (o) {
              if (o && o.isTexture && !1 === o.isRenderTargetTexture) {
                const a = o.mapping,
                  c = 303 === a || 304 === a,
                  u = a === i || a === r;
                if (c || u) {
                  if (e.has(o)) return e.get(o).texture;
                  {
                    const i = o.image;
                    if (
                      (c && i && i.height > 0) ||
                      (u &&
                        i &&
                        (function (t) {
                          let e = 0;
                          for (let n = 0; n < 6; n++) void 0 !== t[n] && e++;
                          return 6 === e;
                        })(i))
                    ) {
                      const i = t.getRenderTarget();
                      null === n && (n = new cs(t));
                      const r = c ? n.fromEquirectangular(o) : n.fromCubemap(o);
                      return (
                        e.set(o, r),
                        t.setRenderTarget(i),
                        o.addEventListener("dispose", s),
                        r.texture
                      );
                    }
                    return null;
                  }
                }
              }
              return o;
            },
            dispose: function () {
              (e = new WeakMap()), null !== n && (n.dispose(), (n = null));
            },
          };
        }
        function gs(t) {
          const e = {};
          function n(n) {
            if (void 0 !== e[n]) return e[n];
            let s;
            switch (n) {
              case "WEBGL_depth_texture":
                s =
                  t.getExtension("WEBGL_depth_texture") ||
                  t.getExtension("MOZ_WEBGL_depth_texture") ||
                  t.getExtension("WEBKIT_WEBGL_depth_texture");
                break;
              case "EXT_texture_filter_anisotropic":
                s =
                  t.getExtension("EXT_texture_filter_anisotropic") ||
                  t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                  t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                break;
              case "WEBGL_compressed_texture_s3tc":
                s =
                  t.getExtension("WEBGL_compressed_texture_s3tc") ||
                  t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                  t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                break;
              case "WEBGL_compressed_texture_pvrtc":
                s =
                  t.getExtension("WEBGL_compressed_texture_pvrtc") ||
                  t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                break;
              default:
                s = t.getExtension(n);
            }
            return (e[n] = s), s;
          }
          return {
            has: function (t) {
              return null !== n(t);
            },
            init: function (t) {
              t.isWebGL2
                ? n("EXT_color_buffer_float")
                : (n("WEBGL_depth_texture"),
                  n("OES_texture_float"),
                  n("OES_texture_half_float"),
                  n("OES_texture_half_float_linear"),
                  n("OES_standard_derivatives"),
                  n("OES_element_index_uint"),
                  n("OES_vertex_array_object"),
                  n("ANGLE_instanced_arrays")),
                n("OES_texture_float_linear"),
                n("EXT_color_buffer_half_float");
            },
            get: function (t) {
              const e = n(t);
              return (
                null === e &&
                  console.warn(
                    "THREE.WebGLRenderer: " + t + " extension not supported."
                  ),
                e
              );
            },
          };
        }
        function xs(t, e, n, s) {
          const i = {},
            r = new WeakMap();
          function o(t) {
            const a = t.target;
            null !== a.index && e.remove(a.index);
            for (const t in a.attributes) e.remove(a.attributes[t]);
            a.removeEventListener("dispose", o), delete i[a.id];
            const c = r.get(a);
            c && (e.remove(c), r.delete(a)),
              s.releaseStatesOfGeometry(a),
              !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount,
              n.memory.geometries--;
          }
          function a(t) {
            const n = [],
              s = t.index,
              i = t.attributes.position;
            let o = 0;
            if (null !== s) {
              const t = s.array;
              o = s.version;
              for (let e = 0, s = t.length; e < s; e += 3) {
                const s = t[e + 0],
                  i = t[e + 1],
                  r = t[e + 2];
                n.push(s, i, i, r, r, s);
              }
            } else {
              const t = i.array;
              o = i.version;
              for (let e = 0, s = t.length / 3 - 1; e < s; e += 3) {
                const t = e + 0,
                  s = e + 1,
                  i = e + 2;
                n.push(t, s, s, i, i, t);
              }
            }
            const a = new (et(n) > 65535 ? He : Be)(n, 1);
            a.version = o;
            const c = r.get(t);
            c && e.remove(c), r.set(t, a);
          }
          return {
            get: function (t, e) {
              return (
                !0 === i[e.id] ||
                  (e.addEventListener("dispose", o),
                  (i[e.id] = !0),
                  n.memory.geometries++),
                e
              );
            },
            update: function (t) {
              const n = t.attributes;
              for (const t in n) e.update(n[t], 34962);
              const s = t.morphAttributes;
              for (const t in s) {
                const n = s[t];
                for (let t = 0, s = n.length; t < s; t++) e.update(n[t], 34962);
              }
            },
            getWireframeAttribute: function (t) {
              const e = r.get(t);
              if (e) {
                const n = t.index;
                null !== n && e.version < n.version && a(t);
              } else a(t);
              return r.get(t);
            },
          };
        }
        function vs(t, e, n, s) {
          const i = s.isWebGL2;
          let r, o, a;
          (this.setMode = function (t) {
            r = t;
          }),
            (this.setIndex = function (t) {
              (o = t.type), (a = t.bytesPerElement);
            }),
            (this.render = function (e, s) {
              t.drawElements(r, s, o, e * a), n.update(s, r, 1);
            }),
            (this.renderInstances = function (s, c, u) {
              if (0 === u) return;
              let d, l;
              if (i) (d = t), (l = "drawElementsInstanced");
              else if (
                ((d = e.get("ANGLE_instanced_arrays")),
                (l = "drawElementsInstancedANGLE"),
                null === d)
              )
                return void console.error(
                  "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                );
              d[l](r, c, o, s * a, u), n.update(c, r, u);
            });
        }
        function ys(t) {
          const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
          return {
            memory: { geometries: 0, textures: 0 },
            render: e,
            programs: null,
            autoReset: !0,
            reset: function () {
              e.frame++,
                (e.calls = 0),
                (e.triangles = 0),
                (e.points = 0),
                (e.lines = 0);
            },
            update: function (t, n, s) {
              switch ((e.calls++, n)) {
                case 4:
                  e.triangles += s * (t / 3);
                  break;
                case 1:
                  e.lines += s * (t / 2);
                  break;
                case 3:
                  e.lines += s * (t - 1);
                  break;
                case 2:
                  e.lines += s * t;
                  break;
                case 0:
                  e.points += s * t;
                  break;
                default:
                  console.error("THREE.WebGLInfo: Unknown draw mode:", n);
              }
            },
          };
        }
        class ws extends at {
          constructor(t = null, e = 1, n = 1, s = 1) {
            super(null),
              (this.image = { data: t, width: e, height: n, depth: s }),
              (this.magFilter = d),
              (this.minFilter = d),
              (this.wrapR = c),
              (this.generateMipmaps = !1),
              (this.flipY = !1),
              (this.unpackAlignment = 1),
              (this.needsUpdate = !0);
          }
        }
        function _s(t, e) {
          return t[0] - e[0];
        }
        function bs(t, e) {
          return Math.abs(e[1]) - Math.abs(t[1]);
        }
        function Ms(t, e) {
          let n = 1;
          const s = e.isInterleavedBufferAttribute ? e.data.array : e.array;
          s instanceof Int8Array
            ? (n = 127)
            : s instanceof Int16Array
            ? (n = 32767)
            : s instanceof Int32Array
            ? (n = 2147483647)
            : console.error(
                "THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",
                s
              ),
            t.divideScalar(n);
        }
        function Ss(t, e, n) {
          const s = {},
            i = new Float32Array(8),
            r = new WeakMap(),
            o = new ft(),
            a = [];
          for (let t = 0; t < 8; t++) a[t] = [t, 0];
          return {
            update: function (c, u, d, l) {
              const h = c.morphTargetInfluences;
              if (!0 === e.isWebGL2) {
                const s = u.morphAttributes.position.length;
                let i = r.get(u);
                if (void 0 === i || i.count !== s) {
                  void 0 !== i && i.texture.dispose();
                  const t = void 0 !== u.morphAttributes.normal,
                    n = u.morphAttributes.position,
                    a = u.morphAttributes.normal || [],
                    c = !0 === t ? 2 : 1;
                  let d = u.attributes.position.count * c,
                    l = 1;
                  d > e.maxTextureSize &&
                    ((l = Math.ceil(d / e.maxTextureSize)),
                    (d = e.maxTextureSize));
                  const h = new Float32Array(d * l * 4 * s),
                    f = new ws(h, d, l, s);
                  (f.format = b), (f.type = v);
                  const m = 4 * c;
                  for (let e = 0; e < s; e++) {
                    const s = n[e],
                      i = a[e],
                      r = d * l * 4 * e;
                    for (let e = 0; e < s.count; e++) {
                      o.fromBufferAttribute(s, e),
                        !0 === s.normalized && Ms(o, s);
                      const n = e * m;
                      (h[r + n + 0] = o.x),
                        (h[r + n + 1] = o.y),
                        (h[r + n + 2] = o.z),
                        (h[r + n + 3] = 0),
                        !0 === t &&
                          (o.fromBufferAttribute(i, e),
                          !0 === i.normalized && Ms(o, i),
                          (h[r + n + 4] = o.x),
                          (h[r + n + 5] = o.y),
                          (h[r + n + 6] = o.z),
                          (h[r + n + 7] = 0));
                    }
                  }
                  (i = { count: s, texture: f, size: new Q(d, l) }),
                    r.set(u, i);
                }
                let a = 0;
                for (let t = 0; t < h.length; t++) a += h[t];
                const c = u.morphTargetsRelative ? 1 : 1 - a;
                l.getUniforms().setValue(t, "morphTargetBaseInfluence", c),
                  l.getUniforms().setValue(t, "morphTargetInfluences", h),
                  l
                    .getUniforms()
                    .setValue(t, "morphTargetsTexture", i.texture, n),
                  l
                    .getUniforms()
                    .setValue(t, "morphTargetsTextureSize", i.size);
              } else {
                const e = void 0 === h ? 0 : h.length;
                let n = s[u.id];
                if (void 0 === n || n.length !== e) {
                  n = [];
                  for (let t = 0; t < e; t++) n[t] = [t, 0];
                  s[u.id] = n;
                }
                for (let t = 0; t < e; t++) {
                  const e = n[t];
                  (e[0] = t), (e[1] = h[t]);
                }
                n.sort(bs);
                for (let t = 0; t < 8; t++)
                  t < e && n[t][1]
                    ? ((a[t][0] = n[t][0]), (a[t][1] = n[t][1]))
                    : ((a[t][0] = Number.MAX_SAFE_INTEGER), (a[t][1] = 0));
                a.sort(_s);
                const r = u.morphAttributes.position,
                  o = u.morphAttributes.normal;
                let c = 0;
                for (let t = 0; t < 8; t++) {
                  const e = a[t],
                    n = e[0],
                    s = e[1];
                  n !== Number.MAX_SAFE_INTEGER && s
                    ? (r &&
                        u.getAttribute("morphTarget" + t) !== r[n] &&
                        u.setAttribute("morphTarget" + t, r[n]),
                      o &&
                        u.getAttribute("morphNormal" + t) !== o[n] &&
                        u.setAttribute("morphNormal" + t, o[n]),
                      (i[t] = s),
                      (c += s))
                    : (r &&
                        !0 === u.hasAttribute("morphTarget" + t) &&
                        u.deleteAttribute("morphTarget" + t),
                      o &&
                        !0 === u.hasAttribute("morphNormal" + t) &&
                        u.deleteAttribute("morphNormal" + t),
                      (i[t] = 0));
                }
                const d = u.morphTargetsRelative ? 1 : 1 - c;
                l.getUniforms().setValue(t, "morphTargetBaseInfluence", d),
                  l.getUniforms().setValue(t, "morphTargetInfluences", i);
              }
            },
          };
        }
        function Ts(t, e, n, s) {
          let i = new WeakMap();
          function r(t) {
            const e = t.target;
            e.removeEventListener("dispose", r),
              n.remove(e.instanceMatrix),
              null !== e.instanceColor && n.remove(e.instanceColor);
          }
          return {
            update: function (t) {
              const o = s.render.frame,
                a = t.geometry,
                c = e.get(t, a);
              return (
                i.get(c) !== o && (e.update(c), i.set(c, o)),
                t.isInstancedMesh &&
                  (!1 === t.hasEventListener("dispose", r) &&
                    t.addEventListener("dispose", r),
                  n.update(t.instanceMatrix, 34962),
                  null !== t.instanceColor && n.update(t.instanceColor, 34962)),
                c
              );
            },
            dispose: function () {
              i = new WeakMap();
            },
          };
        }
        ws.prototype.isDataTexture2DArray = !0;
        class Es extends at {
          constructor(t = null, e = 1, n = 1, s = 1) {
            super(null),
              (this.image = { data: t, width: e, height: n, depth: s }),
              (this.magFilter = d),
              (this.minFilter = d),
              (this.wrapR = c),
              (this.generateMipmaps = !1),
              (this.flipY = !1),
              (this.unpackAlignment = 1),
              (this.needsUpdate = !0);
          }
        }
        Es.prototype.isDataTexture3D = !0;
        const Cs = new at(),
          As = new ws(),
          Ls = new Es(),
          Rs = new En(),
          Ps = [],
          Is = [],
          Ds = new Float32Array(16),
          Ns = new Float32Array(9),
          Os = new Float32Array(4);
        function ks(t, e, n) {
          const s = t[0];
          if (s <= 0 || s > 0) return t;
          const i = e * n;
          let r = Ps[i];
          if (
            (void 0 === r && ((r = new Float32Array(i)), (Ps[i] = r)), 0 !== e)
          ) {
            s.toArray(r, 0);
            for (let s = 1, i = 0; s !== e; ++s) (i += n), t[s].toArray(r, i);
          }
          return r;
        }
        function Us(t, e) {
          if (t.length !== e.length) return !1;
          for (let n = 0, s = t.length; n < s; n++)
            if (t[n] !== e[n]) return !1;
          return !0;
        }
        function zs(t, e) {
          for (let n = 0, s = e.length; n < s; n++) t[n] = e[n];
        }
        function Fs(t, e) {
          let n = Is[e];
          void 0 === n && ((n = new Int32Array(e)), (Is[e] = n));
          for (let s = 0; s !== e; ++s) n[s] = t.allocateTextureUnit();
          return n;
        }
        function Bs(t, e) {
          const n = this.cache;
          n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
        }
        function Hs(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y) ||
              (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
          else {
            if (Us(n, e)) return;
            t.uniform2fv(this.addr, e), zs(n, e);
          }
        }
        function Gs(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
              (t.uniform3f(this.addr, e.x, e.y, e.z),
              (n[0] = e.x),
              (n[1] = e.y),
              (n[2] = e.z));
          else if (void 0 !== e.r)
            (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
              (t.uniform3f(this.addr, e.r, e.g, e.b),
              (n[0] = e.r),
              (n[1] = e.g),
              (n[2] = e.b));
          else {
            if (Us(n, e)) return;
            t.uniform3fv(this.addr, e), zs(n, e);
          }
        }
        function Vs(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
              (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
              (n[0] = e.x),
              (n[1] = e.y),
              (n[2] = e.z),
              (n[3] = e.w));
          else {
            if (Us(n, e)) return;
            t.uniform4fv(this.addr, e), zs(n, e);
          }
        }
        function Ws(t, e) {
          const n = this.cache,
            s = e.elements;
          if (void 0 === s) {
            if (Us(n, e)) return;
            t.uniformMatrix2fv(this.addr, !1, e), zs(n, e);
          } else {
            if (Us(n, s)) return;
            Os.set(s), t.uniformMatrix2fv(this.addr, !1, Os), zs(n, s);
          }
        }
        function js(t, e) {
          const n = this.cache,
            s = e.elements;
          if (void 0 === s) {
            if (Us(n, e)) return;
            t.uniformMatrix3fv(this.addr, !1, e), zs(n, e);
          } else {
            if (Us(n, s)) return;
            Ns.set(s), t.uniformMatrix3fv(this.addr, !1, Ns), zs(n, s);
          }
        }
        function Xs(t, e) {
          const n = this.cache,
            s = e.elements;
          if (void 0 === s) {
            if (Us(n, e)) return;
            t.uniformMatrix4fv(this.addr, !1, e), zs(n, e);
          } else {
            if (Us(n, s)) return;
            Ds.set(s), t.uniformMatrix4fv(this.addr, !1, Ds), zs(n, s);
          }
        }
        function qs(t, e) {
          const n = this.cache;
          n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
        }
        function Ys(t, e) {
          const n = this.cache;
          Us(n, e) || (t.uniform2iv(this.addr, e), zs(n, e));
        }
        function Js(t, e) {
          const n = this.cache;
          Us(n, e) || (t.uniform3iv(this.addr, e), zs(n, e));
        }
        function Zs(t, e) {
          const n = this.cache;
          Us(n, e) || (t.uniform4iv(this.addr, e), zs(n, e));
        }
        function $s(t, e) {
          const n = this.cache;
          n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
        }
        function Ks(t, e) {
          const n = this.cache;
          Us(n, e) || (t.uniform2uiv(this.addr, e), zs(n, e));
        }
        function Qs(t, e) {
          const n = this.cache;
          Us(n, e) || (t.uniform3uiv(this.addr, e), zs(n, e));
        }
        function ti(t, e) {
          const n = this.cache;
          Us(n, e) || (t.uniform4uiv(this.addr, e), zs(n, e));
        }
        function ei(t, e, n) {
          const s = this.cache,
            i = n.allocateTextureUnit();
          s[0] !== i && (t.uniform1i(this.addr, i), (s[0] = i)),
            n.safeSetTexture2D(e || Cs, i);
        }
        function ni(t, e, n) {
          const s = this.cache,
            i = n.allocateTextureUnit();
          s[0] !== i && (t.uniform1i(this.addr, i), (s[0] = i)),
            n.setTexture3D(e || Ls, i);
        }
        function si(t, e, n) {
          const s = this.cache,
            i = n.allocateTextureUnit();
          s[0] !== i && (t.uniform1i(this.addr, i), (s[0] = i)),
            n.safeSetTextureCube(e || Rs, i);
        }
        function ii(t, e, n) {
          const s = this.cache,
            i = n.allocateTextureUnit();
          s[0] !== i && (t.uniform1i(this.addr, i), (s[0] = i)),
            n.setTexture2DArray(e || As, i);
        }
        function ri(t, e) {
          t.uniform1fv(this.addr, e);
        }
        function oi(t, e) {
          const n = ks(e, this.size, 2);
          t.uniform2fv(this.addr, n);
        }
        function ai(t, e) {
          const n = ks(e, this.size, 3);
          t.uniform3fv(this.addr, n);
        }
        function ci(t, e) {
          const n = ks(e, this.size, 4);
          t.uniform4fv(this.addr, n);
        }
        function ui(t, e) {
          const n = ks(e, this.size, 4);
          t.uniformMatrix2fv(this.addr, !1, n);
        }
        function di(t, e) {
          const n = ks(e, this.size, 9);
          t.uniformMatrix3fv(this.addr, !1, n);
        }
        function li(t, e) {
          const n = ks(e, this.size, 16);
          t.uniformMatrix4fv(this.addr, !1, n);
        }
        function hi(t, e) {
          t.uniform1iv(this.addr, e);
        }
        function fi(t, e) {
          t.uniform2iv(this.addr, e);
        }
        function mi(t, e) {
          t.uniform3iv(this.addr, e);
        }
        function pi(t, e) {
          t.uniform4iv(this.addr, e);
        }
        function gi(t, e) {
          t.uniform1uiv(this.addr, e);
        }
        function xi(t, e) {
          t.uniform2uiv(this.addr, e);
        }
        function vi(t, e) {
          t.uniform3uiv(this.addr, e);
        }
        function yi(t, e) {
          t.uniform4uiv(this.addr, e);
        }
        function wi(t, e, n) {
          const s = e.length,
            i = Fs(n, s);
          t.uniform1iv(this.addr, i);
          for (let t = 0; t !== s; ++t) n.safeSetTexture2D(e[t] || Cs, i[t]);
        }
        function _i(t, e, n) {
          const s = e.length,
            i = Fs(n, s);
          t.uniform1iv(this.addr, i);
          for (let t = 0; t !== s; ++t) n.safeSetTextureCube(e[t] || Rs, i[t]);
        }
        function bi(t, e, n) {
          (this.id = t),
            (this.addr = n),
            (this.cache = []),
            (this.setValue = (function (t) {
              switch (t) {
                case 5126:
                  return Bs;
                case 35664:
                  return Hs;
                case 35665:
                  return Gs;
                case 35666:
                  return Vs;
                case 35674:
                  return Ws;
                case 35675:
                  return js;
                case 35676:
                  return Xs;
                case 5124:
                case 35670:
                  return qs;
                case 35667:
                case 35671:
                  return Ys;
                case 35668:
                case 35672:
                  return Js;
                case 35669:
                case 35673:
                  return Zs;
                case 5125:
                  return $s;
                case 36294:
                  return Ks;
                case 36295:
                  return Qs;
                case 36296:
                  return ti;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                  return ei;
                case 35679:
                case 36299:
                case 36307:
                  return ni;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                  return si;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                  return ii;
              }
            })(e.type));
        }
        function Mi(t, e, n) {
          (this.id = t),
            (this.addr = n),
            (this.cache = []),
            (this.size = e.size),
            (this.setValue = (function (t) {
              switch (t) {
                case 5126:
                  return ri;
                case 35664:
                  return oi;
                case 35665:
                  return ai;
                case 35666:
                  return ci;
                case 35674:
                  return ui;
                case 35675:
                  return di;
                case 35676:
                  return li;
                case 5124:
                case 35670:
                  return hi;
                case 35667:
                case 35671:
                  return fi;
                case 35668:
                case 35672:
                  return mi;
                case 35669:
                case 35673:
                  return pi;
                case 5125:
                  return gi;
                case 36294:
                  return xi;
                case 36295:
                  return vi;
                case 36296:
                  return yi;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                  return wi;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                  return _i;
              }
            })(e.type));
        }
        function Si(t) {
          (this.id = t), (this.seq = []), (this.map = {});
        }
        (Mi.prototype.updateCache = function (t) {
          const e = this.cache;
          t instanceof Float32Array &&
            e.length !== t.length &&
            (this.cache = new Float32Array(t.length)),
            zs(e, t);
        }),
          (Si.prototype.setValue = function (t, e, n) {
            const s = this.seq;
            for (let i = 0, r = s.length; i !== r; ++i) {
              const r = s[i];
              r.setValue(t, e[r.id], n);
            }
          });
        const Ti = /(\w+)(\])?(\[|\.)?/g;
        function Ei(t, e) {
          t.seq.push(e), (t.map[e.id] = e);
        }
        function Ci(t, e, n) {
          const s = t.name,
            i = s.length;
          for (Ti.lastIndex = 0; ; ) {
            const r = Ti.exec(s),
              o = Ti.lastIndex;
            let a = r[1];
            const c = "]" === r[2],
              u = r[3];
            if ((c && (a |= 0), void 0 === u || ("[" === u && o + 2 === i))) {
              Ei(n, void 0 === u ? new bi(a, t, e) : new Mi(a, t, e));
              break;
            }
            {
              let t = n.map[a];
              void 0 === t && ((t = new Si(a)), Ei(n, t)), (n = t);
            }
          }
        }
        function Ai(t, e) {
          (this.seq = []), (this.map = {});
          const n = t.getProgramParameter(e, 35718);
          for (let s = 0; s < n; ++s) {
            const n = t.getActiveUniform(e, s);
            Ci(n, t.getUniformLocation(e, n.name), this);
          }
        }
        function Li(t, e, n) {
          const s = t.createShader(e);
          return t.shaderSource(s, n), t.compileShader(s), s;
        }
        (Ai.prototype.setValue = function (t, e, n, s) {
          const i = this.map[e];
          void 0 !== i && i.setValue(t, n, s);
        }),
          (Ai.prototype.setOptional = function (t, e, n) {
            const s = e[n];
            void 0 !== s && this.setValue(t, n, s);
          }),
          (Ai.upload = function (t, e, n, s) {
            for (let i = 0, r = e.length; i !== r; ++i) {
              const r = e[i],
                o = n[r.id];
              !1 !== o.needsUpdate && r.setValue(t, o.value, s);
            }
          }),
          (Ai.seqWithValue = function (t, e) {
            const n = [];
            for (let s = 0, i = t.length; s !== i; ++s) {
              const i = t[s];
              i.id in e && n.push(i);
            }
            return n;
          });
        let Ri = 0;
        function Pi(t) {
          switch (t) {
            case P:
              return ["Linear", "( value )"];
            case I:
              return ["sRGB", "( value )"];
            case N:
              return ["RGBE", "( value )"];
            case 3004:
              return ["RGBM", "( value, 7.0 )"];
            case 3005:
              return ["RGBM", "( value, 16.0 )"];
            case 3006:
              return ["RGBD", "( value, 256.0 )"];
            case D:
              return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
            case 3003:
              return ["LogLuv", "( value )"];
            default:
              return (
                console.warn("THREE.WebGLProgram: Unsupported encoding:", t),
                ["Linear", "( value )"]
              );
          }
        }
        function Ii(t, e, n) {
          const s = t.getShaderParameter(e, 35713),
            i = t.getShaderInfoLog(e).trim();
          return s && "" === i
            ? ""
            : n.toUpperCase() +
                "\n\n" +
                i +
                "\n\n" +
                (function (t) {
                  const e = t.split("\n");
                  for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
                  return e.join("\n");
                })(t.getShaderSource(e));
        }
        function Di(t, e) {
          const n = Pi(e);
          return (
            "vec4 " +
            t +
            "( vec4 value ) { return " +
            n[0] +
            "ToLinear" +
            n[1] +
            "; }"
          );
        }
        function Ni(t, e) {
          const n = Pi(e);
          return (
            "vec4 " +
            t +
            "( vec4 value ) { return LinearTo" +
            n[0] +
            n[1] +
            "; }"
          );
        }
        function Oi(t, e) {
          let n;
          switch (e) {
            case 1:
              n = "Linear";
              break;
            case 2:
              n = "Reinhard";
              break;
            case 3:
              n = "OptimizedCineon";
              break;
            case 4:
              n = "ACESFilmic";
              break;
            case 5:
              n = "Custom";
              break;
            default:
              console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
                (n = "Linear");
          }
          return (
            "vec3 " +
            t +
            "( vec3 color ) { return " +
            n +
            "ToneMapping( color ); }"
          );
        }
        function ki(t) {
          return "" !== t;
        }
        function Ui(t, e) {
          return t
            .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
            .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
            .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
            .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
            .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
            .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
            .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
            .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
        }
        function zi(t, e) {
          return t
            .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
            .replace(
              /UNION_CLIPPING_PLANES/g,
              e.numClippingPlanes - e.numClipIntersection
            );
        }
        const Fi = /^[ \t]*#include +<([\w\d./]+)>/gm;
        function Bi(t) {
          return t.replace(Fi, Hi);
        }
        function Hi(t, e) {
          const n = zn[e];
          if (void 0 === n)
            throw new Error("Can not resolve #include <" + e + ">");
          return Bi(n);
        }
        const Gi =
            /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
          Vi =
            /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
        function Wi(t) {
          return t.replace(Vi, Xi).replace(Gi, ji);
        }
        function ji(t, e, n, s) {
          return (
            console.warn(
              "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
            ),
            Xi(0, e, n, s)
          );
        }
        function Xi(t, e, n, s) {
          let i = "";
          for (let t = parseInt(e); t < parseInt(n); t++)
            i += s
              .replace(/\[\s*i\s*\]/g, "[ " + t + " ]")
              .replace(/UNROLLED_LOOP_INDEX/g, t);
          return i;
        }
        function qi(t) {
          let e =
            "precision " +
            t.precision +
            " float;\nprecision " +
            t.precision +
            " int;";
          return (
            "highp" === t.precision
              ? (e += "\n#define HIGH_PRECISION")
              : "mediump" === t.precision
              ? (e += "\n#define MEDIUM_PRECISION")
              : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
            e
          );
        }
        function Yi(t, e, n, s) {
          const a = t.getContext(),
            c = n.defines;
          let u = n.vertexShader,
            d = n.fragmentShader;
          const l = (function (t) {
              let e = "SHADOWMAP_TYPE_BASIC";
              return (
                1 === t.shadowMapType
                  ? (e = "SHADOWMAP_TYPE_PCF")
                  : 2 === t.shadowMapType
                  ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
                  : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"),
                e
              );
            })(n),
            h = (function (t) {
              let e = "ENVMAP_TYPE_CUBE";
              if (t.envMap)
                switch (t.envMapMode) {
                  case i:
                  case r:
                    e = "ENVMAP_TYPE_CUBE";
                    break;
                  case o:
                  case 307:
                    e = "ENVMAP_TYPE_CUBE_UV";
                }
              return e;
            })(n),
            f = (function (t) {
              let e = "ENVMAP_MODE_REFLECTION";
              if (t.envMap)
                switch (t.envMapMode) {
                  case r:
                  case 307:
                    e = "ENVMAP_MODE_REFRACTION";
                }
              return e;
            })(n),
            m = (function (t) {
              let e = "ENVMAP_BLENDING_NONE";
              if (t.envMap)
                switch (t.combine) {
                  case 0:
                    e = "ENVMAP_BLENDING_MULTIPLY";
                    break;
                  case 1:
                    e = "ENVMAP_BLENDING_MIX";
                    break;
                  case 2:
                    e = "ENVMAP_BLENDING_ADD";
                }
              return e;
            })(n),
            p = t.gammaFactor > 0 ? t.gammaFactor : 1,
            g = n.isWebGL2
              ? ""
              : (function (t) {
                  return [
                    t.extensionDerivatives ||
                    t.envMapCubeUV ||
                    t.bumpMap ||
                    t.tangentSpaceNormalMap ||
                    t.clearcoatNormalMap ||
                    t.flatShading ||
                    "physical" === t.shaderID
                      ? "#extension GL_OES_standard_derivatives : enable"
                      : "",
                    (t.extensionFragDepth || t.logarithmicDepthBuffer) &&
                    t.rendererExtensionFragDepth
                      ? "#extension GL_EXT_frag_depth : enable"
                      : "",
                    t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
                      ? "#extension GL_EXT_draw_buffers : require"
                      : "",
                    (t.extensionShaderTextureLOD ||
                      t.envMap ||
                      t.transmission) &&
                    t.rendererExtensionShaderTextureLod
                      ? "#extension GL_EXT_shader_texture_lod : enable"
                      : "",
                  ]
                    .filter(ki)
                    .join("\n");
                })(n),
            x = (function (t) {
              const e = [];
              for (const n in t) {
                const s = t[n];
                !1 !== s && e.push("#define " + n + " " + s);
              }
              return e.join("\n");
            })(c),
            v = a.createProgram();
          let y,
            w,
            b = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
          n.isRawShaderMaterial
            ? ((y = [x].filter(ki).join("\n")),
              y.length > 0 && (y += "\n"),
              (w = [g, x].filter(ki).join("\n")),
              w.length > 0 && (w += "\n"))
            : ((y = [
                qi(n),
                "#define SHADER_NAME " + n.shaderName,
                x,
                n.instancing ? "#define USE_INSTANCING" : "",
                n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
                n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
                "#define GAMMA_FACTOR " + p,
                "#define MAX_BONES " + n.maxBones,
                n.useFog && n.fog ? "#define USE_FOG" : "",
                n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
                n.map ? "#define USE_MAP" : "",
                n.envMap ? "#define USE_ENVMAP" : "",
                n.envMap ? "#define " + f : "",
                n.lightMap ? "#define USE_LIGHTMAP" : "",
                n.aoMap ? "#define USE_AOMAP" : "",
                n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                n.bumpMap ? "#define USE_BUMPMAP" : "",
                n.normalMap ? "#define USE_NORMALMAP" : "",
                n.normalMap && n.objectSpaceNormalMap
                  ? "#define OBJECTSPACE_NORMALMAP"
                  : "",
                n.normalMap && n.tangentSpaceNormalMap
                  ? "#define TANGENTSPACE_NORMALMAP"
                  : "",
                n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
                n.clearcoatRoughnessMap
                  ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                  : "",
                n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
                n.displacementMap && n.supportsVertexTextures
                  ? "#define USE_DISPLACEMENTMAP"
                  : "",
                n.specularMap ? "#define USE_SPECULARMAP" : "",
                n.specularIntensityMap
                  ? "#define USE_SPECULARINTENSITYMAP"
                  : "",
                n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
                n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                n.metalnessMap ? "#define USE_METALNESSMAP" : "",
                n.alphaMap ? "#define USE_ALPHAMAP" : "",
                n.transmission ? "#define USE_TRANSMISSION" : "",
                n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
                n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
                n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
                n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
                n.vertexTangents ? "#define USE_TANGENT" : "",
                n.vertexColors ? "#define USE_COLOR" : "",
                n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
                n.vertexUvs ? "#define USE_UV" : "",
                n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
                n.flatShading ? "#define FLAT_SHADED" : "",
                n.skinning ? "#define USE_SKINNING" : "",
                n.useVertexTexture ? "#define BONE_TEXTURE" : "",
                n.morphTargets ? "#define USE_MORPHTARGETS" : "",
                n.morphNormals && !1 === n.flatShading
                  ? "#define USE_MORPHNORMALS"
                  : "",
                n.morphTargets && n.isWebGL2
                  ? "#define MORPHTARGETS_TEXTURE"
                  : "",
                n.morphTargets && n.isWebGL2
                  ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount
                  : "",
                n.doubleSided ? "#define DOUBLE_SIDED" : "",
                n.flipSided ? "#define FLIP_SIDED" : "",
                n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                n.shadowMapEnabled ? "#define " + l : "",
                n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
                n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
                n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                  ? "#define USE_LOGDEPTHBUF_EXT"
                  : "",
                "uniform mat4 modelMatrix;",
                "uniform mat4 modelViewMatrix;",
                "uniform mat4 projectionMatrix;",
                "uniform mat4 viewMatrix;",
                "uniform mat3 normalMatrix;",
                "uniform vec3 cameraPosition;",
                "uniform bool isOrthographic;",
                "#ifdef USE_INSTANCING",
                "\tattribute mat4 instanceMatrix;",
                "#endif",
                "#ifdef USE_INSTANCING_COLOR",
                "\tattribute vec3 instanceColor;",
                "#endif",
                "attribute vec3 position;",
                "attribute vec3 normal;",
                "attribute vec2 uv;",
                "#ifdef USE_TANGENT",
                "\tattribute vec4 tangent;",
                "#endif",
                "#if defined( USE_COLOR_ALPHA )",
                "\tattribute vec4 color;",
                "#elif defined( USE_COLOR )",
                "\tattribute vec3 color;",
                "#endif",
                "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
                "\tattribute vec3 morphTarget0;",
                "\tattribute vec3 morphTarget1;",
                "\tattribute vec3 morphTarget2;",
                "\tattribute vec3 morphTarget3;",
                "\t#ifdef USE_MORPHNORMALS",
                "\t\tattribute vec3 morphNormal0;",
                "\t\tattribute vec3 morphNormal1;",
                "\t\tattribute vec3 morphNormal2;",
                "\t\tattribute vec3 morphNormal3;",
                "\t#else",
                "\t\tattribute vec3 morphTarget4;",
                "\t\tattribute vec3 morphTarget5;",
                "\t\tattribute vec3 morphTarget6;",
                "\t\tattribute vec3 morphTarget7;",
                "\t#endif",
                "#endif",
                "#ifdef USE_SKINNING",
                "\tattribute vec4 skinIndex;",
                "\tattribute vec4 skinWeight;",
                "#endif",
                "\n",
              ]
                .filter(ki)
                .join("\n")),
              (w = [
                g,
                qi(n),
                "#define SHADER_NAME " + n.shaderName,
                x,
                "#define GAMMA_FACTOR " + p,
                n.useFog && n.fog ? "#define USE_FOG" : "",
                n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
                n.map ? "#define USE_MAP" : "",
                n.matcap ? "#define USE_MATCAP" : "",
                n.envMap ? "#define USE_ENVMAP" : "",
                n.envMap ? "#define " + h : "",
                n.envMap ? "#define " + f : "",
                n.envMap ? "#define " + m : "",
                n.lightMap ? "#define USE_LIGHTMAP" : "",
                n.aoMap ? "#define USE_AOMAP" : "",
                n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                n.bumpMap ? "#define USE_BUMPMAP" : "",
                n.normalMap ? "#define USE_NORMALMAP" : "",
                n.normalMap && n.objectSpaceNormalMap
                  ? "#define OBJECTSPACE_NORMALMAP"
                  : "",
                n.normalMap && n.tangentSpaceNormalMap
                  ? "#define TANGENTSPACE_NORMALMAP"
                  : "",
                n.clearcoat ? "#define USE_CLEARCOAT" : "",
                n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
                n.clearcoatRoughnessMap
                  ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                  : "",
                n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
                n.specularMap ? "#define USE_SPECULARMAP" : "",
                n.specularIntensityMap
                  ? "#define USE_SPECULARINTENSITYMAP"
                  : "",
                n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
                n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                n.metalnessMap ? "#define USE_METALNESSMAP" : "",
                n.alphaMap ? "#define USE_ALPHAMAP" : "",
                n.alphaTest ? "#define USE_ALPHATEST" : "",
                n.sheen ? "#define USE_SHEEN" : "",
                n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
                n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
                n.transmission ? "#define USE_TRANSMISSION" : "",
                n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
                n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
                n.vertexTangents ? "#define USE_TANGENT" : "",
                n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
                n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
                n.vertexUvs ? "#define USE_UV" : "",
                n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
                n.gradientMap ? "#define USE_GRADIENTMAP" : "",
                n.flatShading ? "#define FLAT_SHADED" : "",
                n.doubleSided ? "#define DOUBLE_SIDED" : "",
                n.flipSided ? "#define FLIP_SIDED" : "",
                n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                n.shadowMapEnabled ? "#define " + l : "",
                n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
                n.physicallyCorrectLights
                  ? "#define PHYSICALLY_CORRECT_LIGHTS"
                  : "",
                n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
                n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                  ? "#define USE_LOGDEPTHBUF_EXT"
                  : "",
                (n.extensionShaderTextureLOD || n.envMap) &&
                n.rendererExtensionShaderTextureLod
                  ? "#define TEXTURE_LOD_EXT"
                  : "",
                "uniform mat4 viewMatrix;",
                "uniform vec3 cameraPosition;",
                "uniform bool isOrthographic;",
                0 !== n.toneMapping ? "#define TONE_MAPPING" : "",
                0 !== n.toneMapping ? zn.tonemapping_pars_fragment : "",
                0 !== n.toneMapping ? Oi("toneMapping", n.toneMapping) : "",
                n.dithering ? "#define DITHERING" : "",
                n.format === _ ? "#define OPAQUE" : "",
                zn.encodings_pars_fragment,
                n.map ? Di("mapTexelToLinear", n.mapEncoding) : "",
                n.matcap ? Di("matcapTexelToLinear", n.matcapEncoding) : "",
                n.envMap ? Di("envMapTexelToLinear", n.envMapEncoding) : "",
                n.emissiveMap
                  ? Di("emissiveMapTexelToLinear", n.emissiveMapEncoding)
                  : "",
                n.specularColorMap
                  ? Di(
                      "specularColorMapTexelToLinear",
                      n.specularColorMapEncoding
                    )
                  : "",
                n.sheenColorMap
                  ? Di("sheenColorMapTexelToLinear", n.sheenColorMapEncoding)
                  : "",
                n.lightMap
                  ? Di("lightMapTexelToLinear", n.lightMapEncoding)
                  : "",
                Ni("linearToOutputTexel", n.outputEncoding),
                n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
                "\n",
              ]
                .filter(ki)
                .join("\n"))),
            (u = Bi(u)),
            (u = Ui(u, n)),
            (u = zi(u, n)),
            (d = Bi(d)),
            (d = Ui(d, n)),
            (d = zi(d, n)),
            (u = Wi(u)),
            (d = Wi(d)),
            n.isWebGL2 &&
              !0 !== n.isRawShaderMaterial &&
              ((b = "#version 300 es\n"),
              (y =
                [
                  "precision mediump sampler2DArray;",
                  "#define attribute in",
                  "#define varying out",
                  "#define texture2D texture",
                ].join("\n") +
                "\n" +
                y),
              (w =
                [
                  "#define varying in",
                  n.glslVersion === z ? "" : "out highp vec4 pc_fragColor;",
                  n.glslVersion === z
                    ? ""
                    : "#define gl_FragColor pc_fragColor",
                  "#define gl_FragDepthEXT gl_FragDepth",
                  "#define texture2D texture",
                  "#define textureCube texture",
                  "#define texture2DProj textureProj",
                  "#define texture2DLodEXT textureLod",
                  "#define texture2DProjLodEXT textureProjLod",
                  "#define textureCubeLodEXT textureLod",
                  "#define texture2DGradEXT textureGrad",
                  "#define texture2DProjGradEXT textureProjGrad",
                  "#define textureCubeGradEXT textureGrad",
                ].join("\n") +
                "\n" +
                w));
          const M = b + w + d,
            S = Li(a, 35633, b + y + u),
            T = Li(a, 35632, M);
          if (
            (a.attachShader(v, S),
            a.attachShader(v, T),
            void 0 !== n.index0AttributeName
              ? a.bindAttribLocation(v, 0, n.index0AttributeName)
              : !0 === n.morphTargets && a.bindAttribLocation(v, 0, "position"),
            a.linkProgram(v),
            t.debug.checkShaderErrors)
          ) {
            const t = a.getProgramInfoLog(v).trim(),
              e = a.getShaderInfoLog(S).trim(),
              n = a.getShaderInfoLog(T).trim();
            let s = !0,
              i = !0;
            if (!1 === a.getProgramParameter(v, 35714)) {
              s = !1;
              const e = Ii(a, S, "vertex"),
                n = Ii(a, T, "fragment");
              console.error(
                "THREE.WebGLProgram: Shader Error " +
                  a.getError() +
                  " - VALIDATE_STATUS " +
                  a.getProgramParameter(v, 35715) +
                  "\n\nProgram Info Log: " +
                  t +
                  "\n" +
                  e +
                  "\n" +
                  n
              );
            } else
              "" !== t
                ? console.warn("THREE.WebGLProgram: Program Info Log:", t)
                : ("" !== e && "" !== n) || (i = !1);
            i &&
              (this.diagnostics = {
                runnable: s,
                programLog: t,
                vertexShader: { log: e, prefix: y },
                fragmentShader: { log: n, prefix: w },
              });
          }
          let E, C;
          return (
            a.deleteShader(S),
            a.deleteShader(T),
            (this.getUniforms = function () {
              return void 0 === E && (E = new Ai(a, v)), E;
            }),
            (this.getAttributes = function () {
              return (
                void 0 === C &&
                  (C = (function (t, e) {
                    const n = {},
                      s = t.getProgramParameter(e, 35721);
                    for (let i = 0; i < s; i++) {
                      const s = t.getActiveAttrib(e, i),
                        r = s.name;
                      let o = 1;
                      35674 === s.type && (o = 2),
                        35675 === s.type && (o = 3),
                        35676 === s.type && (o = 4),
                        (n[r] = {
                          type: s.type,
                          location: t.getAttribLocation(e, r),
                          locationSize: o,
                        });
                    }
                    return n;
                  })(a, v)),
                C
              );
            }),
            (this.destroy = function () {
              s.releaseStatesOfProgram(this),
                a.deleteProgram(v),
                (this.program = void 0);
            }),
            (this.name = n.shaderName),
            (this.id = Ri++),
            (this.cacheKey = e),
            (this.usedTimes = 1),
            (this.program = v),
            (this.vertexShader = S),
            (this.fragmentShader = T),
            this
          );
        }
        function Ji(t, e, n, s, i, r, a) {
          const c = [],
            u = i.isWebGL2,
            d = i.logarithmicDepthBuffer,
            l = i.floatVertexTextures,
            h = i.maxVertexUniforms,
            f = i.vertexTextures;
          let m = i.precision;
          const g = {
              MeshDepthMaterial: "depth",
              MeshDistanceMaterial: "distanceRGBA",
              MeshNormalMaterial: "normal",
              MeshBasicMaterial: "basic",
              MeshLambertMaterial: "lambert",
              MeshPhongMaterial: "phong",
              MeshToonMaterial: "toon",
              MeshStandardMaterial: "physical",
              MeshPhysicalMaterial: "physical",
              MeshMatcapMaterial: "matcap",
              LineBasicMaterial: "basic",
              LineDashedMaterial: "dashed",
              PointsMaterial: "points",
              ShadowMaterial: "shadow",
              SpriteMaterial: "sprite",
            },
            x = [
              "precision",
              "isWebGL2",
              "supportsVertexTextures",
              "outputEncoding",
              "instancing",
              "instancingColor",
              "map",
              "mapEncoding",
              "matcap",
              "matcapEncoding",
              "envMap",
              "envMapMode",
              "envMapEncoding",
              "envMapCubeUV",
              "lightMap",
              "lightMapEncoding",
              "aoMap",
              "emissiveMap",
              "emissiveMapEncoding",
              "bumpMap",
              "normalMap",
              "objectSpaceNormalMap",
              "tangentSpaceNormalMap",
              "clearcoat",
              "clearcoatMap",
              "clearcoatRoughnessMap",
              "clearcoatNormalMap",
              "displacementMap",
              "specularMap",
              ,
              "roughnessMap",
              "metalnessMap",
              "gradientMap",
              "alphaMap",
              "alphaTest",
              "combine",
              "vertexColors",
              "vertexAlphas",
              "vertexTangents",
              "vertexUvs",
              "uvsVertexOnly",
              "fog",
              "useFog",
              "fogExp2",
              "flatShading",
              "sizeAttenuation",
              "logarithmicDepthBuffer",
              "skinning",
              "maxBones",
              "useVertexTexture",
              "morphTargets",
              "morphNormals",
              "morphTargetsCount",
              "premultipliedAlpha",
              "numDirLights",
              "numPointLights",
              "numSpotLights",
              "numHemiLights",
              "numRectAreaLights",
              "numDirLightShadows",
              "numPointLightShadows",
              "numSpotLightShadows",
              "shadowMapEnabled",
              "shadowMapType",
              "toneMapping",
              "physicallyCorrectLights",
              "doubleSided",
              "flipSided",
              "numClippingPlanes",
              "numClipIntersection",
              "depthPacking",
              "dithering",
              "format",
              "specularIntensityMap",
              "specularColorMap",
              "specularColorMapEncoding",
              "transmission",
              "transmissionMap",
              "thicknessMap",
              "sheen",
              "sheenColorMap",
              "sheenColorMapEncoding",
              "sheenRoughnessMap",
            ];
          function v(t) {
            let e;
            return (
              t && t.isTexture
                ? (e = t.encoding)
                : t && t.isWebGLRenderTarget
                ? (console.warn(
                    "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
                  ),
                  (e = t.texture.encoding))
                : (e = P),
              u &&
                t &&
                t.isTexture &&
                t.format === b &&
                t.type === p &&
                t.encoding === I &&
                (e = P),
              e
            );
          }
          return {
            getParameters: function (r, c, p, x, y) {
              const w = x.fog,
                _ = r.isMeshStandardMaterial ? x.environment : null,
                b = (r.isMeshStandardMaterial ? n : e).get(r.envMap || _),
                M = g[r.type],
                S = y.isSkinnedMesh
                  ? (function (t) {
                      const e = t.skeleton.bones;
                      if (l) return 1024;
                      {
                        const t = h,
                          n = Math.floor((t - 20) / 4),
                          s = Math.min(n, e.length);
                        return s < e.length
                          ? (console.warn(
                              "THREE.WebGLRenderer: Skeleton has " +
                                e.length +
                                " bones. This GPU supports " +
                                s +
                                "."
                            ),
                            0)
                          : s;
                      }
                    })(y)
                  : 0;
              let T, E;
              if (
                (null !== r.precision &&
                  ((m = i.getMaxPrecision(r.precision)),
                  m !== r.precision &&
                    console.warn(
                      "THREE.WebGLProgram.getParameters:",
                      r.precision,
                      "not supported, using",
                      m,
                      "instead."
                    )),
                M)
              ) {
                const t = Bn[M];
                (T = t.vertexShader), (E = t.fragmentShader);
              } else (T = r.vertexShader), (E = r.fragmentShader);
              const C = t.getRenderTarget(),
                A = r.alphaTest > 0,
                L = r.clearcoat > 0;
              return {
                isWebGL2: u,
                shaderID: M,
                shaderName: r.type,
                vertexShader: T,
                fragmentShader: E,
                defines: r.defines,
                isRawShaderMaterial: !0 === r.isRawShaderMaterial,
                glslVersion: r.glslVersion,
                precision: m,
                instancing: !0 === y.isInstancedMesh,
                instancingColor:
                  !0 === y.isInstancedMesh && null !== y.instanceColor,
                supportsVertexTextures: f,
                outputEncoding: null !== C ? v(C.texture) : t.outputEncoding,
                map: !!r.map,
                mapEncoding: v(r.map),
                matcap: !!r.matcap,
                matcapEncoding: v(r.matcap),
                envMap: !!b,
                envMapMode: b && b.mapping,
                envMapEncoding: v(b),
                envMapCubeUV: !!b && (b.mapping === o || 307 === b.mapping),
                lightMap: !!r.lightMap,
                lightMapEncoding: v(r.lightMap),
                aoMap: !!r.aoMap,
                emissiveMap: !!r.emissiveMap,
                emissiveMapEncoding: v(r.emissiveMap),
                bumpMap: !!r.bumpMap,
                normalMap: !!r.normalMap,
                objectSpaceNormalMap: 1 === r.normalMapType,
                tangentSpaceNormalMap: 0 === r.normalMapType,
                clearcoat: L,
                clearcoatMap: L && !!r.clearcoatMap,
                clearcoatRoughnessMap: L && !!r.clearcoatRoughnessMap,
                clearcoatNormalMap: L && !!r.clearcoatNormalMap,
                displacementMap: !!r.displacementMap,
                roughnessMap: !!r.roughnessMap,
                metalnessMap: !!r.metalnessMap,
                specularMap: !!r.specularMap,
                specularIntensityMap: !!r.specularIntensityMap,
                specularColorMap: !!r.specularColorMap,
                specularColorMapEncoding: v(r.specularColorMap),
                alphaMap: !!r.alphaMap,
                alphaTest: A,
                gradientMap: !!r.gradientMap,
                sheen: r.sheen > 0,
                sheenColorMap: !!r.sheenColorMap,
                sheenColorMapEncoding: v(r.sheenColorMap),
                sheenRoughnessMap: !!r.sheenRoughnessMap,
                transmission: r.transmission > 0,
                transmissionMap: !!r.transmissionMap,
                thicknessMap: !!r.thicknessMap,
                combine: r.combine,
                vertexTangents:
                  !!r.normalMap &&
                  !!y.geometry &&
                  !!y.geometry.attributes.tangent,
                vertexColors: r.vertexColors,
                vertexAlphas:
                  !0 === r.vertexColors &&
                  !!y.geometry &&
                  !!y.geometry.attributes.color &&
                  4 === y.geometry.attributes.color.itemSize,
                vertexUvs:
                  !!r.map ||
                  !!r.bumpMap ||
                  !!r.normalMap ||
                  !!r.specularMap ||
                  !!r.alphaMap ||
                  !!r.emissiveMap ||
                  !!r.roughnessMap ||
                  !!r.metalnessMap ||
                  !!r.clearcoatMap ||
                  !!r.clearcoatRoughnessMap ||
                  !!r.clearcoatNormalMap ||
                  !!r.displacementMap ||
                  !!r.transmissionMap ||
                  !!r.thicknessMap ||
                  !!r.specularIntensityMap ||
                  !!r.specularColorMap ||
                  !!r.sheenColorMap ||
                  r.sheenRoughnessMap,
                uvsVertexOnly: !(
                  r.map ||
                  r.bumpMap ||
                  r.normalMap ||
                  r.specularMap ||
                  r.alphaMap ||
                  r.emissiveMap ||
                  r.roughnessMap ||
                  r.metalnessMap ||
                  r.clearcoatNormalMap ||
                  r.transmission > 0 ||
                  r.transmissionMap ||
                  r.thicknessMap ||
                  r.specularIntensityMap ||
                  r.specularColorMap ||
                  !!r.sheen > 0 ||
                  r.sheenColorMap ||
                  r.sheenRoughnessMap ||
                  !r.displacementMap
                ),
                fog: !!w,
                useFog: r.fog,
                fogExp2: w && w.isFogExp2,
                flatShading: !!r.flatShading,
                sizeAttenuation: r.sizeAttenuation,
                logarithmicDepthBuffer: d,
                skinning: !0 === y.isSkinnedMesh && S > 0,
                maxBones: S,
                useVertexTexture: l,
                morphTargets:
                  !!y.geometry && !!y.geometry.morphAttributes.position,
                morphNormals:
                  !!y.geometry && !!y.geometry.morphAttributes.normal,
                morphTargetsCount:
                  y.geometry && y.geometry.morphAttributes.position
                    ? y.geometry.morphAttributes.position.length
                    : 0,
                numDirLights: c.directional.length,
                numPointLights: c.point.length,
                numSpotLights: c.spot.length,
                numRectAreaLights: c.rectArea.length,
                numHemiLights: c.hemi.length,
                numDirLightShadows: c.directionalShadowMap.length,
                numPointLightShadows: c.pointShadowMap.length,
                numSpotLightShadows: c.spotShadowMap.length,
                numClippingPlanes: a.numPlanes,
                numClipIntersection: a.numIntersection,
                format: r.format,
                dithering: r.dithering,
                shadowMapEnabled: t.shadowMap.enabled && p.length > 0,
                shadowMapType: t.shadowMap.type,
                toneMapping: r.toneMapped ? t.toneMapping : 0,
                physicallyCorrectLights: t.physicallyCorrectLights,
                premultipliedAlpha: r.premultipliedAlpha,
                doubleSided: 2 === r.side,
                flipSided: 1 === r.side,
                depthPacking: void 0 !== r.depthPacking && r.depthPacking,
                index0AttributeName: r.index0AttributeName,
                extensionDerivatives: r.extensions && r.extensions.derivatives,
                extensionFragDepth: r.extensions && r.extensions.fragDepth,
                extensionDrawBuffers: r.extensions && r.extensions.drawBuffers,
                extensionShaderTextureLOD:
                  r.extensions && r.extensions.shaderTextureLOD,
                rendererExtensionFragDepth: u || s.has("EXT_frag_depth"),
                rendererExtensionDrawBuffers: u || s.has("WEBGL_draw_buffers"),
                rendererExtensionShaderTextureLod:
                  u || s.has("EXT_shader_texture_lod"),
                customProgramCacheKey: r.customProgramCacheKey(),
              };
            },
            getProgramCacheKey: function (e) {
              const n = [];
              if (
                (e.shaderID
                  ? n.push(e.shaderID)
                  : (n.push(st(e.fragmentShader)), n.push(st(e.vertexShader))),
                void 0 !== e.defines)
              )
                for (const t in e.defines) n.push(t), n.push(e.defines[t]);
              if (!1 === e.isRawShaderMaterial) {
                for (let t = 0; t < x.length; t++) n.push(e[x[t]]);
                n.push(t.outputEncoding), n.push(t.gammaFactor);
              }
              return n.push(e.customProgramCacheKey), n.join();
            },
            getUniforms: function (t) {
              const e = g[t.type];
              let n;
              if (e) {
                const t = Bn[e];
                n = wn.clone(t.uniforms);
              } else n = t.uniforms;
              return n;
            },
            acquireProgram: function (e, n) {
              let s;
              for (let t = 0, e = c.length; t < e; t++) {
                const e = c[t];
                if (e.cacheKey === n) {
                  (s = e), ++s.usedTimes;
                  break;
                }
              }
              return void 0 === s && ((s = new Yi(t, n, e, r)), c.push(s)), s;
            },
            releaseProgram: function (t) {
              if (0 == --t.usedTimes) {
                const e = c.indexOf(t);
                (c[e] = c[c.length - 1]), c.pop(), t.destroy();
              }
            },
            programs: c,
          };
        }
        function Zi() {
          let t = new WeakMap();
          return {
            get: function (e) {
              let n = t.get(e);
              return void 0 === n && ((n = {}), t.set(e, n)), n;
            },
            remove: function (e) {
              t.delete(e);
            },
            update: function (e, n, s) {
              t.get(e)[n] = s;
            },
            dispose: function () {
              t = new WeakMap();
            },
          };
        }
        function $i(t, e) {
          return t.groupOrder !== e.groupOrder
            ? t.groupOrder - e.groupOrder
            : t.renderOrder !== e.renderOrder
            ? t.renderOrder - e.renderOrder
            : t.program !== e.program
            ? t.program.id - e.program.id
            : t.material.id !== e.material.id
            ? t.material.id - e.material.id
            : t.z !== e.z
            ? t.z - e.z
            : t.id - e.id;
        }
        function Ki(t, e) {
          return t.groupOrder !== e.groupOrder
            ? t.groupOrder - e.groupOrder
            : t.renderOrder !== e.renderOrder
            ? t.renderOrder - e.renderOrder
            : t.z !== e.z
            ? e.z - t.z
            : t.id - e.id;
        }
        function Qi(t) {
          const e = [];
          let n = 0;
          const s = [],
            i = [],
            r = [],
            o = { id: -1 };
          function a(s, i, r, a, c, u) {
            let d = e[n];
            const l = t.get(r);
            return (
              void 0 === d
                ? ((d = {
                    id: s.id,
                    object: s,
                    geometry: i,
                    material: r,
                    program: l.program || o,
                    groupOrder: a,
                    renderOrder: s.renderOrder,
                    z: c,
                    group: u,
                  }),
                  (e[n] = d))
                : ((d.id = s.id),
                  (d.object = s),
                  (d.geometry = i),
                  (d.material = r),
                  (d.program = l.program || o),
                  (d.groupOrder = a),
                  (d.renderOrder = s.renderOrder),
                  (d.z = c),
                  (d.group = u)),
              n++,
              d
            );
          }
          return {
            opaque: s,
            transmissive: i,
            transparent: r,
            init: function () {
              (n = 0), (s.length = 0), (i.length = 0), (r.length = 0);
            },
            push: function (t, e, n, o, c, u) {
              const d = a(t, e, n, o, c, u);
              n.transmission > 0
                ? i.push(d)
                : !0 === n.transparent
                ? r.push(d)
                : s.push(d);
            },
            unshift: function (t, e, n, o, c, u) {
              const d = a(t, e, n, o, c, u);
              n.transmission > 0
                ? i.unshift(d)
                : !0 === n.transparent
                ? r.unshift(d)
                : s.unshift(d);
            },
            finish: function () {
              for (let t = n, s = e.length; t < s; t++) {
                const n = e[t];
                if (null === n.id) break;
                (n.id = null),
                  (n.object = null),
                  (n.geometry = null),
                  (n.material = null),
                  (n.program = null),
                  (n.group = null);
              }
            },
            sort: function (t, e) {
              s.length > 1 && s.sort(t || $i),
                i.length > 1 && i.sort(e || Ki),
                r.length > 1 && r.sort(e || Ki);
            },
          };
        }
        function tr(t) {
          let e = new WeakMap();
          return {
            get: function (n, s) {
              let i;
              return (
                !1 === e.has(n)
                  ? ((i = new Qi(t)), e.set(n, [i]))
                  : s >= e.get(n).length
                  ? ((i = new Qi(t)), e.get(n).push(i))
                  : (i = e.get(n)[s]),
                i
              );
            },
            dispose: function () {
              e = new WeakMap();
            },
          };
        }
        function er() {
          const t = {};
          return {
            get: function (e) {
              if (void 0 !== t[e.id]) return t[e.id];
              let n;
              switch (e.type) {
                case "DirectionalLight":
                  n = { direction: new ft(), color: new Oe() };
                  break;
                case "SpotLight":
                  n = {
                    position: new ft(),
                    direction: new ft(),
                    color: new Oe(),
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0,
                  };
                  break;
                case "PointLight":
                  n = {
                    position: new ft(),
                    color: new Oe(),
                    distance: 0,
                    decay: 0,
                  };
                  break;
                case "HemisphereLight":
                  n = {
                    direction: new ft(),
                    skyColor: new Oe(),
                    groundColor: new Oe(),
                  };
                  break;
                case "RectAreaLight":
                  n = {
                    color: new Oe(),
                    position: new ft(),
                    halfWidth: new ft(),
                    halfHeight: new ft(),
                  };
              }
              return (t[e.id] = n), n;
            },
          };
        }
        let nr = 0;
        function sr(t, e) {
          return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
        }
        function ir(t, e) {
          const n = new er(),
            s = (function () {
              const t = {};
              return {
                get: function (e) {
                  if (void 0 !== t[e.id]) return t[e.id];
                  let n;
                  switch (e.type) {
                    case "DirectionalLight":
                    case "SpotLight":
                      n = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Q(),
                      };
                      break;
                    case "PointLight":
                      n = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Q(),
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3,
                      };
                  }
                  return (t[e.id] = n), n;
                },
              };
            })(),
            i = {
              version: 0,
              hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1,
              },
              ambient: [0, 0, 0],
              probe: [],
              directional: [],
              directionalShadow: [],
              directionalShadowMap: [],
              directionalShadowMatrix: [],
              spot: [],
              spotShadow: [],
              spotShadowMap: [],
              spotShadowMatrix: [],
              rectArea: [],
              rectAreaLTC1: null,
              rectAreaLTC2: null,
              point: [],
              pointShadow: [],
              pointShadowMap: [],
              pointShadowMatrix: [],
              hemi: [],
            };
          for (let t = 0; t < 9; t++) i.probe.push(new ft());
          const r = new ft(),
            o = new Wt(),
            a = new Wt();
          return {
            setup: function (r, o) {
              let a = 0,
                c = 0,
                u = 0;
              for (let t = 0; t < 9; t++) i.probe[t].set(0, 0, 0);
              let d = 0,
                l = 0,
                h = 0,
                f = 0,
                m = 0,
                p = 0,
                g = 0,
                x = 0;
              r.sort(sr);
              const v = !0 !== o ? Math.PI : 1;
              for (let t = 0, e = r.length; t < e; t++) {
                const e = r[t],
                  o = e.color,
                  y = e.intensity,
                  w = e.distance,
                  _ = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                if (e.isAmbientLight)
                  (a += o.r * y * v), (c += o.g * y * v), (u += o.b * y * v);
                else if (e.isLightProbe)
                  for (let t = 0; t < 9; t++)
                    i.probe[t].addScaledVector(e.sh.coefficients[t], y);
                else if (e.isDirectionalLight) {
                  const t = n.get(e);
                  if (
                    (t.color.copy(e.color).multiplyScalar(e.intensity * v),
                    e.castShadow)
                  ) {
                    const t = e.shadow,
                      n = s.get(e);
                    (n.shadowBias = t.bias),
                      (n.shadowNormalBias = t.normalBias),
                      (n.shadowRadius = t.radius),
                      (n.shadowMapSize = t.mapSize),
                      (i.directionalShadow[d] = n),
                      (i.directionalShadowMap[d] = _),
                      (i.directionalShadowMatrix[d] = e.shadow.matrix),
                      p++;
                  }
                  (i.directional[d] = t), d++;
                } else if (e.isSpotLight) {
                  const t = n.get(e);
                  if (
                    (t.position.setFromMatrixPosition(e.matrixWorld),
                    t.color.copy(o).multiplyScalar(y * v),
                    (t.distance = w),
                    (t.coneCos = Math.cos(e.angle)),
                    (t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra))),
                    (t.decay = e.decay),
                    e.castShadow)
                  ) {
                    const t = e.shadow,
                      n = s.get(e);
                    (n.shadowBias = t.bias),
                      (n.shadowNormalBias = t.normalBias),
                      (n.shadowRadius = t.radius),
                      (n.shadowMapSize = t.mapSize),
                      (i.spotShadow[h] = n),
                      (i.spotShadowMap[h] = _),
                      (i.spotShadowMatrix[h] = e.shadow.matrix),
                      x++;
                  }
                  (i.spot[h] = t), h++;
                } else if (e.isRectAreaLight) {
                  const t = n.get(e);
                  t.color.copy(o).multiplyScalar(y),
                    t.halfWidth.set(0.5 * e.width, 0, 0),
                    t.halfHeight.set(0, 0.5 * e.height, 0),
                    (i.rectArea[f] = t),
                    f++;
                } else if (e.isPointLight) {
                  const t = n.get(e);
                  if (
                    (t.color.copy(e.color).multiplyScalar(e.intensity * v),
                    (t.distance = e.distance),
                    (t.decay = e.decay),
                    e.castShadow)
                  ) {
                    const t = e.shadow,
                      n = s.get(e);
                    (n.shadowBias = t.bias),
                      (n.shadowNormalBias = t.normalBias),
                      (n.shadowRadius = t.radius),
                      (n.shadowMapSize = t.mapSize),
                      (n.shadowCameraNear = t.camera.near),
                      (n.shadowCameraFar = t.camera.far),
                      (i.pointShadow[l] = n),
                      (i.pointShadowMap[l] = _),
                      (i.pointShadowMatrix[l] = e.shadow.matrix),
                      g++;
                  }
                  (i.point[l] = t), l++;
                } else if (e.isHemisphereLight) {
                  const t = n.get(e);
                  t.skyColor.copy(e.color).multiplyScalar(y * v),
                    t.groundColor.copy(e.groundColor).multiplyScalar(y * v),
                    (i.hemi[m] = t),
                    m++;
                }
              }
              f > 0 &&
                (e.isWebGL2 || !0 === t.has("OES_texture_float_linear")
                  ? ((i.rectAreaLTC1 = Fn.LTC_FLOAT_1),
                    (i.rectAreaLTC2 = Fn.LTC_FLOAT_2))
                  : !0 === t.has("OES_texture_half_float_linear")
                  ? ((i.rectAreaLTC1 = Fn.LTC_HALF_1),
                    (i.rectAreaLTC2 = Fn.LTC_HALF_2))
                  : console.error(
                      "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
                    )),
                (i.ambient[0] = a),
                (i.ambient[1] = c),
                (i.ambient[2] = u);
              const y = i.hash;
              (y.directionalLength === d &&
                y.pointLength === l &&
                y.spotLength === h &&
                y.rectAreaLength === f &&
                y.hemiLength === m &&
                y.numDirectionalShadows === p &&
                y.numPointShadows === g &&
                y.numSpotShadows === x) ||
                ((i.directional.length = d),
                (i.spot.length = h),
                (i.rectArea.length = f),
                (i.point.length = l),
                (i.hemi.length = m),
                (i.directionalShadow.length = p),
                (i.directionalShadowMap.length = p),
                (i.pointShadow.length = g),
                (i.pointShadowMap.length = g),
                (i.spotShadow.length = x),
                (i.spotShadowMap.length = x),
                (i.directionalShadowMatrix.length = p),
                (i.pointShadowMatrix.length = g),
                (i.spotShadowMatrix.length = x),
                (y.directionalLength = d),
                (y.pointLength = l),
                (y.spotLength = h),
                (y.rectAreaLength = f),
                (y.hemiLength = m),
                (y.numDirectionalShadows = p),
                (y.numPointShadows = g),
                (y.numSpotShadows = x),
                (i.version = nr++));
            },
            setupView: function (t, e) {
              let n = 0,
                s = 0,
                c = 0,
                u = 0,
                d = 0;
              const l = e.matrixWorldInverse;
              for (let e = 0, h = t.length; e < h; e++) {
                const h = t[e];
                if (h.isDirectionalLight) {
                  const t = i.directional[n];
                  t.direction.setFromMatrixPosition(h.matrixWorld),
                    r.setFromMatrixPosition(h.target.matrixWorld),
                    t.direction.sub(r),
                    t.direction.transformDirection(l),
                    n++;
                } else if (h.isSpotLight) {
                  const t = i.spot[c];
                  t.position.setFromMatrixPosition(h.matrixWorld),
                    t.position.applyMatrix4(l),
                    t.direction.setFromMatrixPosition(h.matrixWorld),
                    r.setFromMatrixPosition(h.target.matrixWorld),
                    t.direction.sub(r),
                    t.direction.transformDirection(l),
                    c++;
                } else if (h.isRectAreaLight) {
                  const t = i.rectArea[u];
                  t.position.setFromMatrixPosition(h.matrixWorld),
                    t.position.applyMatrix4(l),
                    a.identity(),
                    o.copy(h.matrixWorld),
                    o.premultiply(l),
                    a.extractRotation(o),
                    t.halfWidth.set(0.5 * h.width, 0, 0),
                    t.halfHeight.set(0, 0.5 * h.height, 0),
                    t.halfWidth.applyMatrix4(a),
                    t.halfHeight.applyMatrix4(a),
                    u++;
                } else if (h.isPointLight) {
                  const t = i.point[s];
                  t.position.setFromMatrixPosition(h.matrixWorld),
                    t.position.applyMatrix4(l),
                    s++;
                } else if (h.isHemisphereLight) {
                  const t = i.hemi[d];
                  t.direction.setFromMatrixPosition(h.matrixWorld),
                    t.direction.transformDirection(l),
                    t.direction.normalize(),
                    d++;
                }
              }
            },
            state: i,
          };
        }
        function rr(t, e) {
          const n = new ir(t, e),
            s = [],
            i = [];
          return {
            init: function () {
              (s.length = 0), (i.length = 0);
            },
            state: { lightsArray: s, shadowsArray: i, lights: n },
            setupLights: function (t) {
              n.setup(s, t);
            },
            setupLightsView: function (t) {
              n.setupView(s, t);
            },
            pushLight: function (t) {
              s.push(t);
            },
            pushShadow: function (t) {
              i.push(t);
            },
          };
        }
        function or(t, e) {
          let n = new WeakMap();
          return {
            get: function (s, i = 0) {
              let r;
              return (
                !1 === n.has(s)
                  ? ((r = new rr(t, e)), n.set(s, [r]))
                  : i >= n.get(s).length
                  ? ((r = new rr(t, e)), n.get(s).push(r))
                  : (r = n.get(s)[i]),
                r
              );
            },
            dispose: function () {
              n = new WeakMap();
            },
          };
        }
        class ar extends Ae {
          constructor(t) {
            super(),
              (this.type = "MeshDepthMaterial"),
              (this.depthPacking = 3200),
              (this.map = null),
              (this.alphaMap = null),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.fog = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.depthPacking = t.depthPacking),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              this
            );
          }
        }
        ar.prototype.isMeshDepthMaterial = !0;
        class cr extends Ae {
          constructor(t) {
            super(),
              (this.type = "MeshDistanceMaterial"),
              (this.referencePosition = new ft()),
              (this.nearDistance = 1),
              (this.farDistance = 1e3),
              (this.map = null),
              (this.alphaMap = null),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.fog = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.referencePosition.copy(t.referencePosition),
              (this.nearDistance = t.nearDistance),
              (this.farDistance = t.farDistance),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              this
            );
          }
        }
        function ur(t, e, n) {
          let s = new Nn();
          const i = new Q(),
            r = new Q(),
            o = new ut(),
            a = new ar({ depthPacking: 3201 }),
            c = new cr(),
            u = {},
            l = n.maxTextureSize,
            h = { 0: 1, 1: 0, 2: 2 },
            m = new _n({
              defines: { VSM_SAMPLES: 8 },
              uniforms: {
                shadow_pass: { value: null },
                resolution: { value: new Q() },
                radius: { value: 4 },
              },
              vertexShader:
                "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
              fragmentShader:
                "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
            }),
            p = m.clone();
          p.defines.HORIZONTAL_PASS = 1;
          const g = new Ze();
          g.setAttribute(
            "position",
            new Fe(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
          );
          const x = new pn(g, m),
            v = this;
          function y(n, s) {
            const i = e.update(x);
            m.defines.VSM_SAMPLES !== n.blurSamples &&
              ((m.defines.VSM_SAMPLES = n.blurSamples),
              (p.defines.VSM_SAMPLES = n.blurSamples),
              (m.needsUpdate = !0),
              (p.needsUpdate = !0)),
              (m.uniforms.shadow_pass.value = n.map.texture),
              (m.uniforms.resolution.value = n.mapSize),
              (m.uniforms.radius.value = n.radius),
              t.setRenderTarget(n.mapPass),
              t.clear(),
              t.renderBufferDirect(s, null, i, m, x, null),
              (p.uniforms.shadow_pass.value = n.mapPass.texture),
              (p.uniforms.resolution.value = n.mapSize),
              (p.uniforms.radius.value = n.radius),
              t.setRenderTarget(n.map),
              t.clear(),
              t.renderBufferDirect(s, null, i, p, x, null);
          }
          function w(e, n, s, i, r, o, d) {
            let l = null;
            const f =
              !0 === i.isPointLight
                ? e.customDistanceMaterial
                : e.customDepthMaterial;
            if (
              ((l = void 0 !== f ? f : !0 === i.isPointLight ? c : a),
              (t.localClippingEnabled &&
                !0 === s.clipShadows &&
                0 !== s.clippingPlanes.length) ||
                (s.displacementMap && 0 !== s.displacementScale) ||
                (s.alphaMap && s.alphaTest > 0))
            ) {
              const t = l.uuid,
                e = s.uuid;
              let n = u[t];
              void 0 === n && ((n = {}), (u[t] = n));
              let i = n[e];
              void 0 === i && ((i = l.clone()), (n[e] = i)), (l = i);
            }
            return (
              (l.visible = s.visible),
              (l.wireframe = s.wireframe),
              (l.side =
                3 === d
                  ? null !== s.shadowSide
                    ? s.shadowSide
                    : s.side
                  : null !== s.shadowSide
                  ? s.shadowSide
                  : h[s.side]),
              (l.alphaMap = s.alphaMap),
              (l.alphaTest = s.alphaTest),
              (l.clipShadows = s.clipShadows),
              (l.clippingPlanes = s.clippingPlanes),
              (l.clipIntersection = s.clipIntersection),
              (l.displacementMap = s.displacementMap),
              (l.displacementScale = s.displacementScale),
              (l.displacementBias = s.displacementBias),
              (l.wireframeLinewidth = s.wireframeLinewidth),
              (l.linewidth = s.linewidth),
              !0 === i.isPointLight &&
                !0 === l.isMeshDistanceMaterial &&
                (l.referencePosition.setFromMatrixPosition(i.matrixWorld),
                (l.nearDistance = r),
                (l.farDistance = o)),
              l
            );
          }
          function _(n, i, r, o, a) {
            if (!1 === n.visible) return;
            if (
              n.layers.test(i.layers) &&
              (n.isMesh || n.isLine || n.isPoints) &&
              (n.castShadow || (n.receiveShadow && 3 === a)) &&
              (!n.frustumCulled || s.intersectsObject(n))
            ) {
              n.modelViewMatrix.multiplyMatrices(
                r.matrixWorldInverse,
                n.matrixWorld
              );
              const s = e.update(n),
                i = n.material;
              if (Array.isArray(i)) {
                const e = s.groups;
                for (let c = 0, u = e.length; c < u; c++) {
                  const u = e[c],
                    d = i[u.materialIndex];
                  if (d && d.visible) {
                    const e = w(n, 0, d, o, r.near, r.far, a);
                    t.renderBufferDirect(r, null, s, e, n, u);
                  }
                }
              } else if (i.visible) {
                const e = w(n, 0, i, o, r.near, r.far, a);
                t.renderBufferDirect(r, null, s, e, n, null);
              }
            }
            const c = n.children;
            for (let t = 0, e = c.length; t < e; t++) _(c[t], i, r, o, a);
          }
          (this.enabled = !1),
            (this.autoUpdate = !0),
            (this.needsUpdate = !1),
            (this.type = 1),
            (this.render = function (e, n, a) {
              if (!1 === v.enabled) return;
              if (!1 === v.autoUpdate && !1 === v.needsUpdate) return;
              if (0 === e.length) return;
              const c = t.getRenderTarget(),
                u = t.getActiveCubeFace(),
                h = t.getActiveMipmapLevel(),
                m = t.state;
              m.setBlending(0),
                m.buffers.color.setClear(1, 1, 1, 1),
                m.buffers.depth.setTest(!0),
                m.setScissorTest(!1);
              for (let c = 0, u = e.length; c < u; c++) {
                const u = e[c],
                  h = u.shadow;
                if (void 0 === h) {
                  console.warn("THREE.WebGLShadowMap:", u, "has no shadow.");
                  continue;
                }
                if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue;
                i.copy(h.mapSize);
                const p = h.getFrameExtents();
                if (
                  (i.multiply(p),
                  r.copy(h.mapSize),
                  (i.x > l || i.y > l) &&
                    (i.x > l &&
                      ((r.x = Math.floor(l / p.x)),
                      (i.x = r.x * p.x),
                      (h.mapSize.x = r.x)),
                    i.y > l &&
                      ((r.y = Math.floor(l / p.y)),
                      (i.y = r.y * p.y),
                      (h.mapSize.y = r.y))),
                  null === h.map && !h.isPointLightShadow && 3 === this.type)
                ) {
                  const t = { minFilter: f, magFilter: f, format: b };
                  (h.map = new dt(i.x, i.y, t)),
                    (h.map.texture.name = u.name + ".shadowMap"),
                    (h.mapPass = new dt(i.x, i.y, t)),
                    h.camera.updateProjectionMatrix();
                }
                if (null === h.map) {
                  const t = { minFilter: d, magFilter: d, format: b };
                  (h.map = new dt(i.x, i.y, t)),
                    (h.map.texture.name = u.name + ".shadowMap"),
                    h.camera.updateProjectionMatrix();
                }
                t.setRenderTarget(h.map), t.clear();
                const g = h.getViewportCount();
                for (let t = 0; t < g; t++) {
                  const e = h.getViewport(t);
                  o.set(r.x * e.x, r.y * e.y, r.x * e.z, r.y * e.w),
                    m.viewport(o),
                    h.updateMatrices(u, t),
                    (s = h.getFrustum()),
                    _(n, a, h.camera, u, this.type);
                }
                h.isPointLightShadow || 3 !== this.type || y(h, a),
                  (h.needsUpdate = !1);
              }
              (v.needsUpdate = !1), t.setRenderTarget(c, u, h);
            });
        }
        function dr(t, e, n) {
          const i = n.isWebGL2,
            r = new (function () {
              let e = !1;
              const n = new ut();
              let s = null;
              const i = new ut(0, 0, 0, 0);
              return {
                setMask: function (n) {
                  s === n || e || (t.colorMask(n, n, n, n), (s = n));
                },
                setLocked: function (t) {
                  e = t;
                },
                setClear: function (e, s, r, o, a) {
                  !0 === a && ((e *= o), (s *= o), (r *= o)),
                    n.set(e, s, r, o),
                    !1 === i.equals(n) && (t.clearColor(e, s, r, o), i.copy(n));
                },
                reset: function () {
                  (e = !1), (s = null), i.set(-1, 0, 0, 0);
                },
              };
            })(),
            o = new (function () {
              let e = !1,
                n = null,
                s = null,
                i = null;
              return {
                setTest: function (t) {
                  t ? z(2929) : F(2929);
                },
                setMask: function (s) {
                  n === s || e || (t.depthMask(s), (n = s));
                },
                setFunc: function (e) {
                  if (s !== e) {
                    if (e)
                      switch (e) {
                        case 0:
                          t.depthFunc(512);
                          break;
                        case 1:
                          t.depthFunc(519);
                          break;
                        case 2:
                          t.depthFunc(513);
                          break;
                        default:
                          t.depthFunc(515);
                          break;
                        case 4:
                          t.depthFunc(514);
                          break;
                        case 5:
                          t.depthFunc(518);
                          break;
                        case 6:
                          t.depthFunc(516);
                          break;
                        case 7:
                          t.depthFunc(517);
                      }
                    else t.depthFunc(515);
                    s = e;
                  }
                },
                setLocked: function (t) {
                  e = t;
                },
                setClear: function (e) {
                  i !== e && (t.clearDepth(e), (i = e));
                },
                reset: function () {
                  (e = !1), (n = null), (s = null), (i = null);
                },
              };
            })(),
            a = new (function () {
              let e = !1,
                n = null,
                s = null,
                i = null,
                r = null,
                o = null,
                a = null,
                c = null,
                u = null;
              return {
                setTest: function (t) {
                  e || (t ? z(2960) : F(2960));
                },
                setMask: function (s) {
                  n === s || e || (t.stencilMask(s), (n = s));
                },
                setFunc: function (e, n, o) {
                  (s === e && i === n && r === o) ||
                    (t.stencilFunc(e, n, o), (s = e), (i = n), (r = o));
                },
                setOp: function (e, n, s) {
                  (o === e && a === n && c === s) ||
                    (t.stencilOp(e, n, s), (o = e), (a = n), (c = s));
                },
                setLocked: function (t) {
                  e = t;
                },
                setClear: function (e) {
                  u !== e && (t.clearStencil(e), (u = e));
                },
                reset: function () {
                  (e = !1),
                    (n = null),
                    (s = null),
                    (i = null),
                    (r = null),
                    (o = null),
                    (a = null),
                    (c = null),
                    (u = null);
                },
              };
            })();
          let c = {},
            u = null,
            d = {},
            l = null,
            h = !1,
            f = null,
            m = null,
            p = null,
            g = null,
            x = null,
            v = null,
            y = null,
            w = !1,
            _ = null,
            b = null,
            M = null,
            S = null,
            T = null;
          const E = t.getParameter(35661);
          let C = !1,
            A = 0;
          const L = t.getParameter(7938);
          -1 !== L.indexOf("WebGL")
            ? ((A = parseFloat(/^WebGL (\d)/.exec(L)[1])), (C = A >= 1))
            : -1 !== L.indexOf("OpenGL ES") &&
              ((A = parseFloat(/^OpenGL ES (\d)/.exec(L)[1])), (C = A >= 2));
          let R = null,
            P = {};
          const I = t.getParameter(3088),
            D = t.getParameter(2978),
            N = new ut().fromArray(I),
            O = new ut().fromArray(D);
          function k(e, n, s) {
            const i = new Uint8Array(4),
              r = t.createTexture();
            t.bindTexture(e, r),
              t.texParameteri(e, 10241, 9728),
              t.texParameteri(e, 10240, 9728);
            for (let e = 0; e < s; e++)
              t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, i);
            return r;
          }
          const U = {};
          function z(e) {
            !0 !== c[e] && (t.enable(e), (c[e] = !0));
          }
          function F(e) {
            !1 !== c[e] && (t.disable(e), (c[e] = !1));
          }
          (U[3553] = k(3553, 3553, 1)),
            (U[34067] = k(34067, 34069, 6)),
            r.setClear(0, 0, 0, 1),
            o.setClear(1),
            a.setClear(0),
            z(2929),
            o.setFunc(3),
            V(!1),
            W(1),
            z(2884),
            G(0);
          const B = { [s]: 32774, 101: 32778, 102: 32779 };
          if (i) (B[103] = 32775), (B[104] = 32776);
          else {
            const t = e.get("EXT_blend_minmax");
            null !== t && ((B[103] = t.MIN_EXT), (B[104] = t.MAX_EXT));
          }
          const H = {
            200: 0,
            201: 1,
            202: 768,
            204: 770,
            210: 776,
            208: 774,
            206: 772,
            203: 769,
            205: 771,
            209: 775,
            207: 773,
          };
          function G(e, n, i, r, o, a, c, u) {
            if (0 !== e) {
              if ((!1 === h && (z(3042), (h = !0)), 5 === e))
                (o = o || n),
                  (a = a || i),
                  (c = c || r),
                  (n === m && o === x) ||
                    (t.blendEquationSeparate(B[n], B[o]), (m = n), (x = o)),
                  (i === p && r === g && a === v && c === y) ||
                    (t.blendFuncSeparate(H[i], H[r], H[a], H[c]),
                    (p = i),
                    (g = r),
                    (v = a),
                    (y = c)),
                  (f = e),
                  (w = null);
              else if (e !== f || u !== w) {
                if (
                  ((m === s && x === s) ||
                    (t.blendEquation(32774), (m = s), (x = s)),
                  u)
                )
                  switch (e) {
                    case 1:
                      t.blendFuncSeparate(1, 771, 1, 771);
                      break;
                    case 2:
                      t.blendFunc(1, 1);
                      break;
                    case 3:
                      t.blendFuncSeparate(0, 0, 769, 771);
                      break;
                    case 4:
                      t.blendFuncSeparate(0, 768, 0, 770);
                      break;
                    default:
                      console.error("THREE.WebGLState: Invalid blending: ", e);
                  }
                else
                  switch (e) {
                    case 1:
                      t.blendFuncSeparate(770, 771, 1, 771);
                      break;
                    case 2:
                      t.blendFunc(770, 1);
                      break;
                    case 3:
                      t.blendFunc(0, 769);
                      break;
                    case 4:
                      t.blendFunc(0, 768);
                      break;
                    default:
                      console.error("THREE.WebGLState: Invalid blending: ", e);
                  }
                (p = null),
                  (g = null),
                  (v = null),
                  (y = null),
                  (f = e),
                  (w = u);
              }
            } else !0 === h && (F(3042), (h = !1));
          }
          function V(e) {
            _ !== e && (e ? t.frontFace(2304) : t.frontFace(2305), (_ = e));
          }
          function W(e) {
            0 !== e
              ? (z(2884),
                e !== b &&
                  (1 === e
                    ? t.cullFace(1029)
                    : 2 === e
                    ? t.cullFace(1028)
                    : t.cullFace(1032)))
              : F(2884),
              (b = e);
          }
          function j(e, n, s) {
            e
              ? (z(32823),
                (S === n && T === s) ||
                  (t.polygonOffset(n, s), (S = n), (T = s)))
              : F(32823);
          }
          function X(e) {
            void 0 === e && (e = 33984 + E - 1),
              R !== e && (t.activeTexture(e), (R = e));
          }
          return {
            buffers: { color: r, depth: o, stencil: a },
            enable: z,
            disable: F,
            bindFramebuffer: function (e, n) {
              return (
                null === n && null !== u && (n = u),
                d[e] !== n &&
                  (t.bindFramebuffer(e, n),
                  (d[e] = n),
                  i &&
                    (36009 === e && (d[36160] = n),
                    36160 === e && (d[36009] = n)),
                  !0)
              );
            },
            bindXRFramebuffer: function (e) {
              e !== u && (t.bindFramebuffer(36160, e), (u = e));
            },
            useProgram: function (e) {
              return l !== e && (t.useProgram(e), (l = e), !0);
            },
            setBlending: G,
            setMaterial: function (t, e) {
              2 === t.side ? F(2884) : z(2884);
              let n = 1 === t.side;
              e && (n = !n),
                V(n),
                1 === t.blending && !1 === t.transparent
                  ? G(0)
                  : G(
                      t.blending,
                      t.blendEquation,
                      t.blendSrc,
                      t.blendDst,
                      t.blendEquationAlpha,
                      t.blendSrcAlpha,
                      t.blendDstAlpha,
                      t.premultipliedAlpha
                    ),
                o.setFunc(t.depthFunc),
                o.setTest(t.depthTest),
                o.setMask(t.depthWrite),
                r.setMask(t.colorWrite);
              const s = t.stencilWrite;
              a.setTest(s),
                s &&
                  (a.setMask(t.stencilWriteMask),
                  a.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
                  a.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
                j(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
                !0 === t.alphaToCoverage ? z(32926) : F(32926);
            },
            setFlipSided: V,
            setCullFace: W,
            setLineWidth: function (e) {
              e !== M && (C && t.lineWidth(e), (M = e));
            },
            setPolygonOffset: j,
            setScissorTest: function (t) {
              t ? z(3089) : F(3089);
            },
            activeTexture: X,
            bindTexture: function (e, n) {
              null === R && X();
              let s = P[R];
              void 0 === s &&
                ((s = { type: void 0, texture: void 0 }), (P[R] = s)),
                (s.type === e && s.texture === n) ||
                  (t.bindTexture(e, n || U[e]), (s.type = e), (s.texture = n));
            },
            unbindTexture: function () {
              const e = P[R];
              void 0 !== e &&
                void 0 !== e.type &&
                (t.bindTexture(e.type, null),
                (e.type = void 0),
                (e.texture = void 0));
            },
            compressedTexImage2D: function () {
              try {
                t.compressedTexImage2D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            texImage2D: function () {
              try {
                t.texImage2D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            texImage3D: function () {
              try {
                t.texImage3D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            scissor: function (e) {
              !1 === N.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), N.copy(e));
            },
            viewport: function (e) {
              !1 === O.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), O.copy(e));
            },
            reset: function () {
              t.disable(3042),
                t.disable(2884),
                t.disable(2929),
                t.disable(32823),
                t.disable(3089),
                t.disable(2960),
                t.disable(32926),
                t.blendEquation(32774),
                t.blendFunc(1, 0),
                t.blendFuncSeparate(1, 0, 1, 0),
                t.colorMask(!0, !0, !0, !0),
                t.clearColor(0, 0, 0, 0),
                t.depthMask(!0),
                t.depthFunc(513),
                t.clearDepth(1),
                t.stencilMask(4294967295),
                t.stencilFunc(519, 0, 4294967295),
                t.stencilOp(7680, 7680, 7680),
                t.clearStencil(0),
                t.cullFace(1029),
                t.frontFace(2305),
                t.polygonOffset(0, 0),
                t.activeTexture(33984),
                t.bindFramebuffer(36160, null),
                !0 === i &&
                  (t.bindFramebuffer(36009, null),
                  t.bindFramebuffer(36008, null)),
                t.useProgram(null),
                t.lineWidth(1),
                t.scissor(0, 0, t.canvas.width, t.canvas.height),
                t.viewport(0, 0, t.canvas.width, t.canvas.height),
                (c = {}),
                (R = null),
                (P = {}),
                (u = null),
                (d = {}),
                (l = null),
                (h = !1),
                (f = null),
                (m = null),
                (p = null),
                (g = null),
                (x = null),
                (v = null),
                (y = null),
                (w = !1),
                (_ = null),
                (b = null),
                (M = null),
                (S = null),
                (T = null),
                N.set(0, 0, t.canvas.width, t.canvas.height),
                O.set(0, 0, t.canvas.width, t.canvas.height),
                r.reset(),
                o.reset(),
                a.reset();
            },
          };
        }
        function lr(t, e, n, s, i, r, o) {
          const p = i.isWebGL2,
            T = i.maxTextures,
            E = i.maxCubemapSize,
            C = i.maxTextureSize,
            A = i.maxSamples,
            L = new WeakMap();
          let R,
            P = !1;
          try {
            P =
              "undefined" != typeof OffscreenCanvas &&
              null !== new OffscreenCanvas(1, 1).getContext("2d");
          } catch (t) {}
          function D(t, e) {
            return P ? new OffscreenCanvas(t, e) : nt("canvas");
          }
          function N(t, e, n, s) {
            let i = 1;
            if (
              ((t.width > s || t.height > s) &&
                (i = s / Math.max(t.width, t.height)),
              i < 1 || !0 === e)
            ) {
              if (
                ("undefined" != typeof HTMLImageElement &&
                  t instanceof HTMLImageElement) ||
                ("undefined" != typeof HTMLCanvasElement &&
                  t instanceof HTMLCanvasElement) ||
                ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
              ) {
                const s = e ? $ : Math.floor,
                  r = s(i * t.width),
                  o = s(i * t.height);
                void 0 === R && (R = D(r, o));
                const a = n ? D(r, o) : R;
                return (
                  (a.width = r),
                  (a.height = o),
                  a.getContext("2d").drawImage(t, 0, 0, r, o),
                  console.warn(
                    "THREE.WebGLRenderer: Texture has been resized from (" +
                      t.width +
                      "x" +
                      t.height +
                      ") to (" +
                      r +
                      "x" +
                      o +
                      ")."
                  ),
                  a
                );
              }
              return (
                "data" in t &&
                  console.warn(
                    "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                      t.width +
                      "x" +
                      t.height +
                      ")."
                  ),
                t
              );
            }
            return t;
          }
          function O(t) {
            return J(t.width) && J(t.height);
          }
          function k(t, e) {
            return (
              t.generateMipmaps && e && t.minFilter !== d && t.minFilter !== f
            );
          }
          function U(e, n, i, r, o = 1) {
            t.generateMipmap(e),
              (s.get(n).__maxMipLevel = Math.log2(Math.max(i, r, o)));
          }
          function z(n, s, i, r) {
            if (!1 === p) return s;
            if (null !== n) {
              if (void 0 !== t[n]) return t[n];
              console.warn(
                "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                  n +
                  "'"
              );
            }
            let o = s;
            return (
              6403 === s &&
                (5126 === i && (o = 33326),
                5131 === i && (o = 33325),
                5121 === i && (o = 33321)),
              6407 === s &&
                (5126 === i && (o = 34837),
                5131 === i && (o = 34843),
                5121 === i && (o = 32849)),
              6408 === s &&
                (5126 === i && (o = 34836),
                5131 === i && (o = 34842),
                5121 === i && (o = r === I ? 35907 : 32856)),
              (33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o) ||
                e.get("EXT_color_buffer_float"),
              o
            );
          }
          function F(t) {
            return t === d || t === l || t === h ? 9728 : 9729;
          }
          function B(e) {
            const n = e.target;
            n.removeEventListener("dispose", B),
              (function (e) {
                const n = s.get(e);
                void 0 !== n.__webglInit &&
                  (t.deleteTexture(n.__webglTexture), s.remove(e));
              })(n),
              n.isVideoTexture && L.delete(n),
              o.memory.textures--;
          }
          function H(e) {
            const n = e.target;
            n.removeEventListener("dispose", H),
              (function (e) {
                const n = e.texture,
                  i = s.get(e),
                  r = s.get(n);
                if (e) {
                  if (
                    (void 0 !== r.__webglTexture &&
                      (t.deleteTexture(r.__webglTexture), o.memory.textures--),
                    e.depthTexture && e.depthTexture.dispose(),
                    e.isWebGLCubeRenderTarget)
                  )
                    for (let e = 0; e < 6; e++)
                      t.deleteFramebuffer(i.__webglFramebuffer[e]),
                        i.__webglDepthbuffer &&
                          t.deleteRenderbuffer(i.__webglDepthbuffer[e]);
                  else
                    t.deleteFramebuffer(i.__webglFramebuffer),
                      i.__webglDepthbuffer &&
                        t.deleteRenderbuffer(i.__webglDepthbuffer),
                      i.__webglMultisampledFramebuffer &&
                        t.deleteFramebuffer(i.__webglMultisampledFramebuffer),
                      i.__webglColorRenderbuffer &&
                        t.deleteRenderbuffer(i.__webglColorRenderbuffer),
                      i.__webglDepthRenderbuffer &&
                        t.deleteRenderbuffer(i.__webglDepthRenderbuffer);
                  if (e.isWebGLMultipleRenderTargets)
                    for (let e = 0, i = n.length; e < i; e++) {
                      const i = s.get(n[e]);
                      i.__webglTexture &&
                        (t.deleteTexture(i.__webglTexture),
                        o.memory.textures--),
                        s.remove(n[e]);
                    }
                  s.remove(n), s.remove(e);
                }
              })(n);
          }
          let G = 0;
          function V(t, e) {
            const i = s.get(t);
            if (
              (t.isVideoTexture &&
                (function (t) {
                  const e = o.render.frame;
                  L.get(t) !== e && (L.set(t, e), t.update());
                })(t),
              t.version > 0 && i.__version !== t.version)
            ) {
              const n = t.image;
              if (void 0 === n)
                console.warn(
                  "THREE.WebGLRenderer: Texture marked for update but image is undefined"
                );
              else {
                if (!1 !== n.complete) return void Z(i, t, e);
                console.warn(
                  "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
                );
              }
            }
            n.activeTexture(33984 + e), n.bindTexture(3553, i.__webglTexture);
          }
          function W(e, i) {
            const o = s.get(e);
            e.version > 0 && o.__version !== e.version
              ? (function (e, s, i) {
                  if (6 !== s.image.length) return;
                  Y(e, s),
                    n.activeTexture(33984 + i),
                    n.bindTexture(34067, e.__webglTexture),
                    t.pixelStorei(37440, s.flipY),
                    t.pixelStorei(37441, s.premultiplyAlpha),
                    t.pixelStorei(3317, s.unpackAlignment),
                    t.pixelStorei(37443, 0);
                  const o =
                      s &&
                      (s.isCompressedTexture || s.image[0].isCompressedTexture),
                    a = s.image[0] && s.image[0].isDataTexture,
                    c = [];
                  for (let t = 0; t < 6; t++)
                    c[t] =
                      o || a
                        ? a
                          ? s.image[t].image
                          : s.image[t]
                        : N(s.image[t], !1, !0, E);
                  const u = c[0],
                    d = O(u) || p,
                    l = r.convert(s.format),
                    h = r.convert(s.type),
                    f = z(s.internalFormat, l, h, s.encoding);
                  let m;
                  if ((q(34067, s, d), o)) {
                    for (let t = 0; t < 6; t++) {
                      m = c[t].mipmaps;
                      for (let e = 0; e < m.length; e++) {
                        const i = m[e];
                        s.format !== b && s.format !== _
                          ? null !== l
                            ? n.compressedTexImage2D(
                                34069 + t,
                                e,
                                f,
                                i.width,
                                i.height,
                                0,
                                i.data
                              )
                            : console.warn(
                                "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                              )
                          : n.texImage2D(
                              34069 + t,
                              e,
                              f,
                              i.width,
                              i.height,
                              0,
                              l,
                              h,
                              i.data
                            );
                      }
                    }
                    e.__maxMipLevel = m.length - 1;
                  } else {
                    m = s.mipmaps;
                    for (let t = 0; t < 6; t++)
                      if (a) {
                        n.texImage2D(
                          34069 + t,
                          0,
                          f,
                          c[t].width,
                          c[t].height,
                          0,
                          l,
                          h,
                          c[t].data
                        );
                        for (let e = 0; e < m.length; e++) {
                          const s = m[e].image[t].image;
                          n.texImage2D(
                            34069 + t,
                            e + 1,
                            f,
                            s.width,
                            s.height,
                            0,
                            l,
                            h,
                            s.data
                          );
                        }
                      } else {
                        n.texImage2D(34069 + t, 0, f, l, h, c[t]);
                        for (let e = 0; e < m.length; e++) {
                          const s = m[e];
                          n.texImage2D(34069 + t, e + 1, f, l, h, s.image[t]);
                        }
                      }
                    e.__maxMipLevel = m.length;
                  }
                  k(s, d) && U(34067, s, u.width, u.height),
                    (e.__version = s.version),
                    s.onUpdate && s.onUpdate(s);
                })(o, e, i)
              : (n.activeTexture(33984 + i),
                n.bindTexture(34067, o.__webglTexture));
          }
          const j = { [a]: 10497, [c]: 33071, [u]: 33648 },
            X = {
              [d]: 9728,
              [l]: 9984,
              [h]: 9986,
              [f]: 9729,
              1007: 9985,
              [m]: 9987,
            };
          function q(n, r, o) {
            if (
              (o
                ? (t.texParameteri(n, 10242, j[r.wrapS]),
                  t.texParameteri(n, 10243, j[r.wrapT]),
                  (32879 !== n && 35866 !== n) ||
                    t.texParameteri(n, 32882, j[r.wrapR]),
                  t.texParameteri(n, 10240, X[r.magFilter]),
                  t.texParameteri(n, 10241, X[r.minFilter]))
                : (t.texParameteri(n, 10242, 33071),
                  t.texParameteri(n, 10243, 33071),
                  (32879 !== n && 35866 !== n) ||
                    t.texParameteri(n, 32882, 33071),
                  (r.wrapS === c && r.wrapT === c) ||
                    console.warn(
                      "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                    ),
                  t.texParameteri(n, 10240, F(r.magFilter)),
                  t.texParameteri(n, 10241, F(r.minFilter)),
                  r.minFilter !== d &&
                    r.minFilter !== f &&
                    console.warn(
                      "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                    )),
              !0 === e.has("EXT_texture_filter_anisotropic"))
            ) {
              const o = e.get("EXT_texture_filter_anisotropic");
              if (r.type === v && !1 === e.has("OES_texture_float_linear"))
                return;
              if (
                !1 === p &&
                r.type === y &&
                !1 === e.has("OES_texture_half_float_linear")
              )
                return;
              (r.anisotropy > 1 || s.get(r).__currentAnisotropy) &&
                (t.texParameterf(
                  n,
                  o.TEXTURE_MAX_ANISOTROPY_EXT,
                  Math.min(r.anisotropy, i.getMaxAnisotropy())
                ),
                (s.get(r).__currentAnisotropy = r.anisotropy));
            }
          }
          function Y(e, n) {
            void 0 === e.__webglInit &&
              ((e.__webglInit = !0),
              n.addEventListener("dispose", B),
              (e.__webglTexture = t.createTexture()),
              o.memory.textures++);
          }
          function Z(e, s, i) {
            let o = 3553;
            s.isDataTexture2DArray && (o = 35866),
              s.isDataTexture3D && (o = 32879),
              Y(e, s),
              n.activeTexture(33984 + i),
              n.bindTexture(o, e.__webglTexture),
              t.pixelStorei(37440, s.flipY),
              t.pixelStorei(37441, s.premultiplyAlpha),
              t.pixelStorei(3317, s.unpackAlignment),
              t.pixelStorei(37443, 0);
            const a =
                (function (t) {
                  return (
                    !p &&
                    (t.wrapS !== c ||
                      t.wrapT !== c ||
                      (t.minFilter !== d && t.minFilter !== f))
                  );
                })(s) && !1 === O(s.image),
              u = N(s.image, a, !1, C),
              l = O(u) || p,
              h = r.convert(s.format);
            let m,
              y = r.convert(s.type),
              T = z(s.internalFormat, h, y, s.encoding);
            q(o, s, l);
            const E = s.mipmaps;
            if (s.isDepthTexture)
              (T = 6402),
                p
                  ? (T =
                      s.type === v
                        ? 36012
                        : s.type === x
                        ? 33190
                        : s.type === w
                        ? 35056
                        : 33189)
                  : s.type === v &&
                    console.error(
                      "WebGLRenderer: Floating point depth texture requires WebGL2."
                    ),
                s.format === M &&
                  6402 === T &&
                  s.type !== g &&
                  s.type !== x &&
                  (console.warn(
                    "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
                  ),
                  (s.type = g),
                  (y = r.convert(s.type))),
                s.format === S &&
                  6402 === T &&
                  ((T = 34041),
                  s.type !== w &&
                    (console.warn(
                      "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                    ),
                    (s.type = w),
                    (y = r.convert(s.type)))),
                n.texImage2D(3553, 0, T, u.width, u.height, 0, h, y, null);
            else if (s.isDataTexture)
              if (E.length > 0 && l) {
                for (let t = 0, e = E.length; t < e; t++)
                  (m = E[t]),
                    n.texImage2D(
                      3553,
                      t,
                      T,
                      m.width,
                      m.height,
                      0,
                      h,
                      y,
                      m.data
                    );
                (s.generateMipmaps = !1), (e.__maxMipLevel = E.length - 1);
              } else
                n.texImage2D(3553, 0, T, u.width, u.height, 0, h, y, u.data),
                  (e.__maxMipLevel = 0);
            else if (s.isCompressedTexture) {
              for (let t = 0, e = E.length; t < e; t++)
                (m = E[t]),
                  s.format !== b && s.format !== _
                    ? null !== h
                      ? n.compressedTexImage2D(
                          3553,
                          t,
                          T,
                          m.width,
                          m.height,
                          0,
                          m.data
                        )
                      : console.warn(
                          "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                        )
                    : n.texImage2D(
                        3553,
                        t,
                        T,
                        m.width,
                        m.height,
                        0,
                        h,
                        y,
                        m.data
                      );
              e.__maxMipLevel = E.length - 1;
            } else if (s.isDataTexture2DArray)
              n.texImage3D(
                35866,
                0,
                T,
                u.width,
                u.height,
                u.depth,
                0,
                h,
                y,
                u.data
              ),
                (e.__maxMipLevel = 0);
            else if (s.isDataTexture3D)
              n.texImage3D(
                32879,
                0,
                T,
                u.width,
                u.height,
                u.depth,
                0,
                h,
                y,
                u.data
              ),
                (e.__maxMipLevel = 0);
            else if (E.length > 0 && l) {
              for (let t = 0, e = E.length; t < e; t++)
                (m = E[t]), n.texImage2D(3553, t, T, h, y, m);
              (s.generateMipmaps = !1), (e.__maxMipLevel = E.length - 1);
            } else n.texImage2D(3553, 0, T, h, y, u), (e.__maxMipLevel = 0);
            k(s, l) && U(o, s, u.width, u.height),
              (e.__version = s.version),
              s.onUpdate && s.onUpdate(s);
          }
          function K(e, i, o, a, c) {
            const u = r.convert(o.format),
              d = r.convert(o.type),
              l = z(o.internalFormat, u, d, o.encoding);
            32879 === c || 35866 === c
              ? n.texImage3D(c, 0, l, i.width, i.height, i.depth, 0, u, d, null)
              : n.texImage2D(c, 0, l, i.width, i.height, 0, u, d, null),
              n.bindFramebuffer(36160, e),
              t.framebufferTexture2D(36160, a, c, s.get(o).__webglTexture, 0),
              n.bindFramebuffer(36160, null);
          }
          function Q(e, n, s) {
            if (
              (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer)
            ) {
              let i = 33189;
              if (s) {
                const e = n.depthTexture;
                e &&
                  e.isDepthTexture &&
                  (e.type === v ? (i = 36012) : e.type === x && (i = 33190));
                const s = tt(n);
                t.renderbufferStorageMultisample(
                  36161,
                  s,
                  i,
                  n.width,
                  n.height
                );
              } else t.renderbufferStorage(36161, i, n.width, n.height);
              t.framebufferRenderbuffer(36160, 36096, 36161, e);
            } else if (n.depthBuffer && n.stencilBuffer) {
              if (s) {
                const e = tt(n);
                t.renderbufferStorageMultisample(
                  36161,
                  e,
                  35056,
                  n.width,
                  n.height
                );
              } else t.renderbufferStorage(36161, 34041, n.width, n.height);
              t.framebufferRenderbuffer(36160, 33306, 36161, e);
            } else {
              const e =
                  !0 === n.isWebGLMultipleRenderTargets
                    ? n.texture[0]
                    : n.texture,
                i = r.convert(e.format),
                o = r.convert(e.type),
                a = z(e.internalFormat, i, o, e.encoding);
              if (s) {
                const e = tt(n);
                t.renderbufferStorageMultisample(
                  36161,
                  e,
                  a,
                  n.width,
                  n.height
                );
              } else t.renderbufferStorage(36161, a, n.width, n.height);
            }
            t.bindRenderbuffer(36161, null);
          }
          function tt(t) {
            return p && t.isWebGLMultisampleRenderTarget
              ? Math.min(A, t.samples)
              : 0;
          }
          let et = !1,
            st = !1;
          (this.allocateTextureUnit = function () {
            const t = G;
            return (
              t >= T &&
                console.warn(
                  "THREE.WebGLTextures: Trying to use " +
                    t +
                    " texture units while this GPU supports only " +
                    T
                ),
              (G += 1),
              t
            );
          }),
            (this.resetTextureUnits = function () {
              G = 0;
            }),
            (this.setTexture2D = V),
            (this.setTexture2DArray = function (t, e) {
              const i = s.get(t);
              t.version > 0 && i.__version !== t.version
                ? Z(i, t, e)
                : (n.activeTexture(33984 + e),
                  n.bindTexture(35866, i.__webglTexture));
            }),
            (this.setTexture3D = function (t, e) {
              const i = s.get(t);
              t.version > 0 && i.__version !== t.version
                ? Z(i, t, e)
                : (n.activeTexture(33984 + e),
                  n.bindTexture(32879, i.__webglTexture));
            }),
            (this.setTextureCube = W),
            (this.setupRenderTarget = function (e) {
              const a = e.texture,
                c = s.get(e),
                u = s.get(a);
              e.addEventListener("dispose", H),
                !0 !== e.isWebGLMultipleRenderTargets &&
                  ((u.__webglTexture = t.createTexture()),
                  (u.__version = a.version),
                  o.memory.textures++);
              const d = !0 === e.isWebGLCubeRenderTarget,
                l = !0 === e.isWebGLMultipleRenderTargets,
                h = !0 === e.isWebGLMultisampleRenderTarget,
                f = a.isDataTexture3D || a.isDataTexture2DArray,
                m = O(e) || p;
              if (
                (!p ||
                  a.format !== _ ||
                  (a.type !== v && a.type !== y) ||
                  ((a.format = b),
                  console.warn(
                    "THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead."
                  )),
                d)
              ) {
                c.__webglFramebuffer = [];
                for (let e = 0; e < 6; e++)
                  c.__webglFramebuffer[e] = t.createFramebuffer();
              } else if (((c.__webglFramebuffer = t.createFramebuffer()), l))
                if (i.drawBuffers) {
                  const n = e.texture;
                  for (let e = 0, i = n.length; e < i; e++) {
                    const i = s.get(n[e]);
                    void 0 === i.__webglTexture &&
                      ((i.__webglTexture = t.createTexture()),
                      o.memory.textures++);
                  }
                } else
                  console.warn(
                    "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
                  );
              else if (h)
                if (p) {
                  (c.__webglMultisampledFramebuffer = t.createFramebuffer()),
                    (c.__webglColorRenderbuffer = t.createRenderbuffer()),
                    t.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
                  const s = r.convert(a.format),
                    i = r.convert(a.type),
                    o = z(a.internalFormat, s, i, a.encoding),
                    u = tt(e);
                  t.renderbufferStorageMultisample(
                    36161,
                    u,
                    o,
                    e.width,
                    e.height
                  ),
                    n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer),
                    t.framebufferRenderbuffer(
                      36160,
                      36064,
                      36161,
                      c.__webglColorRenderbuffer
                    ),
                    t.bindRenderbuffer(36161, null),
                    e.depthBuffer &&
                      ((c.__webglDepthRenderbuffer = t.createRenderbuffer()),
                      Q(c.__webglDepthRenderbuffer, e, !0)),
                    n.bindFramebuffer(36160, null);
                } else
                  console.warn(
                    "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
                  );
              if (d) {
                n.bindTexture(34067, u.__webglTexture), q(34067, a, m);
                for (let t = 0; t < 6; t++)
                  K(c.__webglFramebuffer[t], e, a, 36064, 34069 + t);
                k(a, m) && U(34067, a, e.width, e.height), n.unbindTexture();
              } else if (l) {
                const t = e.texture;
                for (let i = 0, r = t.length; i < r; i++) {
                  const r = t[i],
                    o = s.get(r);
                  n.bindTexture(3553, o.__webglTexture),
                    q(3553, r, m),
                    K(c.__webglFramebuffer, e, r, 36064 + i, 3553),
                    k(r, m) && U(3553, r, e.width, e.height);
                }
                n.unbindTexture();
              } else {
                let t = 3553;
                f &&
                  (p
                    ? (t = a.isDataTexture3D ? 32879 : 35866)
                    : console.warn(
                        "THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2."
                      )),
                  n.bindTexture(t, u.__webglTexture),
                  q(t, a, m),
                  K(c.__webglFramebuffer, e, a, 36064, t),
                  k(a, m) && U(t, a, e.width, e.height, e.depth),
                  n.unbindTexture();
              }
              e.depthBuffer &&
                (function (e) {
                  const i = s.get(e),
                    r = !0 === e.isWebGLCubeRenderTarget;
                  if (e.depthTexture) {
                    if (r)
                      throw new Error(
                        "target.depthTexture not supported in Cube render targets"
                      );
                    !(function (e, i) {
                      if (i && i.isWebGLCubeRenderTarget)
                        throw new Error(
                          "Depth Texture with cube render targets is not supported"
                        );
                      if (
                        (n.bindFramebuffer(36160, e),
                        !i.depthTexture || !i.depthTexture.isDepthTexture)
                      )
                        throw new Error(
                          "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
                        );
                      (s.get(i.depthTexture).__webglTexture &&
                        i.depthTexture.image.width === i.width &&
                        i.depthTexture.image.height === i.height) ||
                        ((i.depthTexture.image.width = i.width),
                        (i.depthTexture.image.height = i.height),
                        (i.depthTexture.needsUpdate = !0)),
                        V(i.depthTexture, 0);
                      const r = s.get(i.depthTexture).__webglTexture;
                      if (i.depthTexture.format === M)
                        t.framebufferTexture2D(36160, 36096, 3553, r, 0);
                      else {
                        if (i.depthTexture.format !== S)
                          throw new Error("Unknown depthTexture format");
                        t.framebufferTexture2D(36160, 33306, 3553, r, 0);
                      }
                    })(i.__webglFramebuffer, e);
                  } else if (r) {
                    i.__webglDepthbuffer = [];
                    for (let s = 0; s < 6; s++)
                      n.bindFramebuffer(36160, i.__webglFramebuffer[s]),
                        (i.__webglDepthbuffer[s] = t.createRenderbuffer()),
                        Q(i.__webglDepthbuffer[s], e, !1);
                  } else
                    n.bindFramebuffer(36160, i.__webglFramebuffer),
                      (i.__webglDepthbuffer = t.createRenderbuffer()),
                      Q(i.__webglDepthbuffer, e, !1);
                  n.bindFramebuffer(36160, null);
                })(e);
            }),
            (this.updateRenderTargetMipmap = function (t) {
              const e = O(t) || p,
                i =
                  !0 === t.isWebGLMultipleRenderTargets
                    ? t.texture
                    : [t.texture];
              for (let r = 0, o = i.length; r < o; r++) {
                const o = i[r];
                if (k(o, e)) {
                  const e = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                    i = s.get(o).__webglTexture;
                  n.bindTexture(e, i),
                    U(e, o, t.width, t.height),
                    n.unbindTexture();
                }
              }
            }),
            (this.updateMultisampleRenderTarget = function (e) {
              if (e.isWebGLMultisampleRenderTarget)
                if (p) {
                  const i = e.width,
                    r = e.height;
                  let o = 16384;
                  e.depthBuffer && (o |= 256), e.stencilBuffer && (o |= 1024);
                  const a = s.get(e);
                  n.bindFramebuffer(36008, a.__webglMultisampledFramebuffer),
                    n.bindFramebuffer(36009, a.__webglFramebuffer),
                    t.blitFramebuffer(0, 0, i, r, 0, 0, i, r, o, 9728),
                    n.bindFramebuffer(36008, null),
                    n.bindFramebuffer(36009, a.__webglMultisampledFramebuffer);
                } else
                  console.warn(
                    "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
                  );
            }),
            (this.safeSetTexture2D = function (t, e) {
              t &&
                t.isWebGLRenderTarget &&
                (!1 === et &&
                  (console.warn(
                    "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
                  ),
                  (et = !0)),
                (t = t.texture)),
                V(t, e);
            }),
            (this.safeSetTextureCube = function (t, e) {
              t &&
                t.isWebGLCubeRenderTarget &&
                (!1 === st &&
                  (console.warn(
                    "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
                  ),
                  (st = !0)),
                (t = t.texture)),
                W(t, e);
            });
        }
        function hr(t, e, n) {
          const s = n.isWebGL2;
          return {
            convert: function (t) {
              let n;
              if (t === p) return 5121;
              if (1017 === t) return 32819;
              if (1018 === t) return 32820;
              if (1019 === t) return 33635;
              if (1010 === t) return 5120;
              if (1011 === t) return 5122;
              if (t === g) return 5123;
              if (1013 === t) return 5124;
              if (t === x) return 5125;
              if (t === v) return 5126;
              if (t === y)
                return s
                  ? 5131
                  : ((n = e.get("OES_texture_half_float")),
                    null !== n ? n.HALF_FLOAT_OES : null);
              if (1021 === t) return 6406;
              if (t === _) return 6407;
              if (t === b) return 6408;
              if (1024 === t) return 6409;
              if (1025 === t) return 6410;
              if (t === M) return 6402;
              if (t === S) return 34041;
              if (1028 === t) return 6403;
              if (1029 === t) return 36244;
              if (1030 === t) return 33319;
              if (1031 === t) return 33320;
              if (1032 === t) return 36248;
              if (1033 === t) return 36249;
              if (33776 === t || 33777 === t || 33778 === t || 33779 === t) {
                if (((n = e.get("WEBGL_compressed_texture_s3tc")), null === n))
                  return null;
                if (33776 === t) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (33777 === t) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (33778 === t) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (33779 === t) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;
              }
              if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
                if (((n = e.get("WEBGL_compressed_texture_pvrtc")), null === n))
                  return null;
                if (35840 === t) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (35841 === t) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (35842 === t) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (35843 === t) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
              }
              if (36196 === t)
                return (
                  (n = e.get("WEBGL_compressed_texture_etc1")),
                  null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null
                );
              if (
                (37492 === t || 37496 === t) &&
                ((n = e.get("WEBGL_compressed_texture_etc")), null !== n)
              ) {
                if (37492 === t) return n.COMPRESSED_RGB8_ETC2;
                if (37496 === t) return n.COMPRESSED_RGBA8_ETC2_EAC;
              }
              return 37808 === t ||
                37809 === t ||
                37810 === t ||
                37811 === t ||
                37812 === t ||
                37813 === t ||
                37814 === t ||
                37815 === t ||
                37816 === t ||
                37817 === t ||
                37818 === t ||
                37819 === t ||
                37820 === t ||
                37821 === t ||
                37840 === t ||
                37841 === t ||
                37842 === t ||
                37843 === t ||
                37844 === t ||
                37845 === t ||
                37846 === t ||
                37847 === t ||
                37848 === t ||
                37849 === t ||
                37850 === t ||
                37851 === t ||
                37852 === t ||
                37853 === t
                ? ((n = e.get("WEBGL_compressed_texture_astc")),
                  null !== n ? t : null)
                : 36492 === t
                ? ((n = e.get("EXT_texture_compression_bptc")),
                  null !== n ? t : null)
                : t === w
                ? s
                  ? 34042
                  : ((n = e.get("WEBGL_depth_texture")),
                    null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null)
                : void 0;
            },
          };
        }
        cr.prototype.isMeshDistanceMaterial = !0;
        class fr extends Mn {
          constructor(t = []) {
            super(), (this.cameras = t);
          }
        }
        fr.prototype.isArrayCamera = !0;
        class mr extends pe {
          constructor() {
            super(), (this.type = "Group");
          }
        }
        mr.prototype.isGroup = !0;
        const pr = { type: "move" };
        class gr {
          constructor() {
            (this._targetRay = null), (this._grip = null), (this._hand = null);
          }
          getHandSpace() {
            return (
              null === this._hand &&
                ((this._hand = new mr()),
                (this._hand.matrixAutoUpdate = !1),
                (this._hand.visible = !1),
                (this._hand.joints = {}),
                (this._hand.inputState = { pinching: !1 })),
              this._hand
            );
          }
          getTargetRaySpace() {
            return (
              null === this._targetRay &&
                ((this._targetRay = new mr()),
                (this._targetRay.matrixAutoUpdate = !1),
                (this._targetRay.visible = !1),
                (this._targetRay.hasLinearVelocity = !1),
                (this._targetRay.linearVelocity = new ft()),
                (this._targetRay.hasAngularVelocity = !1),
                (this._targetRay.angularVelocity = new ft())),
              this._targetRay
            );
          }
          getGripSpace() {
            return (
              null === this._grip &&
                ((this._grip = new mr()),
                (this._grip.matrixAutoUpdate = !1),
                (this._grip.visible = !1),
                (this._grip.hasLinearVelocity = !1),
                (this._grip.linearVelocity = new ft()),
                (this._grip.hasAngularVelocity = !1),
                (this._grip.angularVelocity = new ft())),
              this._grip
            );
          }
          dispatchEvent(t) {
            return (
              null !== this._targetRay && this._targetRay.dispatchEvent(t),
              null !== this._grip && this._grip.dispatchEvent(t),
              null !== this._hand && this._hand.dispatchEvent(t),
              this
            );
          }
          disconnect(t) {
            return (
              this.dispatchEvent({ type: "disconnected", data: t }),
              null !== this._targetRay && (this._targetRay.visible = !1),
              null !== this._grip && (this._grip.visible = !1),
              null !== this._hand && (this._hand.visible = !1),
              this
            );
          }
          update(t, e, n) {
            let s = null,
              i = null,
              r = null;
            const o = this._targetRay,
              a = this._grip,
              c = this._hand;
            if (t && "visible-blurred" !== e.session.visibilityState)
              if (
                (null !== o &&
                  ((s = e.getPose(t.targetRaySpace, n)),
                  null !== s &&
                    (o.matrix.fromArray(s.transform.matrix),
                    o.matrix.decompose(o.position, o.rotation, o.scale),
                    s.linearVelocity
                      ? ((o.hasLinearVelocity = !0),
                        o.linearVelocity.copy(s.linearVelocity))
                      : (o.hasLinearVelocity = !1),
                    s.angularVelocity
                      ? ((o.hasAngularVelocity = !0),
                        o.angularVelocity.copy(s.angularVelocity))
                      : (o.hasAngularVelocity = !1),
                    this.dispatchEvent(pr))),
                c && t.hand)
              ) {
                r = !0;
                for (const s of t.hand.values()) {
                  const t = e.getJointPose(s, n);
                  if (void 0 === c.joints[s.jointName]) {
                    const t = new mr();
                    (t.matrixAutoUpdate = !1),
                      (t.visible = !1),
                      (c.joints[s.jointName] = t),
                      c.add(t);
                  }
                  const i = c.joints[s.jointName];
                  null !== t &&
                    (i.matrix.fromArray(t.transform.matrix),
                    i.matrix.decompose(i.position, i.rotation, i.scale),
                    (i.jointRadius = t.radius)),
                    (i.visible = null !== t);
                }
                const s = c.joints["index-finger-tip"],
                  i = c.joints["thumb-tip"],
                  o = s.position.distanceTo(i.position),
                  a = 0.02,
                  u = 0.005;
                c.inputState.pinching && o > a + u
                  ? ((c.inputState.pinching = !1),
                    this.dispatchEvent({
                      type: "pinchend",
                      handedness: t.handedness,
                      target: this,
                    }))
                  : !c.inputState.pinching &&
                    o <= a - u &&
                    ((c.inputState.pinching = !0),
                    this.dispatchEvent({
                      type: "pinchstart",
                      handedness: t.handedness,
                      target: this,
                    }));
              } else
                null !== a &&
                  t.gripSpace &&
                  ((i = e.getPose(t.gripSpace, n)),
                  null !== i &&
                    (a.matrix.fromArray(i.transform.matrix),
                    a.matrix.decompose(a.position, a.rotation, a.scale),
                    i.linearVelocity
                      ? ((a.hasLinearVelocity = !0),
                        a.linearVelocity.copy(i.linearVelocity))
                      : (a.hasLinearVelocity = !1),
                    i.angularVelocity
                      ? ((a.hasAngularVelocity = !0),
                        a.angularVelocity.copy(i.angularVelocity))
                      : (a.hasAngularVelocity = !1)));
            return (
              null !== o && (o.visible = null !== s),
              null !== a && (a.visible = null !== i),
              null !== c && (c.visible = null !== r),
              this
            );
          }
        }
        class xr extends F {
          constructor(t, e) {
            super();
            const n = this,
              s = t.state;
            let i = null,
              r = 1,
              o = null,
              a = "local-floor",
              c = null,
              u = null,
              d = null,
              l = null,
              h = null,
              f = !1,
              m = null,
              p = null,
              g = null,
              x = null,
              v = null,
              y = null;
            const w = [],
              _ = new Map(),
              b = new Mn();
            b.layers.enable(1), (b.viewport = new ut());
            const M = new Mn();
            M.layers.enable(2), (M.viewport = new ut());
            const S = [b, M],
              T = new fr();
            T.layers.enable(1), T.layers.enable(2);
            let E = null,
              C = null;
            function A(t) {
              const e = _.get(t.inputSource);
              e && e.dispatchEvent({ type: t.type, data: t.inputSource });
            }
            function L() {
              _.forEach(function (t, e) {
                t.disconnect(e);
              }),
                _.clear(),
                (E = null),
                (C = null),
                s.bindXRFramebuffer(null),
                t.setRenderTarget(t.getRenderTarget()),
                d && e.deleteFramebuffer(d),
                m && e.deleteFramebuffer(m),
                p && e.deleteRenderbuffer(p),
                g && e.deleteRenderbuffer(g),
                (d = null),
                (m = null),
                (p = null),
                (g = null),
                (h = null),
                (l = null),
                (u = null),
                (i = null),
                O.stop(),
                (n.isPresenting = !1),
                n.dispatchEvent({ type: "sessionend" });
            }
            function R(t) {
              const e = i.inputSources;
              for (let t = 0; t < w.length; t++) _.set(e[t], w[t]);
              for (let e = 0; e < t.removed.length; e++) {
                const n = t.removed[e],
                  s = _.get(n);
                s &&
                  (s.dispatchEvent({ type: "disconnected", data: n }),
                  _.delete(n));
              }
              for (let e = 0; e < t.added.length; e++) {
                const n = t.added[e],
                  s = _.get(n);
                s && s.dispatchEvent({ type: "connected", data: n });
              }
            }
            (this.cameraAutoUpdate = !0),
              (this.enabled = !1),
              (this.isPresenting = !1),
              (this.getController = function (t) {
                let e = w[t];
                return (
                  void 0 === e && ((e = new gr()), (w[t] = e)),
                  e.getTargetRaySpace()
                );
              }),
              (this.getControllerGrip = function (t) {
                let e = w[t];
                return (
                  void 0 === e && ((e = new gr()), (w[t] = e)), e.getGripSpace()
                );
              }),
              (this.getHand = function (t) {
                let e = w[t];
                return (
                  void 0 === e && ((e = new gr()), (w[t] = e)), e.getHandSpace()
                );
              }),
              (this.setFramebufferScaleFactor = function (t) {
                (r = t),
                  !0 === n.isPresenting &&
                    console.warn(
                      "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                    );
              }),
              (this.setReferenceSpaceType = function (t) {
                (a = t),
                  !0 === n.isPresenting &&
                    console.warn(
                      "THREE.WebXRManager: Cannot change reference space type while presenting."
                    );
              }),
              (this.getReferenceSpace = function () {
                return o;
              }),
              (this.getBaseLayer = function () {
                return null !== l ? l : h;
              }),
              (this.getBinding = function () {
                return u;
              }),
              (this.getFrame = function () {
                return x;
              }),
              (this.getSession = function () {
                return i;
              }),
              (this.setSession = async function (t) {
                if (((i = t), null !== i)) {
                  i.addEventListener("select", A),
                    i.addEventListener("selectstart", A),
                    i.addEventListener("selectend", A),
                    i.addEventListener("squeeze", A),
                    i.addEventListener("squeezestart", A),
                    i.addEventListener("squeezeend", A),
                    i.addEventListener("end", L),
                    i.addEventListener("inputsourceschange", R);
                  const t = e.getContextAttributes();
                  if (
                    (!0 !== t.xrCompatible && (await e.makeXRCompatible()),
                    void 0 === i.renderState.layers)
                  ) {
                    const n = {
                      antialias: t.antialias,
                      alpha: t.alpha,
                      depth: t.depth,
                      stencil: t.stencil,
                      framebufferScaleFactor: r,
                    };
                    (h = new XRWebGLLayer(i, e, n)),
                      i.updateRenderState({ baseLayer: h });
                  } else if (e instanceof WebGLRenderingContext) {
                    const n = {
                      antialias: !0,
                      alpha: t.alpha,
                      depth: t.depth,
                      stencil: t.stencil,
                      framebufferScaleFactor: r,
                    };
                    (h = new XRWebGLLayer(i, e, n)),
                      i.updateRenderState({ layers: [h] });
                  } else {
                    f = t.antialias;
                    let n = null;
                    t.depth &&
                      ((y = 256),
                      t.stencil && (y |= 1024),
                      (v = t.stencil ? 33306 : 36096),
                      (n = t.stencil ? 35056 : 33190));
                    const o = {
                      colorFormat: t.alpha ? 32856 : 32849,
                      depthFormat: n,
                      scaleFactor: r,
                    };
                    (u = new XRWebGLBinding(i, e)),
                      (l = u.createProjectionLayer(o)),
                      (d = e.createFramebuffer()),
                      i.updateRenderState({ layers: [l] }),
                      f &&
                        ((m = e.createFramebuffer()),
                        (p = e.createRenderbuffer()),
                        e.bindRenderbuffer(36161, p),
                        e.renderbufferStorageMultisample(
                          36161,
                          4,
                          32856,
                          l.textureWidth,
                          l.textureHeight
                        ),
                        s.bindFramebuffer(36160, m),
                        e.framebufferRenderbuffer(36160, 36064, 36161, p),
                        e.bindRenderbuffer(36161, null),
                        null !== n &&
                          ((g = e.createRenderbuffer()),
                          e.bindRenderbuffer(36161, g),
                          e.renderbufferStorageMultisample(
                            36161,
                            4,
                            n,
                            l.textureWidth,
                            l.textureHeight
                          ),
                          e.framebufferRenderbuffer(36160, v, 36161, g),
                          e.bindRenderbuffer(36161, null)),
                        s.bindFramebuffer(36160, null));
                  }
                  (o = await i.requestReferenceSpace(a)),
                    O.setContext(i),
                    O.start(),
                    (n.isPresenting = !0),
                    n.dispatchEvent({ type: "sessionstart" });
                }
              });
            const P = new ft(),
              I = new ft();
            function D(t, e) {
              null === e
                ? t.matrixWorld.copy(t.matrix)
                : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
                t.matrixWorldInverse.copy(t.matrixWorld).invert();
            }
            (this.updateCamera = function (t) {
              if (null === i) return;
              (T.near = M.near = b.near = t.near),
                (T.far = M.far = b.far = t.far),
                (E === T.near && C === T.far) ||
                  (i.updateRenderState({ depthNear: T.near, depthFar: T.far }),
                  (E = T.near),
                  (C = T.far));
              const e = t.parent,
                n = T.cameras;
              D(T, e);
              for (let t = 0; t < n.length; t++) D(n[t], e);
              T.matrixWorld.decompose(T.position, T.quaternion, T.scale),
                t.position.copy(T.position),
                t.quaternion.copy(T.quaternion),
                t.scale.copy(T.scale),
                t.matrix.copy(T.matrix),
                t.matrixWorld.copy(T.matrixWorld);
              const s = t.children;
              for (let t = 0, e = s.length; t < e; t++)
                s[t].updateMatrixWorld(!0);
              2 === n.length
                ? (function (t, e, n) {
                    P.setFromMatrixPosition(e.matrixWorld),
                      I.setFromMatrixPosition(n.matrixWorld);
                    const s = P.distanceTo(I),
                      i = e.projectionMatrix.elements,
                      r = n.projectionMatrix.elements,
                      o = i[14] / (i[10] - 1),
                      a = i[14] / (i[10] + 1),
                      c = (i[9] + 1) / i[5],
                      u = (i[9] - 1) / i[5],
                      d = (i[8] - 1) / i[0],
                      l = (r[8] + 1) / r[0],
                      h = o * d,
                      f = o * l,
                      m = s / (-d + l),
                      p = m * -d;
                    e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                      t.translateX(p),
                      t.translateZ(m),
                      t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                      t.matrixWorldInverse.copy(t.matrixWorld).invert();
                    const g = o + m,
                      x = a + m,
                      v = h - p,
                      y = f + (s - p),
                      w = ((c * a) / x) * g,
                      _ = ((u * a) / x) * g;
                    t.projectionMatrix.makePerspective(v, y, w, _, g, x);
                  })(T, b, M)
                : T.projectionMatrix.copy(b.projectionMatrix);
            }),
              (this.getCamera = function () {
                return T;
              }),
              (this.getFoveation = function () {
                return null !== l
                  ? l.fixedFoveation
                  : null !== h
                  ? h.fixedFoveation
                  : void 0;
              }),
              (this.setFoveation = function (t) {
                null !== l && (l.fixedFoveation = t),
                  null !== h &&
                    void 0 !== h.fixedFoveation &&
                    (h.fixedFoveation = t);
              });
            let N = null;
            const O = new On();
            O.setAnimationLoop(function (t, n) {
              if (((c = n.getViewerPose(o)), (x = n), null !== c)) {
                const t = c.views;
                null !== h && s.bindXRFramebuffer(h.framebuffer);
                let n = !1;
                t.length !== T.cameras.length &&
                  ((T.cameras.length = 0), (n = !0));
                for (let i = 0; i < t.length; i++) {
                  const r = t[i];
                  let o = null;
                  if (null !== h) o = h.getViewport(r);
                  else {
                    const t = u.getViewSubImage(l, r);
                    s.bindXRFramebuffer(d),
                      void 0 !== t.depthStencilTexture &&
                        e.framebufferTexture2D(
                          36160,
                          v,
                          3553,
                          t.depthStencilTexture,
                          0
                        ),
                      e.framebufferTexture2D(
                        36160,
                        36064,
                        3553,
                        t.colorTexture,
                        0
                      ),
                      (o = t.viewport);
                  }
                  const a = S[i];
                  a.matrix.fromArray(r.transform.matrix),
                    a.projectionMatrix.fromArray(r.projectionMatrix),
                    a.viewport.set(o.x, o.y, o.width, o.height),
                    0 === i && T.matrix.copy(a.matrix),
                    !0 === n && T.cameras.push(a);
                }
                f && (s.bindXRFramebuffer(m), null !== y && e.clear(y));
              }
              const r = i.inputSources;
              for (let t = 0; t < w.length; t++) {
                const e = w[t],
                  s = r[t];
                e.update(s, n, o);
              }
              if ((N && N(t, n), f)) {
                const t = l.textureWidth,
                  n = l.textureHeight;
                s.bindFramebuffer(36008, m),
                  s.bindFramebuffer(36009, d),
                  e.invalidateFramebuffer(36008, [v]),
                  e.invalidateFramebuffer(36009, [v]),
                  e.blitFramebuffer(0, 0, t, n, 0, 0, t, n, 16384, 9728),
                  e.invalidateFramebuffer(36008, [36064]),
                  s.bindFramebuffer(36008, null),
                  s.bindFramebuffer(36009, null),
                  s.bindFramebuffer(36160, m);
              }
              x = null;
            }),
              (this.setAnimationLoop = function (t) {
                N = t;
              }),
              (this.dispose = function () {});
          }
        }
        function vr(t) {
          function e(e, n) {
            (e.opacity.value = n.opacity),
              n.color && e.diffuse.value.copy(n.color),
              n.emissive &&
                e.emissive.value
                  .copy(n.emissive)
                  .multiplyScalar(n.emissiveIntensity),
              n.map && (e.map.value = n.map),
              n.alphaMap && (e.alphaMap.value = n.alphaMap),
              n.specularMap && (e.specularMap.value = n.specularMap),
              n.alphaTest > 0 && (e.alphaTest.value = n.alphaTest);
            const s = t.get(n).envMap;
            if (s) {
              (e.envMap.value = s),
                (e.flipEnvMap.value =
                  s.isCubeTexture && !1 === s.isRenderTargetTexture ? -1 : 1),
                (e.reflectivity.value = n.reflectivity),
                (e.ior.value = n.ior),
                (e.refractionRatio.value = n.refractionRatio);
              const i = t.get(s).__maxMipLevel;
              void 0 !== i && (e.maxMipLevel.value = i);
            }
            let i, r;
            n.lightMap &&
              ((e.lightMap.value = n.lightMap),
              (e.lightMapIntensity.value = n.lightMapIntensity)),
              n.aoMap &&
                ((e.aoMap.value = n.aoMap),
                (e.aoMapIntensity.value = n.aoMapIntensity)),
              n.map
                ? (i = n.map)
                : n.specularMap
                ? (i = n.specularMap)
                : n.displacementMap
                ? (i = n.displacementMap)
                : n.normalMap
                ? (i = n.normalMap)
                : n.bumpMap
                ? (i = n.bumpMap)
                : n.roughnessMap
                ? (i = n.roughnessMap)
                : n.metalnessMap
                ? (i = n.metalnessMap)
                : n.alphaMap
                ? (i = n.alphaMap)
                : n.emissiveMap
                ? (i = n.emissiveMap)
                : n.clearcoatMap
                ? (i = n.clearcoatMap)
                : n.clearcoatNormalMap
                ? (i = n.clearcoatNormalMap)
                : n.clearcoatRoughnessMap
                ? (i = n.clearcoatRoughnessMap)
                : n.specularIntensityMap
                ? (i = n.specularIntensityMap)
                : n.specularColorMap
                ? (i = n.specularColorMap)
                : n.transmissionMap
                ? (i = n.transmissionMap)
                : n.thicknessMap
                ? (i = n.thicknessMap)
                : n.sheenColorMap
                ? (i = n.sheenColorMap)
                : n.sheenRoughnessMap && (i = n.sheenRoughnessMap),
              void 0 !== i &&
                (i.isWebGLRenderTarget && (i = i.texture),
                !0 === i.matrixAutoUpdate && i.updateMatrix(),
                e.uvTransform.value.copy(i.matrix)),
              n.aoMap ? (r = n.aoMap) : n.lightMap && (r = n.lightMap),
              void 0 !== r &&
                (r.isWebGLRenderTarget && (r = r.texture),
                !0 === r.matrixAutoUpdate && r.updateMatrix(),
                e.uv2Transform.value.copy(r.matrix));
          }
          function n(e, n) {
            (e.roughness.value = n.roughness),
              (e.metalness.value = n.metalness),
              n.roughnessMap && (e.roughnessMap.value = n.roughnessMap),
              n.metalnessMap && (e.metalnessMap.value = n.metalnessMap),
              n.emissiveMap && (e.emissiveMap.value = n.emissiveMap),
              n.bumpMap &&
                ((e.bumpMap.value = n.bumpMap),
                (e.bumpScale.value = n.bumpScale),
                1 === n.side && (e.bumpScale.value *= -1)),
              n.normalMap &&
                ((e.normalMap.value = n.normalMap),
                e.normalScale.value.copy(n.normalScale),
                1 === n.side && e.normalScale.value.negate()),
              n.displacementMap &&
                ((e.displacementMap.value = n.displacementMap),
                (e.displacementScale.value = n.displacementScale),
                (e.displacementBias.value = n.displacementBias)),
              t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity);
          }
          return {
            refreshFogUniforms: function (t, e) {
              t.fogColor.value.copy(e.color),
                e.isFog
                  ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
                  : e.isFogExp2 && (t.fogDensity.value = e.density);
            },
            refreshMaterialUniforms: function (t, s, i, r, o) {
              s.isMeshBasicMaterial
                ? e(t, s)
                : s.isMeshLambertMaterial
                ? (e(t, s),
                  (function (t, e) {
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                  })(t, s))
                : s.isMeshToonMaterial
                ? (e(t, s),
                  (function (t, e) {
                    e.gradientMap && (t.gradientMap.value = e.gradientMap),
                      e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                      e.bumpMap &&
                        ((t.bumpMap.value = e.bumpMap),
                        (t.bumpScale.value = e.bumpScale),
                        1 === e.side && (t.bumpScale.value *= -1)),
                      e.normalMap &&
                        ((t.normalMap.value = e.normalMap),
                        t.normalScale.value.copy(e.normalScale),
                        1 === e.side && t.normalScale.value.negate()),
                      e.displacementMap &&
                        ((t.displacementMap.value = e.displacementMap),
                        (t.displacementScale.value = e.displacementScale),
                        (t.displacementBias.value = e.displacementBias));
                  })(t, s))
                : s.isMeshPhongMaterial
                ? (e(t, s),
                  (function (t, e) {
                    t.specular.value.copy(e.specular),
                      (t.shininess.value = Math.max(e.shininess, 1e-4)),
                      e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                      e.bumpMap &&
                        ((t.bumpMap.value = e.bumpMap),
                        (t.bumpScale.value = e.bumpScale),
                        1 === e.side && (t.bumpScale.value *= -1)),
                      e.normalMap &&
                        ((t.normalMap.value = e.normalMap),
                        t.normalScale.value.copy(e.normalScale),
                        1 === e.side && t.normalScale.value.negate()),
                      e.displacementMap &&
                        ((t.displacementMap.value = e.displacementMap),
                        (t.displacementScale.value = e.displacementScale),
                        (t.displacementBias.value = e.displacementBias));
                  })(t, s))
                : s.isMeshStandardMaterial
                ? (e(t, s),
                  s.isMeshPhysicalMaterial
                    ? (function (t, e, s) {
                        n(t, e),
                          (t.ior.value = e.ior),
                          e.sheen > 0 &&
                            (t.sheenColor.value
                              .copy(e.sheenColor)
                              .multiplyScalar(e.sheen),
                            (t.sheenRoughness.value = e.sheenRoughness),
                            e.sheenColorMap &&
                              (t.sheenColorMap.value = e.sheenColorMap),
                            e.sheenRoughnessMap &&
                              (t.sheenRoughnessMap.value =
                                e.sheenRoughnessMap)),
                          e.clearcoat > 0 &&
                            ((t.clearcoat.value = e.clearcoat),
                            (t.clearcoatRoughness.value = e.clearcoatRoughness),
                            e.clearcoatMap &&
                              (t.clearcoatMap.value = e.clearcoatMap),
                            e.clearcoatRoughnessMap &&
                              (t.clearcoatRoughnessMap.value =
                                e.clearcoatRoughnessMap),
                            e.clearcoatNormalMap &&
                              (t.clearcoatNormalScale.value.copy(
                                e.clearcoatNormalScale
                              ),
                              (t.clearcoatNormalMap.value =
                                e.clearcoatNormalMap),
                              1 === e.side &&
                                t.clearcoatNormalScale.value.negate())),
                          e.transmission > 0 &&
                            ((t.transmission.value = e.transmission),
                            (t.transmissionSamplerMap.value = s.texture),
                            t.transmissionSamplerSize.value.set(
                              s.width,
                              s.height
                            ),
                            e.transmissionMap &&
                              (t.transmissionMap.value = e.transmissionMap),
                            (t.thickness.value = e.thickness),
                            e.thicknessMap &&
                              (t.thicknessMap.value = e.thicknessMap),
                            (t.attenuationDistance.value =
                              e.attenuationDistance),
                            t.attenuationColor.value.copy(e.attenuationColor)),
                          (t.specularIntensity.value = e.specularIntensity),
                          t.specularColor.value.copy(e.specularColor),
                          e.specularIntensityMap &&
                            (t.specularIntensityMap.value =
                              e.specularIntensityMap),
                          e.specularColorMap &&
                            (t.specularColorMap.value = e.specularColorMap);
                      })(t, s, o)
                    : n(t, s))
                : s.isMeshMatcapMaterial
                ? (e(t, s),
                  (function (t, e) {
                    e.matcap && (t.matcap.value = e.matcap),
                      e.bumpMap &&
                        ((t.bumpMap.value = e.bumpMap),
                        (t.bumpScale.value = e.bumpScale),
                        1 === e.side && (t.bumpScale.value *= -1)),
                      e.normalMap &&
                        ((t.normalMap.value = e.normalMap),
                        t.normalScale.value.copy(e.normalScale),
                        1 === e.side && t.normalScale.value.negate()),
                      e.displacementMap &&
                        ((t.displacementMap.value = e.displacementMap),
                        (t.displacementScale.value = e.displacementScale),
                        (t.displacementBias.value = e.displacementBias));
                  })(t, s))
                : s.isMeshDepthMaterial
                ? (e(t, s),
                  (function (t, e) {
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias));
                  })(t, s))
                : s.isMeshDistanceMaterial
                ? (e(t, s),
                  (function (t, e) {
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias)),
                      t.referencePosition.value.copy(e.referencePosition),
                      (t.nearDistance.value = e.nearDistance),
                      (t.farDistance.value = e.farDistance);
                  })(t, s))
                : s.isMeshNormalMaterial
                ? (e(t, s),
                  (function (t, e) {
                    e.bumpMap &&
                      ((t.bumpMap.value = e.bumpMap),
                      (t.bumpScale.value = e.bumpScale),
                      1 === e.side && (t.bumpScale.value *= -1)),
                      e.normalMap &&
                        ((t.normalMap.value = e.normalMap),
                        t.normalScale.value.copy(e.normalScale),
                        1 === e.side && t.normalScale.value.negate()),
                      e.displacementMap &&
                        ((t.displacementMap.value = e.displacementMap),
                        (t.displacementScale.value = e.displacementScale),
                        (t.displacementBias.value = e.displacementBias));
                  })(t, s))
                : s.isLineBasicMaterial
                ? ((function (t, e) {
                    t.diffuse.value.copy(e.color),
                      (t.opacity.value = e.opacity);
                  })(t, s),
                  s.isLineDashedMaterial &&
                    (function (t, e) {
                      (t.dashSize.value = e.dashSize),
                        (t.totalSize.value = e.dashSize + e.gapSize),
                        (t.scale.value = e.scale);
                    })(t, s))
                : s.isPointsMaterial
                ? (function (t, e, n, s) {
                    let i;
                    t.diffuse.value.copy(e.color),
                      (t.opacity.value = e.opacity),
                      (t.size.value = e.size * n),
                      (t.scale.value = 0.5 * s),
                      e.map && (t.map.value = e.map),
                      e.alphaMap && (t.alphaMap.value = e.alphaMap),
                      e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest),
                      e.map ? (i = e.map) : e.alphaMap && (i = e.alphaMap),
                      void 0 !== i &&
                        (!0 === i.matrixAutoUpdate && i.updateMatrix(),
                        t.uvTransform.value.copy(i.matrix));
                  })(t, s, i, r)
                : s.isSpriteMaterial
                ? (function (t, e) {
                    let n;
                    t.diffuse.value.copy(e.color),
                      (t.opacity.value = e.opacity),
                      (t.rotation.value = e.rotation),
                      e.map && (t.map.value = e.map),
                      e.alphaMap && (t.alphaMap.value = e.alphaMap),
                      e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest),
                      e.map ? (n = e.map) : e.alphaMap && (n = e.alphaMap),
                      void 0 !== n &&
                        (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                        t.uvTransform.value.copy(n.matrix));
                  })(t, s)
                : s.isShadowMaterial
                ? (t.color.value.copy(s.color), (t.opacity.value = s.opacity))
                : s.isShaderMaterial && (s.uniformsNeedUpdate = !1);
            },
          };
        }
        function yr(t = {}) {
          const e =
              void 0 !== t.canvas
                ? t.canvas
                : (function () {
                    const t = nt("canvas");
                    return (t.style.display = "block"), t;
                  })(),
            n = void 0 !== t.context ? t.context : null,
            s = void 0 !== t.alpha && t.alpha,
            i = void 0 === t.depth || t.depth,
            r = void 0 === t.stencil || t.stencil,
            o = void 0 !== t.antialias && t.antialias,
            a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
            u = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
            l = void 0 !== t.powerPreference ? t.powerPreference : "default",
            h =
              void 0 !== t.failIfMajorPerformanceCaveat &&
              t.failIfMajorPerformanceCaveat;
          let f = null,
            g = null;
          const x = [],
            w = [];
          (this.domElement = e),
            (this.debug = { checkShaderErrors: !0 }),
            (this.autoClear = !0),
            (this.autoClearColor = !0),
            (this.autoClearDepth = !0),
            (this.autoClearStencil = !0),
            (this.sortObjects = !0),
            (this.clippingPlanes = []),
            (this.localClippingEnabled = !1),
            (this.gammaFactor = 2),
            (this.outputEncoding = P),
            (this.physicallyCorrectLights = !1),
            (this.toneMapping = 0),
            (this.toneMappingExposure = 1);
          const _ = this;
          let M = !1,
            S = 0,
            T = 0,
            E = null,
            C = -1,
            A = null;
          const L = new ut(),
            R = new ut();
          let I = null,
            D = e.width,
            N = e.height,
            O = 1,
            k = null,
            U = null;
          const z = new ut(0, 0, D, N),
            F = new ut(0, 0, D, N);
          let B = !1;
          const H = [],
            G = new Nn();
          let V = !1,
            W = !1,
            j = null;
          const X = new Wt(),
            q = new ft(),
            Y = {
              background: null,
              fog: null,
              environment: null,
              overrideMaterial: null,
              isScene: !0,
            };
          function J() {
            return null === E ? O : 1;
          }
          let Z,
            $,
            K,
            Q,
            tt,
            et,
            st,
            it,
            rt,
            ot,
            at,
            ct,
            ht,
            mt,
            pt,
            gt,
            xt,
            vt,
            yt,
            wt,
            _t,
            bt,
            Mt,
            St = n;
          function Tt(t, n) {
            for (let s = 0; s < t.length; s++) {
              const i = t[s],
                r = e.getContext(i, n);
              if (null !== r) return r;
            }
            return null;
          }
          try {
            const t = {
              alpha: s,
              depth: i,
              stencil: r,
              antialias: o,
              premultipliedAlpha: a,
              preserveDrawingBuffer: u,
              powerPreference: l,
              failIfMajorPerformanceCaveat: h,
            };
            if (
              (e.addEventListener("webglcontextlost", At, !1),
              e.addEventListener("webglcontextrestored", Lt, !1),
              null === St)
            ) {
              const e = ["webgl2", "webgl", "experimental-webgl"];
              if (
                (!0 === _.isWebGL1Renderer && e.shift(),
                (St = Tt(e, t)),
                null === St)
              )
                throw Tt(e)
                  ? new Error(
                      "Error creating WebGL context with your selected attributes."
                    )
                  : new Error("Error creating WebGL context.");
            }
            void 0 === St.getShaderPrecisionFormat &&
              (St.getShaderPrecisionFormat = function () {
                return { rangeMin: 1, rangeMax: 1, precision: 1 };
              });
          } catch (t) {
            throw (console.error("THREE.WebGLRenderer: " + t.message), t);
          }
          function Et() {
            (Z = new gs(St)),
              ($ = new Wn(St, Z, t)),
              Z.init($),
              (bt = new hr(St, Z, $)),
              (K = new dr(St, Z, $)),
              (H[0] = 1029),
              (Q = new ys(St)),
              (tt = new Zi()),
              (et = new lr(St, Z, K, tt, $, bt, Q)),
              (st = new Xn(_)),
              (it = new ps(_)),
              (rt = new kn(St, $)),
              (Mt = new Gn(St, Z, rt, $)),
              (ot = new xs(St, rt, Q, Mt)),
              (at = new Ts(St, ot, rt, Q)),
              (yt = new Ss(St, $, et)),
              (gt = new jn(tt)),
              (ct = new Ji(_, st, it, Z, $, Mt, gt)),
              (ht = new vr(tt)),
              (mt = new tr(tt)),
              (pt = new or(Z, $)),
              (vt = new Hn(_, st, K, at, a)),
              (xt = new ur(_, at, $)),
              (wt = new Vn(St, Z, Q, $)),
              (_t = new vs(St, Z, Q, $)),
              (Q.programs = ct.programs),
              (_.capabilities = $),
              (_.extensions = Z),
              (_.properties = tt),
              (_.renderLists = mt),
              (_.shadowMap = xt),
              (_.state = K),
              (_.info = Q);
          }
          Et();
          const Ct = new xr(_, St);
          function At(t) {
            t.preventDefault(),
              console.log("THREE.WebGLRenderer: Context Lost."),
              (M = !0);
          }
          function Lt() {
            console.log("THREE.WebGLRenderer: Context Restored."), (M = !1);
            const t = Q.autoReset,
              e = xt.enabled,
              n = xt.autoUpdate,
              s = xt.needsUpdate,
              i = xt.type;
            Et(),
              (Q.autoReset = t),
              (xt.enabled = e),
              (xt.autoUpdate = n),
              (xt.needsUpdate = s),
              (xt.type = i);
          }
          function Rt(t) {
            const e = t.target;
            e.removeEventListener("dispose", Rt),
              (function (t) {
                (function (t) {
                  const e = tt.get(t).programs;
                  void 0 !== e &&
                    e.forEach(function (t) {
                      ct.releaseProgram(t);
                    });
                })(t),
                  tt.remove(t);
              })(e);
          }
          (this.xr = Ct),
            (this.getContext = function () {
              return St;
            }),
            (this.getContextAttributes = function () {
              return St.getContextAttributes();
            }),
            (this.forceContextLoss = function () {
              const t = Z.get("WEBGL_lose_context");
              t && t.loseContext();
            }),
            (this.forceContextRestore = function () {
              const t = Z.get("WEBGL_lose_context");
              t && t.restoreContext();
            }),
            (this.getPixelRatio = function () {
              return O;
            }),
            (this.setPixelRatio = function (t) {
              void 0 !== t && ((O = t), this.setSize(D, N, !1));
            }),
            (this.getSize = function (t) {
              return t.set(D, N);
            }),
            (this.setSize = function (t, n, s) {
              Ct.isPresenting
                ? console.warn(
                    "THREE.WebGLRenderer: Can't change size while VR device is presenting."
                  )
                : ((D = t),
                  (N = n),
                  (e.width = Math.floor(t * O)),
                  (e.height = Math.floor(n * O)),
                  !1 !== s &&
                    ((e.style.width = t + "px"), (e.style.height = n + "px")),
                  this.setViewport(0, 0, t, n));
            }),
            (this.getDrawingBufferSize = function (t) {
              return t.set(D * O, N * O).floor();
            }),
            (this.setDrawingBufferSize = function (t, n, s) {
              (D = t),
                (N = n),
                (O = s),
                (e.width = Math.floor(t * s)),
                (e.height = Math.floor(n * s)),
                this.setViewport(0, 0, t, n);
            }),
            (this.getCurrentViewport = function (t) {
              return t.copy(L);
            }),
            (this.getViewport = function (t) {
              return t.copy(z);
            }),
            (this.setViewport = function (t, e, n, s) {
              t.isVector4 ? z.set(t.x, t.y, t.z, t.w) : z.set(t, e, n, s),
                K.viewport(L.copy(z).multiplyScalar(O).floor());
            }),
            (this.getScissor = function (t) {
              return t.copy(F);
            }),
            (this.setScissor = function (t, e, n, s) {
              t.isVector4 ? F.set(t.x, t.y, t.z, t.w) : F.set(t, e, n, s),
                K.scissor(R.copy(F).multiplyScalar(O).floor());
            }),
            (this.getScissorTest = function () {
              return B;
            }),
            (this.setScissorTest = function (t) {
              K.setScissorTest((B = t));
            }),
            (this.setOpaqueSort = function (t) {
              k = t;
            }),
            (this.setTransparentSort = function (t) {
              U = t;
            }),
            (this.getClearColor = function (t) {
              return t.copy(vt.getClearColor());
            }),
            (this.setClearColor = function () {
              vt.setClearColor.apply(vt, arguments);
            }),
            (this.getClearAlpha = function () {
              return vt.getClearAlpha();
            }),
            (this.setClearAlpha = function () {
              vt.setClearAlpha.apply(vt, arguments);
            }),
            (this.clear = function (t, e, n) {
              let s = 0;
              (void 0 === t || t) && (s |= 16384),
                (void 0 === e || e) && (s |= 256),
                (void 0 === n || n) && (s |= 1024),
                St.clear(s);
            }),
            (this.clearColor = function () {
              this.clear(!0, !1, !1);
            }),
            (this.clearDepth = function () {
              this.clear(!1, !0, !1);
            }),
            (this.clearStencil = function () {
              this.clear(!1, !1, !0);
            }),
            (this.dispose = function () {
              e.removeEventListener("webglcontextlost", At, !1),
                e.removeEventListener("webglcontextrestored", Lt, !1),
                mt.dispose(),
                pt.dispose(),
                tt.dispose(),
                st.dispose(),
                it.dispose(),
                at.dispose(),
                Mt.dispose(),
                Ct.dispose(),
                Ct.removeEventListener("sessionstart", It),
                Ct.removeEventListener("sessionend", Dt),
                j && (j.dispose(), (j = null)),
                Nt.stop();
            }),
            (this.renderBufferDirect = function (t, e, n, s, i, r) {
              null === e && (e = Y);
              const o = i.isMesh && i.matrixWorld.determinant() < 0,
                a = (function (t, e, n, s, i) {
                  !0 !== e.isScene && (e = Y), et.resetTextureUnits();
                  const r = e.fog,
                    o = s.isMeshStandardMaterial ? e.environment : null,
                    a = null === E ? _.outputEncoding : E.texture.encoding,
                    c = (s.isMeshStandardMaterial ? it : st).get(s.envMap || o),
                    u =
                      !0 === s.vertexColors &&
                      !!n.attributes.color &&
                      4 === n.attributes.color.itemSize,
                    d = !!s.normalMap && !!n.attributes.tangent,
                    l = !!n.morphAttributes.position,
                    h = !!n.morphAttributes.normal,
                    f = n.morphAttributes.position
                      ? n.morphAttributes.position.length
                      : 0,
                    m = tt.get(s),
                    p = g.state.lights;
                  if (!0 === V && (!0 === W || t !== A)) {
                    const e = t === A && s.id === C;
                    gt.setState(s, t, e);
                  }
                  let x = !1;
                  s.version === m.__version
                    ? (m.needsLights &&
                        m.lightsStateVersion !== p.state.version) ||
                      m.outputEncoding !== a ||
                      (i.isInstancedMesh && !1 === m.instancing)
                      ? (x = !0)
                      : i.isInstancedMesh || !0 !== m.instancing
                      ? i.isSkinnedMesh && !1 === m.skinning
                        ? (x = !0)
                        : i.isSkinnedMesh || !0 !== m.skinning
                        ? m.envMap !== c || (s.fog && m.fog !== r)
                          ? (x = !0)
                          : void 0 === m.numClippingPlanes ||
                            (m.numClippingPlanes === gt.numPlanes &&
                              m.numIntersection === gt.numIntersection)
                          ? (m.vertexAlphas !== u ||
                              m.vertexTangents !== d ||
                              m.morphTargets !== l ||
                              m.morphNormals !== h ||
                              (!0 === $.isWebGL2 &&
                                m.morphTargetsCount !== f)) &&
                            (x = !0)
                          : (x = !0)
                        : (x = !0)
                      : (x = !0)
                    : ((x = !0), (m.__version = s.version));
                  let v = m.currentProgram;
                  !0 === x && (v = Ft(s, e, i));
                  let y = !1,
                    w = !1,
                    b = !1;
                  const M = v.getUniforms(),
                    S = m.uniforms;
                  if (
                    (K.useProgram(v.program) && ((y = !0), (w = !0), (b = !0)),
                    s.id !== C && ((C = s.id), (w = !0)),
                    y || A !== t)
                  ) {
                    if (
                      (M.setValue(St, "projectionMatrix", t.projectionMatrix),
                      $.logarithmicDepthBuffer &&
                        M.setValue(
                          St,
                          "logDepthBufFC",
                          2 / (Math.log(t.far + 1) / Math.LN2)
                        ),
                      A !== t && ((A = t), (w = !0), (b = !0)),
                      s.isShaderMaterial ||
                        s.isMeshPhongMaterial ||
                        s.isMeshToonMaterial ||
                        s.isMeshStandardMaterial ||
                        s.envMap)
                    ) {
                      const e = M.map.cameraPosition;
                      void 0 !== e &&
                        e.setValue(St, q.setFromMatrixPosition(t.matrixWorld));
                    }
                    (s.isMeshPhongMaterial ||
                      s.isMeshToonMaterial ||
                      s.isMeshLambertMaterial ||
                      s.isMeshBasicMaterial ||
                      s.isMeshStandardMaterial ||
                      s.isShaderMaterial) &&
                      M.setValue(
                        St,
                        "isOrthographic",
                        !0 === t.isOrthographicCamera
                      ),
                      (s.isMeshPhongMaterial ||
                        s.isMeshToonMaterial ||
                        s.isMeshLambertMaterial ||
                        s.isMeshBasicMaterial ||
                        s.isMeshStandardMaterial ||
                        s.isShaderMaterial ||
                        s.isShadowMaterial ||
                        i.isSkinnedMesh) &&
                        M.setValue(St, "viewMatrix", t.matrixWorldInverse);
                  }
                  if (i.isSkinnedMesh) {
                    M.setOptional(St, i, "bindMatrix"),
                      M.setOptional(St, i, "bindMatrixInverse");
                    const t = i.skeleton;
                    t &&
                      ($.floatVertexTextures
                        ? (null === t.boneTexture && t.computeBoneTexture(),
                          M.setValue(St, "boneTexture", t.boneTexture, et),
                          M.setValue(St, "boneTextureSize", t.boneTextureSize))
                        : M.setOptional(St, t, "boneMatrices"));
                  }
                  var T, L;
                  return (
                    !n ||
                      (void 0 === n.morphAttributes.position &&
                        void 0 === n.morphAttributes.normal) ||
                      yt.update(i, n, s, v),
                    (w || m.receiveShadow !== i.receiveShadow) &&
                      ((m.receiveShadow = i.receiveShadow),
                      M.setValue(St, "receiveShadow", i.receiveShadow)),
                    w &&
                      (M.setValue(
                        St,
                        "toneMappingExposure",
                        _.toneMappingExposure
                      ),
                      m.needsLights &&
                        ((L = b),
                        ((T = S).ambientLightColor.needsUpdate = L),
                        (T.lightProbe.needsUpdate = L),
                        (T.directionalLights.needsUpdate = L),
                        (T.directionalLightShadows.needsUpdate = L),
                        (T.pointLights.needsUpdate = L),
                        (T.pointLightShadows.needsUpdate = L),
                        (T.spotLights.needsUpdate = L),
                        (T.spotLightShadows.needsUpdate = L),
                        (T.rectAreaLights.needsUpdate = L),
                        (T.hemisphereLights.needsUpdate = L)),
                      r && s.fog && ht.refreshFogUniforms(S, r),
                      ht.refreshMaterialUniforms(S, s, O, N, j),
                      Ai.upload(St, m.uniformsList, S, et)),
                    s.isShaderMaterial &&
                      !0 === s.uniformsNeedUpdate &&
                      (Ai.upload(St, m.uniformsList, S, et),
                      (s.uniformsNeedUpdate = !1)),
                    s.isSpriteMaterial && M.setValue(St, "center", i.center),
                    M.setValue(St, "modelViewMatrix", i.modelViewMatrix),
                    M.setValue(St, "normalMatrix", i.normalMatrix),
                    M.setValue(St, "modelMatrix", i.matrixWorld),
                    v
                  );
                })(t, e, n, s, i);
              K.setMaterial(s, o);
              let c = n.index;
              const u = n.attributes.position;
              if (null === c) {
                if (void 0 === u || 0 === u.count) return;
              } else if (0 === c.count) return;
              let d,
                l = 1;
              !0 === s.wireframe &&
                ((c = ot.getWireframeAttribute(n)), (l = 2)),
                Mt.setup(i, s, a, n, c);
              let h = wt;
              null !== c && ((d = rt.get(c)), (h = _t), h.setIndex(d));
              const f = null !== c ? c.count : u.count,
                m = n.drawRange.start * l,
                p = n.drawRange.count * l,
                x = null !== r ? r.start * l : 0,
                v = null !== r ? r.count * l : 1 / 0,
                y = Math.max(m, x),
                w = Math.min(f, m + p, x + v) - 1,
                b = Math.max(0, w - y + 1);
              if (0 !== b) {
                if (i.isMesh)
                  !0 === s.wireframe
                    ? (K.setLineWidth(s.wireframeLinewidth * J()), h.setMode(1))
                    : h.setMode(4);
                else if (i.isLine) {
                  let t = s.linewidth;
                  void 0 === t && (t = 1),
                    K.setLineWidth(t * J()),
                    i.isLineSegments
                      ? h.setMode(1)
                      : i.isLineLoop
                      ? h.setMode(2)
                      : h.setMode(3);
                } else i.isPoints ? h.setMode(0) : i.isSprite && h.setMode(4);
                if (i.isInstancedMesh) h.renderInstances(y, b, i.count);
                else if (n.isInstancedBufferGeometry) {
                  const t = Math.min(n.instanceCount, n._maxInstanceCount);
                  h.renderInstances(y, b, t);
                } else h.render(y, b);
              }
            }),
            (this.compile = function (t, e) {
              (g = pt.get(t)),
                g.init(),
                w.push(g),
                t.traverseVisible(function (t) {
                  t.isLight &&
                    t.layers.test(e.layers) &&
                    (g.pushLight(t), t.castShadow && g.pushShadow(t));
                }),
                g.setupLights(_.physicallyCorrectLights),
                t.traverse(function (e) {
                  const n = e.material;
                  if (n)
                    if (Array.isArray(n))
                      for (let s = 0; s < n.length; s++) Ft(n[s], t, e);
                    else Ft(n, t, e);
                }),
                w.pop(),
                (g = null);
            });
          let Pt = null;
          function It() {
            Nt.stop();
          }
          function Dt() {
            Nt.start();
          }
          const Nt = new On();
          function Ot(t, e, n, s) {
            if (!1 === t.visible) return;
            if (t.layers.test(e.layers))
              if (t.isGroup) n = t.renderOrder;
              else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
              else if (t.isLight)
                g.pushLight(t), t.castShadow && g.pushShadow(t);
              else if (t.isSprite) {
                if (!t.frustumCulled || G.intersectsSprite(t)) {
                  s && q.setFromMatrixPosition(t.matrixWorld).applyMatrix4(X);
                  const e = at.update(t),
                    i = t.material;
                  i.visible && f.push(t, e, i, n, q.z, null);
                }
              } else if (
                (t.isMesh || t.isLine || t.isPoints) &&
                (t.isSkinnedMesh &&
                  t.skeleton.frame !== Q.render.frame &&
                  (t.skeleton.update(), (t.skeleton.frame = Q.render.frame)),
                !t.frustumCulled || G.intersectsObject(t))
              ) {
                s && q.setFromMatrixPosition(t.matrixWorld).applyMatrix4(X);
                const e = at.update(t),
                  i = t.material;
                if (Array.isArray(i)) {
                  const s = e.groups;
                  for (let r = 0, o = s.length; r < o; r++) {
                    const o = s[r],
                      a = i[o.materialIndex];
                    a && a.visible && f.push(t, e, a, n, q.z, o);
                  }
                } else i.visible && f.push(t, e, i, n, q.z, null);
              }
            const i = t.children;
            for (let t = 0, r = i.length; t < r; t++) Ot(i[t], e, n, s);
          }
          function kt(t, e, n, s) {
            const i = t.opaque,
              r = t.transmissive,
              a = t.transparent;
            g.setupLightsView(n),
              r.length > 0 &&
                (function (t, e, n) {
                  if (null === j) {
                    const t = !0 === o && !0 === $.isWebGL2;
                    j = new (t ? lt : dt)(1024, 1024, {
                      generateMipmaps: !0,
                      type: null !== bt.convert(y) ? y : p,
                      minFilter: m,
                      magFilter: d,
                      wrapS: c,
                      wrapT: c,
                    });
                  }
                  const s = _.getRenderTarget();
                  _.setRenderTarget(j), _.clear();
                  const i = _.toneMapping;
                  (_.toneMapping = 0),
                    Ut(t, e, n),
                    (_.toneMapping = i),
                    et.updateMultisampleRenderTarget(j),
                    et.updateRenderTargetMipmap(j),
                    _.setRenderTarget(s);
                })(i, e, n),
              s && K.viewport(L.copy(s)),
              i.length > 0 && Ut(i, e, n),
              r.length > 0 && Ut(r, e, n),
              a.length > 0 && Ut(a, e, n);
          }
          function Ut(t, e, n) {
            const s = !0 === e.isScene ? e.overrideMaterial : null;
            for (let i = 0, r = t.length; i < r; i++) {
              const r = t[i],
                o = r.object,
                a = r.geometry,
                c = null === s ? r.material : s,
                u = r.group;
              o.layers.test(n.layers) && zt(o, e, n, a, c, u);
            }
          }
          function zt(t, e, n, s, i, r) {
            t.onBeforeRender(_, e, n, s, i, r),
              t.modelViewMatrix.multiplyMatrices(
                n.matrixWorldInverse,
                t.matrixWorld
              ),
              t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
              i.onBeforeRender(_, e, n, s, t, r),
              !0 === i.transparent && 2 === i.side
                ? ((i.side = 1),
                  (i.needsUpdate = !0),
                  _.renderBufferDirect(n, e, s, i, t, r),
                  (i.side = 0),
                  (i.needsUpdate = !0),
                  _.renderBufferDirect(n, e, s, i, t, r),
                  (i.side = 2))
                : _.renderBufferDirect(n, e, s, i, t, r),
              t.onAfterRender(_, e, n, s, i, r);
          }
          function Ft(t, e, n) {
            !0 !== e.isScene && (e = Y);
            const s = tt.get(t),
              i = g.state.lights,
              r = g.state.shadowsArray,
              o = i.state.version,
              a = ct.getParameters(t, i.state, r, e, n),
              c = ct.getProgramCacheKey(a);
            let u = s.programs;
            (s.environment = t.isMeshStandardMaterial ? e.environment : null),
              (s.fog = e.fog),
              (s.envMap = (t.isMeshStandardMaterial ? it : st).get(
                t.envMap || s.environment
              )),
              void 0 === u &&
                (t.addEventListener("dispose", Rt),
                (u = new Map()),
                (s.programs = u));
            let d = u.get(c);
            if (void 0 !== d) {
              if (s.currentProgram === d && s.lightsStateVersion === o)
                return Bt(t, a), d;
            } else
              (a.uniforms = ct.getUniforms(t)),
                t.onBuild(n, a, _),
                t.onBeforeCompile(a, _),
                (d = ct.acquireProgram(a, c)),
                u.set(c, d),
                (s.uniforms = a.uniforms);
            const l = s.uniforms;
            ((t.isShaderMaterial || t.isRawShaderMaterial) &&
              !0 !== t.clipping) ||
              (l.clippingPlanes = gt.uniform),
              Bt(t, a),
              (s.needsLights = (function (t) {
                return (
                  t.isMeshLambertMaterial ||
                  t.isMeshToonMaterial ||
                  t.isMeshPhongMaterial ||
                  t.isMeshStandardMaterial ||
                  t.isShadowMaterial ||
                  (t.isShaderMaterial && !0 === t.lights)
                );
              })(t)),
              (s.lightsStateVersion = o),
              s.needsLights &&
                ((l.ambientLightColor.value = i.state.ambient),
                (l.lightProbe.value = i.state.probe),
                (l.directionalLights.value = i.state.directional),
                (l.directionalLightShadows.value = i.state.directionalShadow),
                (l.spotLights.value = i.state.spot),
                (l.spotLightShadows.value = i.state.spotShadow),
                (l.rectAreaLights.value = i.state.rectArea),
                (l.ltc_1.value = i.state.rectAreaLTC1),
                (l.ltc_2.value = i.state.rectAreaLTC2),
                (l.pointLights.value = i.state.point),
                (l.pointLightShadows.value = i.state.pointShadow),
                (l.hemisphereLights.value = i.state.hemi),
                (l.directionalShadowMap.value = i.state.directionalShadowMap),
                (l.directionalShadowMatrix.value =
                  i.state.directionalShadowMatrix),
                (l.spotShadowMap.value = i.state.spotShadowMap),
                (l.spotShadowMatrix.value = i.state.spotShadowMatrix),
                (l.pointShadowMap.value = i.state.pointShadowMap),
                (l.pointShadowMatrix.value = i.state.pointShadowMatrix));
            const h = d.getUniforms(),
              f = Ai.seqWithValue(h.seq, l);
            return (s.currentProgram = d), (s.uniformsList = f), d;
          }
          function Bt(t, e) {
            const n = tt.get(t);
            (n.outputEncoding = e.outputEncoding),
              (n.instancing = e.instancing),
              (n.skinning = e.skinning),
              (n.morphTargets = e.morphTargets),
              (n.morphNormals = e.morphNormals),
              (n.morphTargetsCount = e.morphTargetsCount),
              (n.numClippingPlanes = e.numClippingPlanes),
              (n.numIntersection = e.numClipIntersection),
              (n.vertexAlphas = e.vertexAlphas),
              (n.vertexTangents = e.vertexTangents);
          }
          Nt.setAnimationLoop(function (t) {
            Pt && Pt(t);
          }),
            "undefined" != typeof window && Nt.setContext(window),
            (this.setAnimationLoop = function (t) {
              (Pt = t),
                Ct.setAnimationLoop(t),
                null === t ? Nt.stop() : Nt.start();
            }),
            Ct.addEventListener("sessionstart", It),
            Ct.addEventListener("sessionend", Dt),
            (this.render = function (t, e) {
              if (void 0 !== e && !0 !== e.isCamera)
                return void console.error(
                  "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
                );
              if (!0 === M) return;
              !0 === t.autoUpdate && t.updateMatrixWorld(),
                null === e.parent && e.updateMatrixWorld(),
                !0 === Ct.enabled &&
                  !0 === Ct.isPresenting &&
                  (!0 === Ct.cameraAutoUpdate && Ct.updateCamera(e),
                  (e = Ct.getCamera())),
                !0 === t.isScene && t.onBeforeRender(_, t, e, E),
                (g = pt.get(t, w.length)),
                g.init(),
                w.push(g),
                X.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                G.setFromProjectionMatrix(X),
                (W = this.localClippingEnabled),
                (V = gt.init(this.clippingPlanes, W, e)),
                (f = mt.get(t, x.length)),
                f.init(),
                x.push(f),
                Ot(t, e, 0, _.sortObjects),
                f.finish(),
                !0 === _.sortObjects && f.sort(k, U),
                !0 === V && gt.beginShadows();
              const n = g.state.shadowsArray;
              if (
                (xt.render(n, t, e),
                !0 === V && gt.endShadows(),
                !0 === this.info.autoReset && this.info.reset(),
                vt.render(f, t),
                g.setupLights(_.physicallyCorrectLights),
                e.isArrayCamera)
              ) {
                const n = e.cameras;
                for (let e = 0, s = n.length; e < s; e++) {
                  const s = n[e];
                  kt(f, t, s, s.viewport);
                }
              } else kt(f, t, e);
              null !== E &&
                (et.updateMultisampleRenderTarget(E),
                et.updateRenderTargetMipmap(E)),
                !0 === t.isScene && t.onAfterRender(_, t, e),
                K.buffers.depth.setTest(!0),
                K.buffers.depth.setMask(!0),
                K.buffers.color.setMask(!0),
                K.setPolygonOffset(!1),
                Mt.resetDefaultState(),
                (C = -1),
                (A = null),
                w.pop(),
                (g = w.length > 0 ? w[w.length - 1] : null),
                x.pop(),
                (f = x.length > 0 ? x[x.length - 1] : null);
            }),
            (this.getActiveCubeFace = function () {
              return S;
            }),
            (this.getActiveMipmapLevel = function () {
              return T;
            }),
            (this.getRenderTarget = function () {
              return E;
            }),
            (this.setRenderTarget = function (t, e = 0, n = 0) {
              (E = t),
                (S = e),
                (T = n),
                t &&
                  void 0 === tt.get(t).__webglFramebuffer &&
                  et.setupRenderTarget(t);
              let s = null,
                i = !1,
                r = !1;
              if (t) {
                const n = t.texture;
                (n.isDataTexture3D || n.isDataTexture2DArray) && (r = !0);
                const o = tt.get(t).__webglFramebuffer;
                t.isWebGLCubeRenderTarget
                  ? ((s = o[e]), (i = !0))
                  : (s = t.isWebGLMultisampleRenderTarget
                      ? tt.get(t).__webglMultisampledFramebuffer
                      : o),
                  L.copy(t.viewport),
                  R.copy(t.scissor),
                  (I = t.scissorTest);
              } else
                L.copy(z).multiplyScalar(O).floor(),
                  R.copy(F).multiplyScalar(O).floor(),
                  (I = B);
              if (K.bindFramebuffer(36160, s) && $.drawBuffers) {
                let e = !1;
                if (t)
                  if (t.isWebGLMultipleRenderTargets) {
                    const n = t.texture;
                    if (H.length !== n.length || 36064 !== H[0]) {
                      for (let t = 0, e = n.length; t < e; t++)
                        H[t] = 36064 + t;
                      (H.length = n.length), (e = !0);
                    }
                  } else
                    (1 === H.length && 36064 === H[0]) ||
                      ((H[0] = 36064), (H.length = 1), (e = !0));
                else
                  (1 === H.length && 1029 === H[0]) ||
                    ((H[0] = 1029), (H.length = 1), (e = !0));
                e &&
                  ($.isWebGL2
                    ? St.drawBuffers(H)
                    : Z.get("WEBGL_draw_buffers").drawBuffersWEBGL(H));
              }
              if ((K.viewport(L), K.scissor(R), K.setScissorTest(I), i)) {
                const s = tt.get(t.texture);
                St.framebufferTexture2D(
                  36160,
                  36064,
                  34069 + e,
                  s.__webglTexture,
                  n
                );
              } else if (r) {
                const s = tt.get(t.texture),
                  i = e || 0;
                St.framebufferTextureLayer(
                  36160,
                  36064,
                  s.__webglTexture,
                  n || 0,
                  i
                );
              }
              C = -1;
            }),
            (this.readRenderTargetPixels = function (t, e, n, s, i, r, o) {
              if (!t || !t.isWebGLRenderTarget)
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
                );
              let a = tt.get(t).__webglFramebuffer;
              if (
                (t.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]), a)
              ) {
                K.bindFramebuffer(36160, a);
                try {
                  const o = t.texture,
                    a = o.format,
                    c = o.type;
                  if (a !== b && bt.convert(a) !== St.getParameter(35739))
                    return void console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                    );
                  const u =
                    c === y &&
                    (Z.has("EXT_color_buffer_half_float") ||
                      ($.isWebGL2 && Z.has("EXT_color_buffer_float")));
                  if (
                    !(
                      c === p ||
                      bt.convert(c) === St.getParameter(35738) ||
                      (c === v &&
                        ($.isWebGL2 ||
                          Z.has("OES_texture_float") ||
                          Z.has("WEBGL_color_buffer_float"))) ||
                      u
                    )
                  )
                    return void console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                    );
                  36053 === St.checkFramebufferStatus(36160)
                    ? e >= 0 &&
                      e <= t.width - s &&
                      n >= 0 &&
                      n <= t.height - i &&
                      St.readPixels(e, n, s, i, bt.convert(a), bt.convert(c), r)
                    : console.error(
                        "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
                      );
                } finally {
                  const t = null !== E ? tt.get(E).__webglFramebuffer : null;
                  K.bindFramebuffer(36160, t);
                }
              }
            }),
            (this.copyFramebufferToTexture = function (t, e, n = 0) {
              const s = Math.pow(2, -n),
                i = Math.floor(e.image.width * s),
                r = Math.floor(e.image.height * s);
              let o = bt.convert(e.format);
              $.isWebGL2 &&
                (6407 === o && (o = 32849), 6408 === o && (o = 32856)),
                et.setTexture2D(e, 0),
                St.copyTexImage2D(3553, n, o, t.x, t.y, i, r, 0),
                K.unbindTexture();
            }),
            (this.copyTextureToTexture = function (t, e, n, s = 0) {
              const i = e.image.width,
                r = e.image.height,
                o = bt.convert(n.format),
                a = bt.convert(n.type);
              et.setTexture2D(n, 0),
                St.pixelStorei(37440, n.flipY),
                St.pixelStorei(37441, n.premultiplyAlpha),
                St.pixelStorei(3317, n.unpackAlignment),
                e.isDataTexture
                  ? St.texSubImage2D(
                      3553,
                      s,
                      t.x,
                      t.y,
                      i,
                      r,
                      o,
                      a,
                      e.image.data
                    )
                  : e.isCompressedTexture
                  ? St.compressedTexSubImage2D(
                      3553,
                      s,
                      t.x,
                      t.y,
                      e.mipmaps[0].width,
                      e.mipmaps[0].height,
                      o,
                      e.mipmaps[0].data
                    )
                  : St.texSubImage2D(3553, s, t.x, t.y, o, a, e.image),
                0 === s && n.generateMipmaps && St.generateMipmap(3553),
                K.unbindTexture();
            }),
            (this.copyTextureToTexture3D = function (t, e, n, s, i = 0) {
              if (_.isWebGL1Renderer)
                return void console.warn(
                  "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
                );
              const r = t.max.x - t.min.x + 1,
                o = t.max.y - t.min.y + 1,
                a = t.max.z - t.min.z + 1,
                c = bt.convert(s.format),
                u = bt.convert(s.type);
              let d;
              if (s.isDataTexture3D) et.setTexture3D(s, 0), (d = 32879);
              else {
                if (!s.isDataTexture2DArray)
                  return void console.warn(
                    "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
                  );
                et.setTexture2DArray(s, 0), (d = 35866);
              }
              St.pixelStorei(37440, s.flipY),
                St.pixelStorei(37441, s.premultiplyAlpha),
                St.pixelStorei(3317, s.unpackAlignment);
              const l = St.getParameter(3314),
                h = St.getParameter(32878),
                f = St.getParameter(3316),
                m = St.getParameter(3315),
                p = St.getParameter(32877),
                g = n.isCompressedTexture ? n.mipmaps[0] : n.image;
              St.pixelStorei(3314, g.width),
                St.pixelStorei(32878, g.height),
                St.pixelStorei(3316, t.min.x),
                St.pixelStorei(3315, t.min.y),
                St.pixelStorei(32877, t.min.z),
                n.isDataTexture || n.isDataTexture3D
                  ? St.texSubImage3D(d, i, e.x, e.y, e.z, r, o, a, c, u, g.data)
                  : n.isCompressedTexture
                  ? (console.warn(
                      "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
                    ),
                    St.compressedTexSubImage3D(
                      d,
                      i,
                      e.x,
                      e.y,
                      e.z,
                      r,
                      o,
                      a,
                      c,
                      g.data
                    ))
                  : St.texSubImage3D(d, i, e.x, e.y, e.z, r, o, a, c, u, g),
                St.pixelStorei(3314, l),
                St.pixelStorei(32878, h),
                St.pixelStorei(3316, f),
                St.pixelStorei(3315, m),
                St.pixelStorei(32877, p),
                0 === i && s.generateMipmaps && St.generateMipmap(d),
                K.unbindTexture();
            }),
            (this.initTexture = function (t) {
              et.setTexture2D(t, 0), K.unbindTexture();
            }),
            (this.resetState = function () {
              (S = 0), (T = 0), (E = null), K.reset(), Mt.reset();
            }),
            "undefined" != typeof __THREE_DEVTOOLS__ &&
              __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent("observe", { detail: this })
              );
        }
        (yr.prototype.isWebGLRenderer = !0),
          (class extends yr {}.prototype.isWebGL1Renderer = !0);
        class wr {
          constructor(t, e = 25e-5) {
            (this.name = ""), (this.color = new Oe(t)), (this.density = e);
          }
          clone() {
            return new wr(this.color, this.density);
          }
          toJSON() {
            return {
              type: "FogExp2",
              color: this.color.getHex(),
              density: this.density,
            };
          }
        }
        wr.prototype.isFogExp2 = !0;
        class _r {
          constructor(t, e = 1, n = 1e3) {
            (this.name = ""),
              (this.color = new Oe(t)),
              (this.near = e),
              (this.far = n);
          }
          clone() {
            return new _r(this.color, this.near, this.far);
          }
          toJSON() {
            return {
              type: "Fog",
              color: this.color.getHex(),
              near: this.near,
              far: this.far,
            };
          }
        }
        _r.prototype.isFog = !0;
        class br extends pe {
          constructor() {
            super(),
              (this.type = "Scene"),
              (this.background = null),
              (this.environment = null),
              (this.fog = null),
              (this.overrideMaterial = null),
              (this.autoUpdate = !0),
              "undefined" != typeof __THREE_DEVTOOLS__ &&
                __THREE_DEVTOOLS__.dispatchEvent(
                  new CustomEvent("observe", { detail: this })
                );
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              null !== t.background && (this.background = t.background.clone()),
              null !== t.environment &&
                (this.environment = t.environment.clone()),
              null !== t.fog && (this.fog = t.fog.clone()),
              null !== t.overrideMaterial &&
                (this.overrideMaterial = t.overrideMaterial.clone()),
              (this.autoUpdate = t.autoUpdate),
              (this.matrixAutoUpdate = t.matrixAutoUpdate),
              this
            );
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return null !== this.fog && (e.object.fog = this.fog.toJSON()), e;
          }
        }
        br.prototype.isScene = !0;
        class Mr {
          constructor(t, e) {
            (this.array = t),
              (this.stride = e),
              (this.count = void 0 !== t ? t.length / e : 0),
              (this.usage = k),
              (this.updateRange = { offset: 0, count: -1 }),
              (this.version = 0),
              (this.uuid = j());
          }
          onUploadCallback() {}
          set needsUpdate(t) {
            !0 === t && this.version++;
          }
          setUsage(t) {
            return (this.usage = t), this;
          }
          copy(t) {
            return (
              (this.array = new t.array.constructor(t.array)),
              (this.count = t.count),
              (this.stride = t.stride),
              (this.usage = t.usage),
              this
            );
          }
          copyAt(t, e, n) {
            (t *= this.stride), (n *= e.stride);
            for (let s = 0, i = this.stride; s < i; s++)
              this.array[t + s] = e.array[n + s];
            return this;
          }
          set(t, e = 0) {
            return this.array.set(t, e), this;
          }
          clone(t) {
            void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
              void 0 === this.array.buffer._uuid &&
                (this.array.buffer._uuid = j()),
              void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
                (t.arrayBuffers[this.array.buffer._uuid] =
                  this.array.slice(0).buffer);
            const e = new this.array.constructor(
                t.arrayBuffers[this.array.buffer._uuid]
              ),
              n = new this.constructor(e, this.stride);
            return n.setUsage(this.usage), n;
          }
          onUpload(t) {
            return (this.onUploadCallback = t), this;
          }
          toJSON(t) {
            return (
              void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
              void 0 === this.array.buffer._uuid &&
                (this.array.buffer._uuid = j()),
              void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
                (t.arrayBuffers[this.array.buffer._uuid] =
                  Array.prototype.slice.call(
                    new Uint32Array(this.array.buffer)
                  )),
              {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride,
              }
            );
          }
        }
        Mr.prototype.isInterleavedBuffer = !0;
        const Sr = new ft();
        class Tr {
          constructor(t, e, n, s = !1) {
            (this.name = ""),
              (this.data = t),
              (this.itemSize = e),
              (this.offset = n),
              (this.normalized = !0 === s);
          }
          get count() {
            return this.data.count;
          }
          get array() {
            return this.data.array;
          }
          set needsUpdate(t) {
            this.data.needsUpdate = t;
          }
          applyMatrix4(t) {
            for (let e = 0, n = this.data.count; e < n; e++)
              (Sr.x = this.getX(e)),
                (Sr.y = this.getY(e)),
                (Sr.z = this.getZ(e)),
                Sr.applyMatrix4(t),
                this.setXYZ(e, Sr.x, Sr.y, Sr.z);
            return this;
          }
          applyNormalMatrix(t) {
            for (let e = 0, n = this.count; e < n; e++)
              (Sr.x = this.getX(e)),
                (Sr.y = this.getY(e)),
                (Sr.z = this.getZ(e)),
                Sr.applyNormalMatrix(t),
                this.setXYZ(e, Sr.x, Sr.y, Sr.z);
            return this;
          }
          transformDirection(t) {
            for (let e = 0, n = this.count; e < n; e++)
              (Sr.x = this.getX(e)),
                (Sr.y = this.getY(e)),
                (Sr.z = this.getZ(e)),
                Sr.transformDirection(t),
                this.setXYZ(e, Sr.x, Sr.y, Sr.z);
            return this;
          }
          setX(t, e) {
            return (
              (this.data.array[t * this.data.stride + this.offset] = e), this
            );
          }
          setY(t, e) {
            return (
              (this.data.array[t * this.data.stride + this.offset + 1] = e),
              this
            );
          }
          setZ(t, e) {
            return (
              (this.data.array[t * this.data.stride + this.offset + 2] = e),
              this
            );
          }
          setW(t, e) {
            return (
              (this.data.array[t * this.data.stride + this.offset + 3] = e),
              this
            );
          }
          getX(t) {
            return this.data.array[t * this.data.stride + this.offset];
          }
          getY(t) {
            return this.data.array[t * this.data.stride + this.offset + 1];
          }
          getZ(t) {
            return this.data.array[t * this.data.stride + this.offset + 2];
          }
          getW(t) {
            return this.data.array[t * this.data.stride + this.offset + 3];
          }
          setXY(t, e, n) {
            return (
              (t = t * this.data.stride + this.offset),
              (this.data.array[t + 0] = e),
              (this.data.array[t + 1] = n),
              this
            );
          }
          setXYZ(t, e, n, s) {
            return (
              (t = t * this.data.stride + this.offset),
              (this.data.array[t + 0] = e),
              (this.data.array[t + 1] = n),
              (this.data.array[t + 2] = s),
              this
            );
          }
          setXYZW(t, e, n, s, i) {
            return (
              (t = t * this.data.stride + this.offset),
              (this.data.array[t + 0] = e),
              (this.data.array[t + 1] = n),
              (this.data.array[t + 2] = s),
              (this.data.array[t + 3] = i),
              this
            );
          }
          clone(t) {
            if (void 0 === t) {
              console.log(
                "THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
              );
              const t = [];
              for (let e = 0; e < this.count; e++) {
                const n = e * this.data.stride + this.offset;
                for (let e = 0; e < this.itemSize; e++)
                  t.push(this.data.array[n + e]);
              }
              return new Fe(
                new this.array.constructor(t),
                this.itemSize,
                this.normalized
              );
            }
            return (
              void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
              void 0 === t.interleavedBuffers[this.data.uuid] &&
                (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
              new Tr(
                t.interleavedBuffers[this.data.uuid],
                this.itemSize,
                this.offset,
                this.normalized
              )
            );
          }
          toJSON(t) {
            if (void 0 === t) {
              console.log(
                "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
              );
              const t = [];
              for (let e = 0; e < this.count; e++) {
                const n = e * this.data.stride + this.offset;
                for (let e = 0; e < this.itemSize; e++)
                  t.push(this.data.array[n + e]);
              }
              return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized,
              };
            }
            return (
              void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
              void 0 === t.interleavedBuffers[this.data.uuid] &&
                (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
              {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized,
              }
            );
          }
        }
        Tr.prototype.isInterleavedBufferAttribute = !0;
        class Er extends Ae {
          constructor(t) {
            super(),
              (this.type = "SpriteMaterial"),
              (this.color = new Oe(16777215)),
              (this.map = null),
              (this.alphaMap = null),
              (this.rotation = 0),
              (this.sizeAttenuation = !0),
              (this.transparent = !0),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.rotation = t.rotation),
              (this.sizeAttenuation = t.sizeAttenuation),
              this
            );
          }
        }
        let Cr;
        Er.prototype.isSpriteMaterial = !0;
        const Ar = new ft(),
          Lr = new ft(),
          Rr = new ft(),
          Pr = new Q(),
          Ir = new Q(),
          Dr = new Wt(),
          Nr = new ft(),
          Or = new ft(),
          kr = new ft(),
          Ur = new Q(),
          zr = new Q(),
          Fr = new Q();
        function Br(t, e, n, s, i, r) {
          Pr.subVectors(t, n).addScalar(0.5).multiply(s),
            void 0 !== i
              ? ((Ir.x = r * Pr.x - i * Pr.y), (Ir.y = i * Pr.x + r * Pr.y))
              : Ir.copy(Pr),
            t.copy(e),
            (t.x += Ir.x),
            (t.y += Ir.y),
            t.applyMatrix4(Dr);
        }
        (class extends pe {
          constructor(t) {
            if ((super(), (this.type = "Sprite"), void 0 === Cr)) {
              Cr = new Ze();
              const t = new Float32Array([
                  -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1,
                  -0.5, 0.5, 0, 0, 1,
                ]),
                e = new Mr(t, 5);
              Cr.setIndex([0, 1, 2, 0, 2, 3]),
                Cr.setAttribute("position", new Tr(e, 3, 0, !1)),
                Cr.setAttribute("uv", new Tr(e, 2, 3, !1));
            }
            (this.geometry = Cr),
              (this.material = void 0 !== t ? t : new Er()),
              (this.center = new Q(0.5, 0.5));
          }
          raycast(t, e) {
            null === t.camera &&
              console.error(
                'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
              ),
              Lr.setFromMatrixScale(this.matrixWorld),
              Dr.copy(t.camera.matrixWorld),
              this.modelViewMatrix.multiplyMatrices(
                t.camera.matrixWorldInverse,
                this.matrixWorld
              ),
              Rr.setFromMatrixPosition(this.modelViewMatrix),
              t.camera.isPerspectiveCamera &&
                !1 === this.material.sizeAttenuation &&
                Lr.multiplyScalar(-Rr.z);
            const n = this.material.rotation;
            let s, i;
            0 !== n && ((i = Math.cos(n)), (s = Math.sin(n)));
            const r = this.center;
            Br(Nr.set(-0.5, -0.5, 0), Rr, r, Lr, s, i),
              Br(Or.set(0.5, -0.5, 0), Rr, r, Lr, s, i),
              Br(kr.set(0.5, 0.5, 0), Rr, r, Lr, s, i),
              Ur.set(0, 0),
              zr.set(1, 0),
              Fr.set(1, 1);
            let o = t.ray.intersectTriangle(Nr, Or, kr, !1, Ar);
            if (
              null === o &&
              (Br(Or.set(-0.5, 0.5, 0), Rr, r, Lr, s, i),
              zr.set(0, 1),
              (o = t.ray.intersectTriangle(Nr, kr, Or, !1, Ar)),
              null === o)
            )
              return;
            const a = t.ray.origin.distanceTo(Ar);
            a < t.near ||
              a > t.far ||
              e.push({
                distance: a,
                point: Ar.clone(),
                uv: Ee.getUV(Ar, Nr, Or, kr, Ur, zr, Fr, new Q()),
                face: null,
                object: this,
              });
          }
          copy(t) {
            return (
              super.copy(t),
              void 0 !== t.center && this.center.copy(t.center),
              (this.material = t.material),
              this
            );
          }
        }).prototype.isSprite = !0;
        const Hr = new ft(),
          Gr = new ut(),
          Vr = new ut(),
          Wr = new ft(),
          jr = new Wt();
        class Xr extends pn {
          constructor(t, e) {
            super(t, e),
              (this.type = "SkinnedMesh"),
              (this.bindMode = "attached"),
              (this.bindMatrix = new Wt()),
              (this.bindMatrixInverse = new Wt());
          }
          copy(t) {
            return (
              super.copy(t),
              (this.bindMode = t.bindMode),
              this.bindMatrix.copy(t.bindMatrix),
              this.bindMatrixInverse.copy(t.bindMatrixInverse),
              (this.skeleton = t.skeleton),
              this
            );
          }
          bind(t, e) {
            (this.skeleton = t),
              void 0 === e &&
                (this.updateMatrixWorld(!0),
                this.skeleton.calculateInverses(),
                (e = this.matrixWorld)),
              this.bindMatrix.copy(e),
              this.bindMatrixInverse.copy(e).invert();
          }
          pose() {
            this.skeleton.pose();
          }
          normalizeSkinWeights() {
            const t = new ut(),
              e = this.geometry.attributes.skinWeight;
            for (let n = 0, s = e.count; n < s; n++) {
              (t.x = e.getX(n)),
                (t.y = e.getY(n)),
                (t.z = e.getZ(n)),
                (t.w = e.getW(n));
              const s = 1 / t.manhattanLength();
              s !== 1 / 0 ? t.multiplyScalar(s) : t.set(1, 0, 0, 0),
                e.setXYZW(n, t.x, t.y, t.z, t.w);
            }
          }
          updateMatrixWorld(t) {
            super.updateMatrixWorld(t),
              "attached" === this.bindMode
                ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
                : "detached" === this.bindMode
                ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
                : console.warn(
                    "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
                  );
          }
          boneTransform(t, e) {
            const n = this.skeleton,
              s = this.geometry;
            Gr.fromBufferAttribute(s.attributes.skinIndex, t),
              Vr.fromBufferAttribute(s.attributes.skinWeight, t),
              Hr.copy(e).applyMatrix4(this.bindMatrix),
              e.set(0, 0, 0);
            for (let t = 0; t < 4; t++) {
              const s = Vr.getComponent(t);
              if (0 !== s) {
                const i = Gr.getComponent(t);
                jr.multiplyMatrices(n.bones[i].matrixWorld, n.boneInverses[i]),
                  e.addScaledVector(Wr.copy(Hr).applyMatrix4(jr), s);
              }
            }
            return e.applyMatrix4(this.bindMatrixInverse);
          }
        }
        Xr.prototype.isSkinnedMesh = !0;
        class qr extends pe {
          constructor() {
            super(), (this.type = "Bone");
          }
        }
        qr.prototype.isBone = !0;
        class Yr extends at {
          constructor(
            t = null,
            e = 1,
            n = 1,
            s,
            i,
            r,
            o,
            a,
            c = 1003,
            u = 1003,
            d,
            l
          ) {
            super(null, r, o, a, c, u, s, i, d, l),
              (this.image = { data: t, width: e, height: n }),
              (this.magFilter = c),
              (this.minFilter = u),
              (this.generateMipmaps = !1),
              (this.flipY = !1),
              (this.unpackAlignment = 1),
              (this.needsUpdate = !0);
          }
        }
        Yr.prototype.isDataTexture = !0;
        const Jr = new Wt(),
          Zr = new Wt();
        class $r {
          constructor(t = [], e = []) {
            (this.uuid = j()),
              (this.bones = t.slice(0)),
              (this.boneInverses = e),
              (this.boneMatrices = null),
              (this.boneTexture = null),
              (this.boneTextureSize = 0),
              (this.frame = -1),
              this.init();
          }
          init() {
            const t = this.bones,
              e = this.boneInverses;
            if (
              ((this.boneMatrices = new Float32Array(16 * t.length)),
              0 === e.length)
            )
              this.calculateInverses();
            else if (t.length !== e.length) {
              console.warn(
                "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
              ),
                (this.boneInverses = []);
              for (let t = 0, e = this.bones.length; t < e; t++)
                this.boneInverses.push(new Wt());
            }
          }
          calculateInverses() {
            this.boneInverses.length = 0;
            for (let t = 0, e = this.bones.length; t < e; t++) {
              const e = new Wt();
              this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(),
                this.boneInverses.push(e);
            }
          }
          pose() {
            for (let t = 0, e = this.bones.length; t < e; t++) {
              const e = this.bones[t];
              e && e.matrixWorld.copy(this.boneInverses[t]).invert();
            }
            for (let t = 0, e = this.bones.length; t < e; t++) {
              const e = this.bones[t];
              e &&
                (e.parent && e.parent.isBone
                  ? (e.matrix.copy(e.parent.matrixWorld).invert(),
                    e.matrix.multiply(e.matrixWorld))
                  : e.matrix.copy(e.matrixWorld),
                e.matrix.decompose(e.position, e.quaternion, e.scale));
            }
          }
          update() {
            const t = this.bones,
              e = this.boneInverses,
              n = this.boneMatrices,
              s = this.boneTexture;
            for (let s = 0, i = t.length; s < i; s++) {
              const i = t[s] ? t[s].matrixWorld : Zr;
              Jr.multiplyMatrices(i, e[s]), Jr.toArray(n, 16 * s);
            }
            null !== s && (s.needsUpdate = !0);
          }
          clone() {
            return new $r(this.bones, this.boneInverses);
          }
          computeBoneTexture() {
            let t = Math.sqrt(4 * this.bones.length);
            (t = Z(t)), (t = Math.max(t, 4));
            const e = new Float32Array(t * t * 4);
            e.set(this.boneMatrices);
            const n = new Yr(e, t, t, b, v);
            return (
              (this.boneMatrices = e),
              (this.boneTexture = n),
              (this.boneTextureSize = t),
              this
            );
          }
          getBoneByName(t) {
            for (let e = 0, n = this.bones.length; e < n; e++) {
              const n = this.bones[e];
              if (n.name === t) return n;
            }
          }
          dispose() {
            null !== this.boneTexture &&
              (this.boneTexture.dispose(), (this.boneTexture = null));
          }
          fromJSON(t, e) {
            this.uuid = t.uuid;
            for (let n = 0, s = t.bones.length; n < s; n++) {
              const s = t.bones[n];
              let i = e[s];
              void 0 === i &&
                (console.warn("THREE.Skeleton: No bone found with UUID:", s),
                (i = new qr())),
                this.bones.push(i),
                this.boneInverses.push(new Wt().fromArray(t.boneInverses[n]));
            }
            return this.init(), this;
          }
          toJSON() {
            const t = {
              metadata: {
                version: 4.5,
                type: "Skeleton",
                generator: "Skeleton.toJSON",
              },
              bones: [],
              boneInverses: [],
            };
            t.uuid = this.uuid;
            const e = this.bones,
              n = this.boneInverses;
            for (let s = 0, i = e.length; s < i; s++) {
              const i = e[s];
              t.bones.push(i.uuid);
              const r = n[s];
              t.boneInverses.push(r.toArray());
            }
            return t;
          }
        }
        class Kr extends Fe {
          constructor(t, e, n, s = 1) {
            "number" == typeof n &&
              ((s = n),
              (n = !1),
              console.error(
                "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
              )),
              super(t, e, n),
              (this.meshPerAttribute = s);
          }
          copy(t) {
            return (
              super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.meshPerAttribute = this.meshPerAttribute),
              (t.isInstancedBufferAttribute = !0),
              t
            );
          }
        }
        Kr.prototype.isInstancedBufferAttribute = !0;
        const Qr = new Wt(),
          to = new Wt(),
          eo = [],
          no = new pn();
        (class extends pn {
          constructor(t, e, n) {
            super(t, e),
              (this.instanceMatrix = new Kr(new Float32Array(16 * n), 16)),
              (this.instanceColor = null),
              (this.count = n),
              (this.frustumCulled = !1);
          }
          copy(t) {
            return (
              super.copy(t),
              this.instanceMatrix.copy(t.instanceMatrix),
              null !== t.instanceColor &&
                (this.instanceColor = t.instanceColor.clone()),
              (this.count = t.count),
              this
            );
          }
          getColorAt(t, e) {
            e.fromArray(this.instanceColor.array, 3 * t);
          }
          getMatrixAt(t, e) {
            e.fromArray(this.instanceMatrix.array, 16 * t);
          }
          raycast(t, e) {
            const n = this.matrixWorld,
              s = this.count;
            if (
              ((no.geometry = this.geometry),
              (no.material = this.material),
              void 0 !== no.material)
            )
              for (let i = 0; i < s; i++) {
                this.getMatrixAt(i, Qr),
                  to.multiplyMatrices(n, Qr),
                  (no.matrixWorld = to),
                  no.raycast(t, eo);
                for (let t = 0, n = eo.length; t < n; t++) {
                  const n = eo[t];
                  (n.instanceId = i), (n.object = this), e.push(n);
                }
                eo.length = 0;
              }
          }
          setColorAt(t, e) {
            null === this.instanceColor &&
              (this.instanceColor = new Kr(
                new Float32Array(3 * this.instanceMatrix.count),
                3
              )),
              e.toArray(this.instanceColor.array, 3 * t);
          }
          setMatrixAt(t, e) {
            e.toArray(this.instanceMatrix.array, 16 * t);
          }
          updateMorphTargets() {}
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
        }).prototype.isInstancedMesh = !0;
        class so extends Ae {
          constructor(t) {
            super(),
              (this.type = "LineBasicMaterial"),
              (this.color = new Oe(16777215)),
              (this.linewidth = 1),
              (this.linecap = "round"),
              (this.linejoin = "round"),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.linewidth = t.linewidth),
              (this.linecap = t.linecap),
              (this.linejoin = t.linejoin),
              this
            );
          }
        }
        so.prototype.isLineBasicMaterial = !0;
        const io = new ft(),
          ro = new ft(),
          oo = new Wt(),
          ao = new Vt(),
          co = new Ot();
        class uo extends pe {
          constructor(t = new Ze(), e = new so()) {
            super(),
              (this.type = "Line"),
              (this.geometry = t),
              (this.material = e),
              this.updateMorphTargets();
          }
          copy(t) {
            return (
              super.copy(t),
              (this.material = t.material),
              (this.geometry = t.geometry),
              this
            );
          }
          computeLineDistances() {
            const t = this.geometry;
            if (t.isBufferGeometry)
              if (null === t.index) {
                const e = t.attributes.position,
                  n = [0];
                for (let t = 1, s = e.count; t < s; t++)
                  io.fromBufferAttribute(e, t - 1),
                    ro.fromBufferAttribute(e, t),
                    (n[t] = n[t - 1]),
                    (n[t] += io.distanceTo(ro));
                t.setAttribute("lineDistance", new Ge(n, 1));
              } else
                console.warn(
                  "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
                );
            else
              t.isGeometry &&
                console.error(
                  "THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
                );
            return this;
          }
          raycast(t, e) {
            const n = this.geometry,
              s = this.matrixWorld,
              i = t.params.Line.threshold,
              r = n.drawRange;
            if (
              (null === n.boundingSphere && n.computeBoundingSphere(),
              co.copy(n.boundingSphere),
              co.applyMatrix4(s),
              (co.radius += i),
              !1 === t.ray.intersectsSphere(co))
            )
              return;
            oo.copy(s).invert(), ao.copy(t.ray).applyMatrix4(oo);
            const o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
              a = o * o,
              c = new ft(),
              u = new ft(),
              d = new ft(),
              l = new ft(),
              h = this.isLineSegments ? 2 : 1;
            if (n.isBufferGeometry) {
              const s = n.index,
                i = n.attributes.position;
              if (null !== s)
                for (
                  let n = Math.max(0, r.start),
                    o = Math.min(s.count, r.start + r.count) - 1;
                  n < o;
                  n += h
                ) {
                  const r = s.getX(n),
                    o = s.getX(n + 1);
                  if (
                    (c.fromBufferAttribute(i, r),
                    u.fromBufferAttribute(i, o),
                    ao.distanceSqToSegment(c, u, l, d) > a)
                  )
                    continue;
                  l.applyMatrix4(this.matrixWorld);
                  const h = t.ray.origin.distanceTo(l);
                  h < t.near ||
                    h > t.far ||
                    e.push({
                      distance: h,
                      point: d.clone().applyMatrix4(this.matrixWorld),
                      index: n,
                      face: null,
                      faceIndex: null,
                      object: this,
                    });
                }
              else
                for (
                  let n = Math.max(0, r.start),
                    s = Math.min(i.count, r.start + r.count) - 1;
                  n < s;
                  n += h
                ) {
                  if (
                    (c.fromBufferAttribute(i, n),
                    u.fromBufferAttribute(i, n + 1),
                    ao.distanceSqToSegment(c, u, l, d) > a)
                  )
                    continue;
                  l.applyMatrix4(this.matrixWorld);
                  const s = t.ray.origin.distanceTo(l);
                  s < t.near ||
                    s > t.far ||
                    e.push({
                      distance: s,
                      point: d.clone().applyMatrix4(this.matrixWorld),
                      index: n,
                      face: null,
                      faceIndex: null,
                      object: this,
                    });
                }
            } else
              n.isGeometry &&
                console.error(
                  "THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
                );
          }
          updateMorphTargets() {
            const t = this.geometry;
            if (t.isBufferGeometry) {
              const e = t.morphAttributes,
                n = Object.keys(e);
              if (n.length > 0) {
                const t = e[n[0]];
                if (void 0 !== t) {
                  (this.morphTargetInfluences = []),
                    (this.morphTargetDictionary = {});
                  for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e].name || String(e);
                    this.morphTargetInfluences.push(0),
                      (this.morphTargetDictionary[n] = e);
                  }
                }
              }
            } else {
              const e = t.morphTargets;
              void 0 !== e &&
                e.length > 0 &&
                console.error(
                  "THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
                );
            }
          }
        }
        uo.prototype.isLine = !0;
        const lo = new ft(),
          ho = new ft();
        class fo extends uo {
          constructor(t, e) {
            super(t, e), (this.type = "LineSegments");
          }
          computeLineDistances() {
            const t = this.geometry;
            if (t.isBufferGeometry)
              if (null === t.index) {
                const e = t.attributes.position,
                  n = [];
                for (let t = 0, s = e.count; t < s; t += 2)
                  lo.fromBufferAttribute(e, t),
                    ho.fromBufferAttribute(e, t + 1),
                    (n[t] = 0 === t ? 0 : n[t - 1]),
                    (n[t + 1] = n[t] + lo.distanceTo(ho));
                t.setAttribute("lineDistance", new Ge(n, 1));
              } else
                console.warn(
                  "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
                );
            else
              t.isGeometry &&
                console.error(
                  "THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
                );
            return this;
          }
        }
        fo.prototype.isLineSegments = !0;
        class mo extends uo {
          constructor(t, e) {
            super(t, e), (this.type = "LineLoop");
          }
        }
        mo.prototype.isLineLoop = !0;
        class po extends Ae {
          constructor(t) {
            super(),
              (this.type = "PointsMaterial"),
              (this.color = new Oe(16777215)),
              (this.map = null),
              (this.alphaMap = null),
              (this.size = 1),
              (this.sizeAttenuation = !0),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.size = t.size),
              (this.sizeAttenuation = t.sizeAttenuation),
              this
            );
          }
        }
        po.prototype.isPointsMaterial = !0;
        const go = new Wt(),
          xo = new Vt(),
          vo = new Ot(),
          yo = new ft();
        class wo extends pe {
          constructor(t = new Ze(), e = new po()) {
            super(),
              (this.type = "Points"),
              (this.geometry = t),
              (this.material = e),
              this.updateMorphTargets();
          }
          copy(t) {
            return (
              super.copy(t),
              (this.material = t.material),
              (this.geometry = t.geometry),
              this
            );
          }
          raycast(t, e) {
            const n = this.geometry,
              s = this.matrixWorld,
              i = t.params.Points.threshold,
              r = n.drawRange;
            if (
              (null === n.boundingSphere && n.computeBoundingSphere(),
              vo.copy(n.boundingSphere),
              vo.applyMatrix4(s),
              (vo.radius += i),
              !1 === t.ray.intersectsSphere(vo))
            )
              return;
            go.copy(s).invert(), xo.copy(t.ray).applyMatrix4(go);
            const o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
              a = o * o;
            if (n.isBufferGeometry) {
              const i = n.index,
                o = n.attributes.position;
              if (null !== i)
                for (
                  let n = Math.max(0, r.start),
                    c = Math.min(i.count, r.start + r.count);
                  n < c;
                  n++
                ) {
                  const r = i.getX(n);
                  yo.fromBufferAttribute(o, r), _o(yo, r, a, s, t, e, this);
                }
              else
                for (
                  let n = Math.max(0, r.start),
                    i = Math.min(o.count, r.start + r.count);
                  n < i;
                  n++
                )
                  yo.fromBufferAttribute(o, n), _o(yo, n, a, s, t, e, this);
            } else
              console.error(
                "THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
          updateMorphTargets() {
            const t = this.geometry;
            if (t.isBufferGeometry) {
              const e = t.morphAttributes,
                n = Object.keys(e);
              if (n.length > 0) {
                const t = e[n[0]];
                if (void 0 !== t) {
                  (this.morphTargetInfluences = []),
                    (this.morphTargetDictionary = {});
                  for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e].name || String(e);
                    this.morphTargetInfluences.push(0),
                      (this.morphTargetDictionary[n] = e);
                  }
                }
              }
            } else {
              const e = t.morphTargets;
              void 0 !== e &&
                e.length > 0 &&
                console.error(
                  "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
                );
            }
          }
        }
        function _o(t, e, n, s, i, r, o) {
          const a = xo.distanceSqToPoint(t);
          if (a < n) {
            const n = new ft();
            xo.closestPointToPoint(t, n), n.applyMatrix4(s);
            const c = i.ray.origin.distanceTo(n);
            if (c < i.near || c > i.far) return;
            r.push({
              distance: c,
              distanceToRay: Math.sqrt(a),
              point: n,
              index: e,
              face: null,
              object: o,
            });
          }
        }
        (wo.prototype.isPoints = !0),
          (class extends at {
            constructor(t, e, n, s, i, r, o, a, c) {
              super(t, e, n, s, i, r, o, a, c),
                (this.format = void 0 !== o ? o : _),
                (this.minFilter = void 0 !== r ? r : f),
                (this.magFilter = void 0 !== i ? i : f),
                (this.generateMipmaps = !1);
              const u = this;
              "requestVideoFrameCallback" in t &&
                t.requestVideoFrameCallback(function e() {
                  (u.needsUpdate = !0), t.requestVideoFrameCallback(e);
                });
            }
            clone() {
              return new this.constructor(this.image).copy(this);
            }
            update() {
              const t = this.image;
              !1 == "requestVideoFrameCallback" in t &&
                t.readyState >= t.HAVE_CURRENT_DATA &&
                (this.needsUpdate = !0);
            }
          }.prototype.isVideoTexture = !0);
        (class extends at {
          constructor(t, e, n, s, i, r, o, a, c, u, d, l) {
            super(null, r, o, a, c, u, s, i, d, l),
              (this.image = { width: e, height: n }),
              (this.mipmaps = t),
              (this.flipY = !1),
              (this.generateMipmaps = !1);
          }
        }).prototype.isCompressedTexture = !0;
        class bo extends at {
          constructor(t, e, n, s, i, r, o, a, c) {
            super(t, e, n, s, i, r, o, a, c), (this.needsUpdate = !0);
          }
        }
        (bo.prototype.isCanvasTexture = !0),
          (class extends at {
            constructor(t, e, n, s, i, r, o, a, c, u) {
              if ((u = void 0 !== u ? u : M) !== M && u !== S)
                throw new Error(
                  "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
                );
              void 0 === n && u === M && (n = g),
                void 0 === n && u === S && (n = w),
                super(null, s, i, r, o, a, u, n, c),
                (this.image = { width: t, height: e }),
                (this.magFilter = void 0 !== o ? o : d),
                (this.minFilter = void 0 !== a ? a : d),
                (this.flipY = !1),
                (this.generateMipmaps = !1);
            }
          }.prototype.isDepthTexture = !0),
          new ft(),
          new ft(),
          new ft(),
          new Ee();
        class Mo {
          constructor() {
            (this.type = "Curve"), (this.arcLengthDivisions = 200);
          }
          getPoint() {
            return (
              console.warn("THREE.Curve: .getPoint() not implemented."), null
            );
          }
          getPointAt(t, e) {
            const n = this.getUtoTmapping(t);
            return this.getPoint(n, e);
          }
          getPoints(t = 5) {
            const e = [];
            for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
            return e;
          }
          getSpacedPoints(t = 5) {
            const e = [];
            for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
            return e;
          }
          getLength() {
            const t = this.getLengths();
            return t[t.length - 1];
          }
          getLengths(t = this.arcLengthDivisions) {
            if (
              this.cacheArcLengths &&
              this.cacheArcLengths.length === t + 1 &&
              !this.needsUpdate
            )
              return this.cacheArcLengths;
            this.needsUpdate = !1;
            const e = [];
            let n,
              s = this.getPoint(0),
              i = 0;
            e.push(0);
            for (let r = 1; r <= t; r++)
              (n = this.getPoint(r / t)),
                (i += n.distanceTo(s)),
                e.push(i),
                (s = n);
            return (this.cacheArcLengths = e), e;
          }
          updateArcLengths() {
            (this.needsUpdate = !0), this.getLengths();
          }
          getUtoTmapping(t, e) {
            const n = this.getLengths();
            let s = 0;
            const i = n.length;
            let r;
            r = e || t * n[i - 1];
            let o,
              a = 0,
              c = i - 1;
            for (; a <= c; )
              if (((s = Math.floor(a + (c - a) / 2)), (o = n[s] - r), o < 0))
                a = s + 1;
              else {
                if (!(o > 0)) {
                  c = s;
                  break;
                }
                c = s - 1;
              }
            if (((s = c), n[s] === r)) return s / (i - 1);
            const u = n[s];
            return (s + (r - u) / (n[s + 1] - u)) / (i - 1);
          }
          getTangent(t, e) {
            const n = 1e-4;
            let s = t - n,
              i = t + n;
            s < 0 && (s = 0), i > 1 && (i = 1);
            const r = this.getPoint(s),
              o = this.getPoint(i),
              a = e || (r.isVector2 ? new Q() : new ft());
            return a.copy(o).sub(r).normalize(), a;
          }
          getTangentAt(t, e) {
            const n = this.getUtoTmapping(t);
            return this.getTangent(n, e);
          }
          computeFrenetFrames(t, e) {
            const n = new ft(),
              s = [],
              i = [],
              r = [],
              o = new ft(),
              a = new Wt();
            for (let e = 0; e <= t; e++) {
              const n = e / t;
              s[e] = this.getTangentAt(n, new ft());
            }
            (i[0] = new ft()), (r[0] = new ft());
            let c = Number.MAX_VALUE;
            const u = Math.abs(s[0].x),
              d = Math.abs(s[0].y),
              l = Math.abs(s[0].z);
            u <= c && ((c = u), n.set(1, 0, 0)),
              d <= c && ((c = d), n.set(0, 1, 0)),
              l <= c && n.set(0, 0, 1),
              o.crossVectors(s[0], n).normalize(),
              i[0].crossVectors(s[0], o),
              r[0].crossVectors(s[0], i[0]);
            for (let e = 1; e <= t; e++) {
              if (
                ((i[e] = i[e - 1].clone()),
                (r[e] = r[e - 1].clone()),
                o.crossVectors(s[e - 1], s[e]),
                o.length() > Number.EPSILON)
              ) {
                o.normalize();
                const t = Math.acos(X(s[e - 1].dot(s[e]), -1, 1));
                i[e].applyMatrix4(a.makeRotationAxis(o, t));
              }
              r[e].crossVectors(s[e], i[e]);
            }
            if (!0 === e) {
              let e = Math.acos(X(i[0].dot(i[t]), -1, 1));
              (e /= t), s[0].dot(o.crossVectors(i[0], i[t])) > 0 && (e = -e);
              for (let n = 1; n <= t; n++)
                i[n].applyMatrix4(a.makeRotationAxis(s[n], e * n)),
                  r[n].crossVectors(s[n], i[n]);
            }
            return { tangents: s, normals: i, binormals: r };
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return (this.arcLengthDivisions = t.arcLengthDivisions), this;
          }
          toJSON() {
            const t = {
              metadata: {
                version: 4.5,
                type: "Curve",
                generator: "Curve.toJSON",
              },
            };
            return (
              (t.arcLengthDivisions = this.arcLengthDivisions),
              (t.type = this.type),
              t
            );
          }
          fromJSON(t) {
            return (this.arcLengthDivisions = t.arcLengthDivisions), this;
          }
        }
        class So extends Mo {
          constructor(
            t = 0,
            e = 0,
            n = 1,
            s = 1,
            i = 0,
            r = 2 * Math.PI,
            o = !1,
            a = 0
          ) {
            super(),
              (this.type = "EllipseCurve"),
              (this.aX = t),
              (this.aY = e),
              (this.xRadius = n),
              (this.yRadius = s),
              (this.aStartAngle = i),
              (this.aEndAngle = r),
              (this.aClockwise = o),
              (this.aRotation = a);
          }
          getPoint(t, e) {
            const n = e || new Q(),
              s = 2 * Math.PI;
            let i = this.aEndAngle - this.aStartAngle;
            const r = Math.abs(i) < Number.EPSILON;
            for (; i < 0; ) i += s;
            for (; i > s; ) i -= s;
            i < Number.EPSILON && (i = r ? 0 : s),
              !0 !== this.aClockwise || r || (i === s ? (i = -s) : (i -= s));
            const o = this.aStartAngle + t * i;
            let a = this.aX + this.xRadius * Math.cos(o),
              c = this.aY + this.yRadius * Math.sin(o);
            if (0 !== this.aRotation) {
              const t = Math.cos(this.aRotation),
                e = Math.sin(this.aRotation),
                n = a - this.aX,
                s = c - this.aY;
              (a = n * t - s * e + this.aX), (c = n * e + s * t + this.aY);
            }
            return n.set(a, c);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.aX = t.aX),
              (this.aY = t.aY),
              (this.xRadius = t.xRadius),
              (this.yRadius = t.yRadius),
              (this.aStartAngle = t.aStartAngle),
              (this.aEndAngle = t.aEndAngle),
              (this.aClockwise = t.aClockwise),
              (this.aRotation = t.aRotation),
              this
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.aX = this.aX),
              (t.aY = this.aY),
              (t.xRadius = this.xRadius),
              (t.yRadius = this.yRadius),
              (t.aStartAngle = this.aStartAngle),
              (t.aEndAngle = this.aEndAngle),
              (t.aClockwise = this.aClockwise),
              (t.aRotation = this.aRotation),
              t
            );
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              (this.aX = t.aX),
              (this.aY = t.aY),
              (this.xRadius = t.xRadius),
              (this.yRadius = t.yRadius),
              (this.aStartAngle = t.aStartAngle),
              (this.aEndAngle = t.aEndAngle),
              (this.aClockwise = t.aClockwise),
              (this.aRotation = t.aRotation),
              this
            );
          }
        }
        So.prototype.isEllipseCurve = !0;
        class To extends So {
          constructor(t, e, n, s, i, r) {
            super(t, e, n, n, s, i, r), (this.type = "ArcCurve");
          }
        }
        function Eo() {
          let t = 0,
            e = 0,
            n = 0,
            s = 0;
          function i(i, r, o, a) {
            (t = i),
              (e = o),
              (n = -3 * i + 3 * r - 2 * o - a),
              (s = 2 * i - 2 * r + o + a);
          }
          return {
            initCatmullRom: function (t, e, n, s, r) {
              i(e, n, r * (n - t), r * (s - e));
            },
            initNonuniformCatmullRom: function (t, e, n, s, r, o, a) {
              let c = (e - t) / r - (n - t) / (r + o) + (n - e) / o,
                u = (n - e) / o - (s - e) / (o + a) + (s - n) / a;
              (c *= o), (u *= o), i(e, n, c, u);
            },
            calc: function (i) {
              const r = i * i;
              return t + e * i + n * r + s * (r * i);
            },
          };
        }
        To.prototype.isArcCurve = !0;
        const Co = new ft(),
          Ao = new Eo(),
          Lo = new Eo(),
          Ro = new Eo();
        class Po extends Mo {
          constructor(t = [], e = !1, n = "centripetal", s = 0.5) {
            super(),
              (this.type = "CatmullRomCurve3"),
              (this.points = t),
              (this.closed = e),
              (this.curveType = n),
              (this.tension = s);
          }
          getPoint(t, e = new ft()) {
            const n = e,
              s = this.points,
              i = s.length,
              r = (i - (this.closed ? 0 : 1)) * t;
            let o,
              a,
              c = Math.floor(r),
              u = r - c;
            this.closed
              ? (c += c > 0 ? 0 : (Math.floor(Math.abs(c) / i) + 1) * i)
              : 0 === u && c === i - 1 && ((c = i - 2), (u = 1)),
              this.closed || c > 0
                ? (o = s[(c - 1) % i])
                : (Co.subVectors(s[0], s[1]).add(s[0]), (o = Co));
            const d = s[c % i],
              l = s[(c + 1) % i];
            if (
              (this.closed || c + 2 < i
                ? (a = s[(c + 2) % i])
                : (Co.subVectors(s[i - 1], s[i - 2]).add(s[i - 1]), (a = Co)),
              "centripetal" === this.curveType || "chordal" === this.curveType)
            ) {
              const t = "chordal" === this.curveType ? 0.5 : 0.25;
              let e = Math.pow(o.distanceToSquared(d), t),
                n = Math.pow(d.distanceToSquared(l), t),
                s = Math.pow(l.distanceToSquared(a), t);
              n < 1e-4 && (n = 1),
                e < 1e-4 && (e = n),
                s < 1e-4 && (s = n),
                Ao.initNonuniformCatmullRom(o.x, d.x, l.x, a.x, e, n, s),
                Lo.initNonuniformCatmullRom(o.y, d.y, l.y, a.y, e, n, s),
                Ro.initNonuniformCatmullRom(o.z, d.z, l.z, a.z, e, n, s);
            } else
              "catmullrom" === this.curveType &&
                (Ao.initCatmullRom(o.x, d.x, l.x, a.x, this.tension),
                Lo.initCatmullRom(o.y, d.y, l.y, a.y, this.tension),
                Ro.initCatmullRom(o.z, d.z, l.z, a.z, this.tension));
            return n.set(Ao.calc(u), Lo.calc(u), Ro.calc(u)), n;
          }
          copy(t) {
            super.copy(t), (this.points = []);
            for (let e = 0, n = t.points.length; e < n; e++) {
              const n = t.points[e];
              this.points.push(n.clone());
            }
            return (
              (this.closed = t.closed),
              (this.curveType = t.curveType),
              (this.tension = t.tension),
              this
            );
          }
          toJSON() {
            const t = super.toJSON();
            t.points = [];
            for (let e = 0, n = this.points.length; e < n; e++) {
              const n = this.points[e];
              t.points.push(n.toArray());
            }
            return (
              (t.closed = this.closed),
              (t.curveType = this.curveType),
              (t.tension = this.tension),
              t
            );
          }
          fromJSON(t) {
            super.fromJSON(t), (this.points = []);
            for (let e = 0, n = t.points.length; e < n; e++) {
              const n = t.points[e];
              this.points.push(new ft().fromArray(n));
            }
            return (
              (this.closed = t.closed),
              (this.curveType = t.curveType),
              (this.tension = t.tension),
              this
            );
          }
        }
        function Io(t, e, n, s, i) {
          const r = 0.5 * (s - e),
            o = 0.5 * (i - n),
            a = t * t;
          return (
            (2 * n - 2 * s + r + o) * (t * a) +
            (-3 * n + 3 * s - 2 * r - o) * a +
            r * t +
            n
          );
        }
        function Do(t, e, n, s) {
          return (
            (function (t, e) {
              const n = 1 - t;
              return n * n * e;
            })(t, e) +
            (function (t, e) {
              return 2 * (1 - t) * t * e;
            })(t, n) +
            (function (t, e) {
              return t * t * e;
            })(t, s)
          );
        }
        function No(t, e, n, s, i) {
          return (
            (function (t, e) {
              const n = 1 - t;
              return n * n * n * e;
            })(t, e) +
            (function (t, e) {
              const n = 1 - t;
              return 3 * n * n * t * e;
            })(t, n) +
            (function (t, e) {
              return 3 * (1 - t) * t * t * e;
            })(t, s) +
            (function (t, e) {
              return t * t * t * e;
            })(t, i)
          );
        }
        Po.prototype.isCatmullRomCurve3 = !0;
        class Oo extends Mo {
          constructor(t = new Q(), e = new Q(), n = new Q(), s = new Q()) {
            super(),
              (this.type = "CubicBezierCurve"),
              (this.v0 = t),
              (this.v1 = e),
              (this.v2 = n),
              (this.v3 = s);
          }
          getPoint(t, e = new Q()) {
            const n = e,
              s = this.v0,
              i = this.v1,
              r = this.v2,
              o = this.v3;
            return (
              n.set(No(t, s.x, i.x, r.x, o.x), No(t, s.y, i.y, r.y, o.y)), n
            );
          }
          copy(t) {
            return (
              super.copy(t),
              this.v0.copy(t.v0),
              this.v1.copy(t.v1),
              this.v2.copy(t.v2),
              this.v3.copy(t.v3),
              this
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.v0 = this.v0.toArray()),
              (t.v1 = this.v1.toArray()),
              (t.v2 = this.v2.toArray()),
              (t.v3 = this.v3.toArray()),
              t
            );
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v0.fromArray(t.v0),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this.v3.fromArray(t.v3),
              this
            );
          }
        }
        Oo.prototype.isCubicBezierCurve = !0;
        class ko extends Mo {
          constructor(t = new ft(), e = new ft(), n = new ft(), s = new ft()) {
            super(),
              (this.type = "CubicBezierCurve3"),
              (this.v0 = t),
              (this.v1 = e),
              (this.v2 = n),
              (this.v3 = s);
          }
          getPoint(t, e = new ft()) {
            const n = e,
              s = this.v0,
              i = this.v1,
              r = this.v2,
              o = this.v3;
            return (
              n.set(
                No(t, s.x, i.x, r.x, o.x),
                No(t, s.y, i.y, r.y, o.y),
                No(t, s.z, i.z, r.z, o.z)
              ),
              n
            );
          }
          copy(t) {
            return (
              super.copy(t),
              this.v0.copy(t.v0),
              this.v1.copy(t.v1),
              this.v2.copy(t.v2),
              this.v3.copy(t.v3),
              this
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.v0 = this.v0.toArray()),
              (t.v1 = this.v1.toArray()),
              (t.v2 = this.v2.toArray()),
              (t.v3 = this.v3.toArray()),
              t
            );
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v0.fromArray(t.v0),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this.v3.fromArray(t.v3),
              this
            );
          }
        }
        ko.prototype.isCubicBezierCurve3 = !0;
        class Uo extends Mo {
          constructor(t = new Q(), e = new Q()) {
            super(), (this.type = "LineCurve"), (this.v1 = t), (this.v2 = e);
          }
          getPoint(t, e = new Q()) {
            const n = e;
            return (
              1 === t
                ? n.copy(this.v2)
                : (n.copy(this.v2).sub(this.v1),
                  n.multiplyScalar(t).add(this.v1)),
              n
            );
          }
          getPointAt(t, e) {
            return this.getPoint(t, e);
          }
          getTangent(t, e) {
            const n = e || new Q();
            return n.copy(this.v2).sub(this.v1).normalize(), n;
          }
          copy(t) {
            return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
          }
          toJSON() {
            const t = super.toJSON();
            return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this
            );
          }
        }
        Uo.prototype.isLineCurve = !0;
        class zo extends Mo {
          constructor(t = new Q(), e = new Q(), n = new Q()) {
            super(),
              (this.type = "QuadraticBezierCurve"),
              (this.v0 = t),
              (this.v1 = e),
              (this.v2 = n);
          }
          getPoint(t, e = new Q()) {
            const n = e,
              s = this.v0,
              i = this.v1,
              r = this.v2;
            return n.set(Do(t, s.x, i.x, r.x), Do(t, s.y, i.y, r.y)), n;
          }
          copy(t) {
            return (
              super.copy(t),
              this.v0.copy(t.v0),
              this.v1.copy(t.v1),
              this.v2.copy(t.v2),
              this
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.v0 = this.v0.toArray()),
              (t.v1 = this.v1.toArray()),
              (t.v2 = this.v2.toArray()),
              t
            );
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v0.fromArray(t.v0),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this
            );
          }
        }
        zo.prototype.isQuadraticBezierCurve = !0;
        class Fo extends Mo {
          constructor(t = new ft(), e = new ft(), n = new ft()) {
            super(),
              (this.type = "QuadraticBezierCurve3"),
              (this.v0 = t),
              (this.v1 = e),
              (this.v2 = n);
          }
          getPoint(t, e = new ft()) {
            const n = e,
              s = this.v0,
              i = this.v1,
              r = this.v2;
            return (
              n.set(
                Do(t, s.x, i.x, r.x),
                Do(t, s.y, i.y, r.y),
                Do(t, s.z, i.z, r.z)
              ),
              n
            );
          }
          copy(t) {
            return (
              super.copy(t),
              this.v0.copy(t.v0),
              this.v1.copy(t.v1),
              this.v2.copy(t.v2),
              this
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.v0 = this.v0.toArray()),
              (t.v1 = this.v1.toArray()),
              (t.v2 = this.v2.toArray()),
              t
            );
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v0.fromArray(t.v0),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this
            );
          }
        }
        Fo.prototype.isQuadraticBezierCurve3 = !0;
        class Bo extends Mo {
          constructor(t = []) {
            super(), (this.type = "SplineCurve"), (this.points = t);
          }
          getPoint(t, e = new Q()) {
            const n = e,
              s = this.points,
              i = (s.length - 1) * t,
              r = Math.floor(i),
              o = i - r,
              a = s[0 === r ? r : r - 1],
              c = s[r],
              u = s[r > s.length - 2 ? s.length - 1 : r + 1],
              d = s[r > s.length - 3 ? s.length - 1 : r + 2];
            return (
              n.set(Io(o, a.x, c.x, u.x, d.x), Io(o, a.y, c.y, u.y, d.y)), n
            );
          }
          copy(t) {
            super.copy(t), (this.points = []);
            for (let e = 0, n = t.points.length; e < n; e++) {
              const n = t.points[e];
              this.points.push(n.clone());
            }
            return this;
          }
          toJSON() {
            const t = super.toJSON();
            t.points = [];
            for (let e = 0, n = this.points.length; e < n; e++) {
              const n = this.points[e];
              t.points.push(n.toArray());
            }
            return t;
          }
          fromJSON(t) {
            super.fromJSON(t), (this.points = []);
            for (let e = 0, n = t.points.length; e < n; e++) {
              const n = t.points[e];
              this.points.push(new Q().fromArray(n));
            }
            return this;
          }
        }
        Bo.prototype.isSplineCurve = !0;
        var Ho = Object.freeze({
          __proto__: null,
          ArcCurve: To,
          CatmullRomCurve3: Po,
          CubicBezierCurve: Oo,
          CubicBezierCurve3: ko,
          EllipseCurve: So,
          LineCurve: Uo,
          LineCurve3: class extends Mo {
            constructor(t = new ft(), e = new ft()) {
              super(),
                (this.type = "LineCurve3"),
                (this.isLineCurve3 = !0),
                (this.v1 = t),
                (this.v2 = e);
            }
            getPoint(t, e = new ft()) {
              const n = e;
              return (
                1 === t
                  ? n.copy(this.v2)
                  : (n.copy(this.v2).sub(this.v1),
                    n.multiplyScalar(t).add(this.v1)),
                n
              );
            }
            getPointAt(t, e) {
              return this.getPoint(t, e);
            }
            copy(t) {
              return (
                super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
              );
            }
            toJSON() {
              const t = super.toJSON();
              return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
            }
            fromJSON(t) {
              return (
                super.fromJSON(t),
                this.v1.fromArray(t.v1),
                this.v2.fromArray(t.v2),
                this
              );
            }
          },
          QuadraticBezierCurve: zo,
          QuadraticBezierCurve3: Fo,
          SplineCurve: Bo,
        });
        class Go extends Mo {
          constructor() {
            super(),
              (this.type = "CurvePath"),
              (this.curves = []),
              (this.autoClose = !1);
          }
          add(t) {
            this.curves.push(t);
          }
          closePath() {
            const t = this.curves[0].getPoint(0),
              e = this.curves[this.curves.length - 1].getPoint(1);
            t.equals(e) || this.curves.push(new Uo(e, t));
          }
          getPoint(t, e) {
            const n = t * this.getLength(),
              s = this.getCurveLengths();
            let i = 0;
            for (; i < s.length; ) {
              if (s[i] >= n) {
                const t = s[i] - n,
                  r = this.curves[i],
                  o = r.getLength(),
                  a = 0 === o ? 0 : 1 - t / o;
                return r.getPointAt(a, e);
              }
              i++;
            }
            return null;
          }
          getLength() {
            const t = this.getCurveLengths();
            return t[t.length - 1];
          }
          updateArcLengths() {
            (this.needsUpdate = !0),
              (this.cacheLengths = null),
              this.getCurveLengths();
          }
          getCurveLengths() {
            if (
              this.cacheLengths &&
              this.cacheLengths.length === this.curves.length
            )
              return this.cacheLengths;
            const t = [];
            let e = 0;
            for (let n = 0, s = this.curves.length; n < s; n++)
              (e += this.curves[n].getLength()), t.push(e);
            return (this.cacheLengths = t), t;
          }
          getSpacedPoints(t = 40) {
            const e = [];
            for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
            return this.autoClose && e.push(e[0]), e;
          }
          getPoints(t = 12) {
            const e = [];
            let n;
            for (let s = 0, i = this.curves; s < i.length; s++) {
              const r = i[s],
                o =
                  r && r.isEllipseCurve
                    ? 2 * t
                    : r && (r.isLineCurve || r.isLineCurve3)
                    ? 1
                    : r && r.isSplineCurve
                    ? t * r.points.length
                    : t,
                a = r.getPoints(o);
              for (let t = 0; t < a.length; t++) {
                const s = a[t];
                (n && n.equals(s)) || (e.push(s), (n = s));
              }
            }
            return (
              this.autoClose &&
                e.length > 1 &&
                !e[e.length - 1].equals(e[0]) &&
                e.push(e[0]),
              e
            );
          }
          copy(t) {
            super.copy(t), (this.curves = []);
            for (let e = 0, n = t.curves.length; e < n; e++) {
              const n = t.curves[e];
              this.curves.push(n.clone());
            }
            return (this.autoClose = t.autoClose), this;
          }
          toJSON() {
            const t = super.toJSON();
            (t.autoClose = this.autoClose), (t.curves = []);
            for (let e = 0, n = this.curves.length; e < n; e++) {
              const n = this.curves[e];
              t.curves.push(n.toJSON());
            }
            return t;
          }
          fromJSON(t) {
            super.fromJSON(t),
              (this.autoClose = t.autoClose),
              (this.curves = []);
            for (let e = 0, n = t.curves.length; e < n; e++) {
              const n = t.curves[e];
              this.curves.push(new Ho[n.type]().fromJSON(n));
            }
            return this;
          }
        }
        class Vo extends Go {
          constructor(t) {
            super(),
              (this.type = "Path"),
              (this.currentPoint = new Q()),
              t && this.setFromPoints(t);
          }
          setFromPoints(t) {
            this.moveTo(t[0].x, t[0].y);
            for (let e = 1, n = t.length; e < n; e++)
              this.lineTo(t[e].x, t[e].y);
            return this;
          }
          moveTo(t, e) {
            return this.currentPoint.set(t, e), this;
          }
          lineTo(t, e) {
            const n = new Uo(this.currentPoint.clone(), new Q(t, e));
            return this.curves.push(n), this.currentPoint.set(t, e), this;
          }
          quadraticCurveTo(t, e, n, s) {
            const i = new zo(
              this.currentPoint.clone(),
              new Q(t, e),
              new Q(n, s)
            );
            return this.curves.push(i), this.currentPoint.set(n, s), this;
          }
          bezierCurveTo(t, e, n, s, i, r) {
            const o = new Oo(
              this.currentPoint.clone(),
              new Q(t, e),
              new Q(n, s),
              new Q(i, r)
            );
            return this.curves.push(o), this.currentPoint.set(i, r), this;
          }
          splineThru(t) {
            const e = [this.currentPoint.clone()].concat(t),
              n = new Bo(e);
            return (
              this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
            );
          }
          arc(t, e, n, s, i, r) {
            const o = this.currentPoint.x,
              a = this.currentPoint.y;
            return this.absarc(t + o, e + a, n, s, i, r), this;
          }
          absarc(t, e, n, s, i, r) {
            return this.absellipse(t, e, n, n, s, i, r), this;
          }
          ellipse(t, e, n, s, i, r, o, a) {
            const c = this.currentPoint.x,
              u = this.currentPoint.y;
            return this.absellipse(t + c, e + u, n, s, i, r, o, a), this;
          }
          absellipse(t, e, n, s, i, r, o, a) {
            const c = new So(t, e, n, s, i, r, o, a);
            if (this.curves.length > 0) {
              const t = c.getPoint(0);
              t.equals(this.currentPoint) || this.lineTo(t.x, t.y);
            }
            this.curves.push(c);
            const u = c.getPoint(1);
            return this.currentPoint.copy(u), this;
          }
          copy(t) {
            return super.copy(t), this.currentPoint.copy(t.currentPoint), this;
          }
          toJSON() {
            const t = super.toJSON();
            return (t.currentPoint = this.currentPoint.toArray()), t;
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.currentPoint.fromArray(t.currentPoint),
              this
            );
          }
        }
        class Wo extends Vo {
          constructor(t) {
            super(t),
              (this.uuid = j()),
              (this.type = "Shape"),
              (this.holes = []);
          }
          getPointsHoles(t) {
            const e = [];
            for (let n = 0, s = this.holes.length; n < s; n++)
              e[n] = this.holes[n].getPoints(t);
            return e;
          }
          extractPoints(t) {
            return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
          }
          copy(t) {
            super.copy(t), (this.holes = []);
            for (let e = 0, n = t.holes.length; e < n; e++) {
              const n = t.holes[e];
              this.holes.push(n.clone());
            }
            return this;
          }
          toJSON() {
            const t = super.toJSON();
            (t.uuid = this.uuid), (t.holes = []);
            for (let e = 0, n = this.holes.length; e < n; e++) {
              const n = this.holes[e];
              t.holes.push(n.toJSON());
            }
            return t;
          }
          fromJSON(t) {
            super.fromJSON(t), (this.uuid = t.uuid), (this.holes = []);
            for (let e = 0, n = t.holes.length; e < n; e++) {
              const n = t.holes[e];
              this.holes.push(new Vo().fromJSON(n));
            }
            return this;
          }
        }
        function jo(t, e, n, s, i) {
          let r, o;
          if (
            i ===
            (function (t, e, n, s) {
              let i = 0;
              for (let r = e, o = n - s; r < n; r += s)
                (i += (t[o] - t[r]) * (t[r + 1] + t[o + 1])), (o = r);
              return i;
            })(t, e, n, s) >
              0
          )
            for (r = e; r < n; r += s) o = ha(r, t[r], t[r + 1], o);
          else for (r = n - s; r >= e; r -= s) o = ha(r, t[r], t[r + 1], o);
          return o && oa(o, o.next) && (fa(o), (o = o.next)), o;
        }
        function Xo(t, e) {
          if (!t) return t;
          e || (e = t);
          let n,
            s = t;
          do {
            if (
              ((n = !1),
              s.steiner || (!oa(s, s.next) && 0 !== ra(s.prev, s, s.next)))
            )
              s = s.next;
            else {
              if ((fa(s), (s = e = s.prev), s === s.next)) break;
              n = !0;
            }
          } while (n || s !== e);
          return e;
        }
        function qo(t, e, n, s, i, r, o) {
          if (!t) return;
          !o &&
            r &&
            (function (t, e, n, s) {
              let i = t;
              do {
                null === i.z && (i.z = ea(i.x, i.y, e, n, s)),
                  (i.prevZ = i.prev),
                  (i.nextZ = i.next),
                  (i = i.next);
              } while (i !== t);
              (i.prevZ.nextZ = null),
                (i.prevZ = null),
                (function (t) {
                  let e,
                    n,
                    s,
                    i,
                    r,
                    o,
                    a,
                    c,
                    u = 1;
                  do {
                    for (n = t, t = null, r = null, o = 0; n; ) {
                      for (
                        o++, s = n, a = 0, e = 0;
                        e < u && (a++, (s = s.nextZ), s);
                        e++
                      );
                      for (c = u; a > 0 || (c > 0 && s); )
                        0 !== a && (0 === c || !s || n.z <= s.z)
                          ? ((i = n), (n = n.nextZ), a--)
                          : ((i = s), (s = s.nextZ), c--),
                          r ? (r.nextZ = i) : (t = i),
                          (i.prevZ = r),
                          (r = i);
                      n = s;
                    }
                    (r.nextZ = null), (u *= 2);
                  } while (o > 1);
                })(i);
            })(t, s, i, r);
          let a,
            c,
            u = t;
          for (; t.prev !== t.next; )
            if (((a = t.prev), (c = t.next), r ? Jo(t, s, i, r) : Yo(t)))
              e.push(a.i / n),
                e.push(t.i / n),
                e.push(c.i / n),
                fa(t),
                (t = c.next),
                (u = c.next);
            else if ((t = c) === u) {
              o
                ? 1 === o
                  ? qo((t = Zo(Xo(t), e, n)), e, n, s, i, r, 2)
                  : 2 === o && $o(t, e, n, s, i, r)
                : qo(Xo(t), e, n, s, i, r, 1);
              break;
            }
        }
        function Yo(t) {
          const e = t.prev,
            n = t,
            s = t.next;
          if (ra(e, n, s) >= 0) return !1;
          let i = t.next.next;
          for (; i !== t.prev; ) {
            if (
              sa(e.x, e.y, n.x, n.y, s.x, s.y, i.x, i.y) &&
              ra(i.prev, i, i.next) >= 0
            )
              return !1;
            i = i.next;
          }
          return !0;
        }
        function Jo(t, e, n, s) {
          const i = t.prev,
            r = t,
            o = t.next;
          if (ra(i, r, o) >= 0) return !1;
          const a = i.x < r.x ? (i.x < o.x ? i.x : o.x) : r.x < o.x ? r.x : o.x,
            c = i.y < r.y ? (i.y < o.y ? i.y : o.y) : r.y < o.y ? r.y : o.y,
            u = i.x > r.x ? (i.x > o.x ? i.x : o.x) : r.x > o.x ? r.x : o.x,
            d = i.y > r.y ? (i.y > o.y ? i.y : o.y) : r.y > o.y ? r.y : o.y,
            l = ea(a, c, e, n, s),
            h = ea(u, d, e, n, s);
          let f = t.prevZ,
            m = t.nextZ;
          for (; f && f.z >= l && m && m.z <= h; ) {
            if (
              f !== t.prev &&
              f !== t.next &&
              sa(i.x, i.y, r.x, r.y, o.x, o.y, f.x, f.y) &&
              ra(f.prev, f, f.next) >= 0
            )
              return !1;
            if (
              ((f = f.prevZ),
              m !== t.prev &&
                m !== t.next &&
                sa(i.x, i.y, r.x, r.y, o.x, o.y, m.x, m.y) &&
                ra(m.prev, m, m.next) >= 0)
            )
              return !1;
            m = m.nextZ;
          }
          for (; f && f.z >= l; ) {
            if (
              f !== t.prev &&
              f !== t.next &&
              sa(i.x, i.y, r.x, r.y, o.x, o.y, f.x, f.y) &&
              ra(f.prev, f, f.next) >= 0
            )
              return !1;
            f = f.prevZ;
          }
          for (; m && m.z <= h; ) {
            if (
              m !== t.prev &&
              m !== t.next &&
              sa(i.x, i.y, r.x, r.y, o.x, o.y, m.x, m.y) &&
              ra(m.prev, m, m.next) >= 0
            )
              return !1;
            m = m.nextZ;
          }
          return !0;
        }
        function Zo(t, e, n) {
          let s = t;
          do {
            const i = s.prev,
              r = s.next.next;
            !oa(i, r) &&
              aa(i, s, s.next, r) &&
              da(i, r) &&
              da(r, i) &&
              (e.push(i.i / n),
              e.push(s.i / n),
              e.push(r.i / n),
              fa(s),
              fa(s.next),
              (s = t = r)),
              (s = s.next);
          } while (s !== t);
          return Xo(s);
        }
        function $o(t, e, n, s, i, r) {
          let o = t;
          do {
            let t = o.next.next;
            for (; t !== o.prev; ) {
              if (o.i !== t.i && ia(o, t)) {
                let a = la(o, t);
                return (
                  (o = Xo(o, o.next)),
                  (a = Xo(a, a.next)),
                  qo(o, e, n, s, i, r),
                  void qo(a, e, n, s, i, r)
                );
              }
              t = t.next;
            }
            o = o.next;
          } while (o !== t);
        }
        function Ko(t, e) {
          return t.x - e.x;
        }
        function Qo(t, e) {
          if (
            ((e = (function (t, e) {
              let n = e;
              const s = t.x,
                i = t.y;
              let r,
                o = -1 / 0;
              do {
                if (i <= n.y && i >= n.next.y && n.next.y !== n.y) {
                  const t =
                    n.x + ((i - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
                  if (t <= s && t > o) {
                    if (((o = t), t === s)) {
                      if (i === n.y) return n;
                      if (i === n.next.y) return n.next;
                    }
                    r = n.x < n.next.x ? n : n.next;
                  }
                }
                n = n.next;
              } while (n !== e);
              if (!r) return null;
              if (s === o) return r;
              const a = r,
                c = r.x,
                u = r.y;
              let d,
                l = 1 / 0;
              n = r;
              do {
                s >= n.x &&
                  n.x >= c &&
                  s !== n.x &&
                  sa(i < u ? s : o, i, c, u, i < u ? o : s, i, n.x, n.y) &&
                  ((d = Math.abs(i - n.y) / (s - n.x)),
                  da(n, t) &&
                    (d < l ||
                      (d === l && (n.x > r.x || (n.x === r.x && ta(r, n))))) &&
                    ((r = n), (l = d))),
                  (n = n.next);
              } while (n !== a);
              return r;
            })(t, e)),
            e)
          ) {
            const n = la(e, t);
            Xo(e, e.next), Xo(n, n.next);
          }
        }
        function ta(t, e) {
          return ra(t.prev, t, e.prev) < 0 && ra(e.next, t, t.next) < 0;
        }
        function ea(t, e, n, s, i) {
          return (
            (t =
              1431655765 &
              ((t =
                858993459 &
                ((t =
                  252645135 &
                  ((t = 16711935 & ((t = 32767 * (t - n) * i) | (t << 8))) |
                    (t << 4))) |
                  (t << 2))) |
                (t << 1))) |
            ((e =
              1431655765 &
              ((e =
                858993459 &
                ((e =
                  252645135 &
                  ((e = 16711935 & ((e = 32767 * (e - s) * i) | (e << 8))) |
                    (e << 4))) |
                  (e << 2))) |
                (e << 1))) <<
              1)
          );
        }
        function na(t) {
          let e = t,
            n = t;
          do {
            (e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e), (e = e.next);
          } while (e !== t);
          return n;
        }
        function sa(t, e, n, s, i, r, o, a) {
          return (
            (i - o) * (e - a) - (t - o) * (r - a) >= 0 &&
            (t - o) * (s - a) - (n - o) * (e - a) >= 0 &&
            (n - o) * (r - a) - (i - o) * (s - a) >= 0
          );
        }
        function ia(t, e) {
          return (
            t.next.i !== e.i &&
            t.prev.i !== e.i &&
            !(function (t, e) {
              let n = t;
              do {
                if (
                  n.i !== t.i &&
                  n.next.i !== t.i &&
                  n.i !== e.i &&
                  n.next.i !== e.i &&
                  aa(n, n.next, t, e)
                )
                  return !0;
                n = n.next;
              } while (n !== t);
              return !1;
            })(t, e) &&
            ((da(t, e) &&
              da(e, t) &&
              (function (t, e) {
                let n = t,
                  s = !1;
                const i = (t.x + e.x) / 2,
                  r = (t.y + e.y) / 2;
                do {
                  n.y > r != n.next.y > r &&
                    n.next.y !== n.y &&
                    i <
                      ((n.next.x - n.x) * (r - n.y)) / (n.next.y - n.y) + n.x &&
                    (s = !s),
                    (n = n.next);
                } while (n !== t);
                return s;
              })(t, e) &&
              (ra(t.prev, t, e.prev) || ra(t, e.prev, e))) ||
              (oa(t, e) &&
                ra(t.prev, t, t.next) > 0 &&
                ra(e.prev, e, e.next) > 0))
          );
        }
        function ra(t, e, n) {
          return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
        }
        function oa(t, e) {
          return t.x === e.x && t.y === e.y;
        }
        function aa(t, e, n, s) {
          const i = ua(ra(t, e, n)),
            r = ua(ra(t, e, s)),
            o = ua(ra(n, s, t)),
            a = ua(ra(n, s, e));
          return (
            (i !== r && o !== a) ||
            !(0 !== i || !ca(t, n, e)) ||
            !(0 !== r || !ca(t, s, e)) ||
            !(0 !== o || !ca(n, t, s)) ||
            !(0 !== a || !ca(n, e, s))
          );
        }
        function ca(t, e, n) {
          return (
            e.x <= Math.max(t.x, n.x) &&
            e.x >= Math.min(t.x, n.x) &&
            e.y <= Math.max(t.y, n.y) &&
            e.y >= Math.min(t.y, n.y)
          );
        }
        function ua(t) {
          return t > 0 ? 1 : t < 0 ? -1 : 0;
        }
        function da(t, e) {
          return ra(t.prev, t, t.next) < 0
            ? ra(t, e, t.next) >= 0 && ra(t, t.prev, e) >= 0
            : ra(t, e, t.prev) < 0 || ra(t, t.next, e) < 0;
        }
        function la(t, e) {
          const n = new ma(t.i, t.x, t.y),
            s = new ma(e.i, e.x, e.y),
            i = t.next,
            r = e.prev;
          return (
            (t.next = e),
            (e.prev = t),
            (n.next = i),
            (i.prev = n),
            (s.next = n),
            (n.prev = s),
            (r.next = s),
            (s.prev = r),
            s
          );
        }
        function ha(t, e, n, s) {
          const i = new ma(t, e, n);
          return (
            s
              ? ((i.next = s.next),
                (i.prev = s),
                (s.next.prev = i),
                (s.next = i))
              : ((i.prev = i), (i.next = i)),
            i
          );
        }
        function fa(t) {
          (t.next.prev = t.prev),
            (t.prev.next = t.next),
            t.prevZ && (t.prevZ.nextZ = t.nextZ),
            t.nextZ && (t.nextZ.prevZ = t.prevZ);
        }
        function ma(t, e, n) {
          (this.i = t),
            (this.x = e),
            (this.y = n),
            (this.prev = null),
            (this.next = null),
            (this.z = null),
            (this.prevZ = null),
            (this.nextZ = null),
            (this.steiner = !1);
        }
        class pa {
          static area(t) {
            const e = t.length;
            let n = 0;
            for (let s = e - 1, i = 0; i < e; s = i++)
              n += t[s].x * t[i].y - t[i].x * t[s].y;
            return 0.5 * n;
          }
          static isClockWise(t) {
            return pa.area(t) < 0;
          }
          static triangulateShape(t, e) {
            const n = [],
              s = [],
              i = [];
            ga(t), xa(n, t);
            let r = t.length;
            e.forEach(ga);
            for (let t = 0; t < e.length; t++)
              s.push(r), (r += e[t].length), xa(n, e[t]);
            const o = (function (t, e, n = 2) {
              const s = e && e.length,
                i = s ? e[0] * n : t.length;
              let r = jo(t, 0, i, n, !0);
              const o = [];
              if (!r || r.next === r.prev) return o;
              let a, c, u, d, l, h, f;
              if (
                (s &&
                  (r = (function (t, e, n, s) {
                    const i = [];
                    let r, o, a, c, u;
                    for (r = 0, o = e.length; r < o; r++)
                      (a = e[r] * s),
                        (c = r < o - 1 ? e[r + 1] * s : t.length),
                        (u = jo(t, a, c, s, !1)),
                        u === u.next && (u.steiner = !0),
                        i.push(na(u));
                    for (i.sort(Ko), r = 0; r < i.length; r++)
                      Qo(i[r], n), (n = Xo(n, n.next));
                    return n;
                  })(t, e, r, n)),
                t.length > 80 * n)
              ) {
                (a = u = t[0]), (c = d = t[1]);
                for (let e = n; e < i; e += n)
                  (l = t[e]),
                    (h = t[e + 1]),
                    l < a && (a = l),
                    h < c && (c = h),
                    l > u && (u = l),
                    h > d && (d = h);
                (f = Math.max(u - a, d - c)), (f = 0 !== f ? 1 / f : 0);
              }
              return qo(r, o, n, a, c, f), o;
            })(n, s);
            for (let t = 0; t < o.length; t += 3) i.push(o.slice(t, t + 3));
            return i;
          }
        }
        function ga(t) {
          const e = t.length;
          e > 2 && t[e - 1].equals(t[0]) && t.pop();
        }
        function xa(t, e) {
          for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y);
        }
        class va extends Ze {
          constructor(
            t = new Wo([
              new Q(0.5, 0.5),
              new Q(-0.5, 0.5),
              new Q(-0.5, -0.5),
              new Q(0.5, -0.5),
            ]),
            e = {}
          ) {
            super(),
              (this.type = "ExtrudeGeometry"),
              (this.parameters = { shapes: t, options: e }),
              (t = Array.isArray(t) ? t : [t]);
            const n = this,
              s = [],
              i = [];
            for (let e = 0, n = t.length; e < n; e++) r(t[e]);
            function r(t) {
              const r = [],
                o = void 0 !== e.curveSegments ? e.curveSegments : 12,
                a = void 0 !== e.steps ? e.steps : 1;
              let c = void 0 !== e.depth ? e.depth : 1,
                u = void 0 === e.bevelEnabled || e.bevelEnabled,
                d = void 0 !== e.bevelThickness ? e.bevelThickness : 0.2,
                l = void 0 !== e.bevelSize ? e.bevelSize : d - 0.1,
                h = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                f = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
              const m = e.extrudePath,
                p = void 0 !== e.UVGenerator ? e.UVGenerator : ya;
              void 0 !== e.amount &&
                (console.warn(
                  "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
                ),
                (c = e.amount));
              let g,
                x,
                v,
                y,
                w,
                _ = !1;
              m &&
                ((g = m.getSpacedPoints(a)),
                (_ = !0),
                (u = !1),
                (x = m.computeFrenetFrames(a, !1)),
                (v = new ft()),
                (y = new ft()),
                (w = new ft())),
                u || ((f = 0), (d = 0), (l = 0), (h = 0));
              const b = t.extractPoints(o);
              let M = b.shape;
              const S = b.holes;
              if (!pa.isClockWise(M)) {
                M = M.reverse();
                for (let t = 0, e = S.length; t < e; t++) {
                  const e = S[t];
                  pa.isClockWise(e) && (S[t] = e.reverse());
                }
              }
              const T = pa.triangulateShape(M, S),
                E = M;
              for (let t = 0, e = S.length; t < e; t++) {
                const e = S[t];
                M = M.concat(e);
              }
              function C(t, e, n) {
                return (
                  e ||
                    console.error("THREE.ExtrudeGeometry: vec does not exist"),
                  e.clone().multiplyScalar(n).add(t)
                );
              }
              const A = M.length,
                L = T.length;
              function R(t, e, n) {
                let s, i, r;
                const o = t.x - e.x,
                  a = t.y - e.y,
                  c = n.x - t.x,
                  u = n.y - t.y,
                  d = o * o + a * a,
                  l = o * u - a * c;
                if (Math.abs(l) > Number.EPSILON) {
                  const l = Math.sqrt(d),
                    h = Math.sqrt(c * c + u * u),
                    f = e.x - a / l,
                    m = e.y + o / l,
                    p =
                      ((n.x - u / h - f) * u - (n.y + c / h - m) * c) /
                      (o * u - a * c);
                  (s = f + o * p - t.x), (i = m + a * p - t.y);
                  const g = s * s + i * i;
                  if (g <= 2) return new Q(s, i);
                  r = Math.sqrt(g / 2);
                } else {
                  let t = !1;
                  o > Number.EPSILON
                    ? c > Number.EPSILON && (t = !0)
                    : o < -Number.EPSILON
                    ? c < -Number.EPSILON && (t = !0)
                    : Math.sign(a) === Math.sign(u) && (t = !0),
                    t
                      ? ((s = -a), (i = o), (r = Math.sqrt(d)))
                      : ((s = o), (i = a), (r = Math.sqrt(d / 2)));
                }
                return new Q(s / r, i / r);
              }
              const P = [];
              for (
                let t = 0, e = E.length, n = e - 1, s = t + 1;
                t < e;
                t++, n++, s++
              )
                n === e && (n = 0),
                  s === e && (s = 0),
                  (P[t] = R(E[t], E[n], E[s]));
              const I = [];
              let D,
                N = P.concat();
              for (let t = 0, e = S.length; t < e; t++) {
                const e = S[t];
                D = [];
                for (
                  let t = 0, n = e.length, s = n - 1, i = t + 1;
                  t < n;
                  t++, s++, i++
                )
                  s === n && (s = 0),
                    i === n && (i = 0),
                    (D[t] = R(e[t], e[s], e[i]));
                I.push(D), (N = N.concat(D));
              }
              for (let t = 0; t < f; t++) {
                const e = t / f,
                  n = d * Math.cos((e * Math.PI) / 2),
                  s = l * Math.sin((e * Math.PI) / 2) + h;
                for (let t = 0, e = E.length; t < e; t++) {
                  const e = C(E[t], P[t], s);
                  U(e.x, e.y, -n);
                }
                for (let t = 0, e = S.length; t < e; t++) {
                  const e = S[t];
                  D = I[t];
                  for (let t = 0, i = e.length; t < i; t++) {
                    const i = C(e[t], D[t], s);
                    U(i.x, i.y, -n);
                  }
                }
              }
              const O = l + h;
              for (let t = 0; t < A; t++) {
                const e = u ? C(M[t], N[t], O) : M[t];
                _
                  ? (y.copy(x.normals[0]).multiplyScalar(e.x),
                    v.copy(x.binormals[0]).multiplyScalar(e.y),
                    w.copy(g[0]).add(y).add(v),
                    U(w.x, w.y, w.z))
                  : U(e.x, e.y, 0);
              }
              for (let t = 1; t <= a; t++)
                for (let e = 0; e < A; e++) {
                  const n = u ? C(M[e], N[e], O) : M[e];
                  _
                    ? (y.copy(x.normals[t]).multiplyScalar(n.x),
                      v.copy(x.binormals[t]).multiplyScalar(n.y),
                      w.copy(g[t]).add(y).add(v),
                      U(w.x, w.y, w.z))
                    : U(n.x, n.y, (c / a) * t);
                }
              for (let t = f - 1; t >= 0; t--) {
                const e = t / f,
                  n = d * Math.cos((e * Math.PI) / 2),
                  s = l * Math.sin((e * Math.PI) / 2) + h;
                for (let t = 0, e = E.length; t < e; t++) {
                  const e = C(E[t], P[t], s);
                  U(e.x, e.y, c + n);
                }
                for (let t = 0, e = S.length; t < e; t++) {
                  const e = S[t];
                  D = I[t];
                  for (let t = 0, i = e.length; t < i; t++) {
                    const i = C(e[t], D[t], s);
                    _
                      ? U(i.x, i.y + g[a - 1].y, g[a - 1].x + n)
                      : U(i.x, i.y, c + n);
                  }
                }
              }
              function k(t, e) {
                let n = t.length;
                for (; --n >= 0; ) {
                  const s = n;
                  let i = n - 1;
                  i < 0 && (i = t.length - 1);
                  for (let t = 0, n = a + 2 * f; t < n; t++) {
                    const n = A * t,
                      r = A * (t + 1);
                    F(e + s + n, e + i + n, e + i + r, e + s + r);
                  }
                }
              }
              function U(t, e, n) {
                r.push(t), r.push(e), r.push(n);
              }
              function z(t, e, i) {
                B(t), B(e), B(i);
                const r = s.length / 3,
                  o = p.generateTopUV(n, s, r - 3, r - 2, r - 1);
                H(o[0]), H(o[1]), H(o[2]);
              }
              function F(t, e, i, r) {
                B(t), B(e), B(r), B(e), B(i), B(r);
                const o = s.length / 3,
                  a = p.generateSideWallUV(n, s, o - 6, o - 3, o - 2, o - 1);
                H(a[0]), H(a[1]), H(a[3]), H(a[1]), H(a[2]), H(a[3]);
              }
              function B(t) {
                s.push(r[3 * t + 0]),
                  s.push(r[3 * t + 1]),
                  s.push(r[3 * t + 2]);
              }
              function H(t) {
                i.push(t.x), i.push(t.y);
              }
              !(function () {
                const t = s.length / 3;
                if (u) {
                  let t = 0,
                    e = A * t;
                  for (let t = 0; t < L; t++) {
                    const n = T[t];
                    z(n[2] + e, n[1] + e, n[0] + e);
                  }
                  (t = a + 2 * f), (e = A * t);
                  for (let t = 0; t < L; t++) {
                    const n = T[t];
                    z(n[0] + e, n[1] + e, n[2] + e);
                  }
                } else {
                  for (let t = 0; t < L; t++) {
                    const e = T[t];
                    z(e[2], e[1], e[0]);
                  }
                  for (let t = 0; t < L; t++) {
                    const e = T[t];
                    z(e[0] + A * a, e[1] + A * a, e[2] + A * a);
                  }
                }
                n.addGroup(t, s.length / 3 - t, 0);
              })(),
                (function () {
                  const t = s.length / 3;
                  let e = 0;
                  k(E, e), (e += E.length);
                  for (let t = 0, n = S.length; t < n; t++) {
                    const n = S[t];
                    k(n, e), (e += n.length);
                  }
                  n.addGroup(t, s.length / 3 - t, 1);
                })();
            }
            this.setAttribute("position", new Ge(s, 3)),
              this.setAttribute("uv", new Ge(i, 2)),
              this.computeVertexNormals();
          }
          toJSON() {
            const t = super.toJSON();
            return (function (t, e, n) {
              if (((n.shapes = []), Array.isArray(t)))
                for (let e = 0, s = t.length; e < s; e++) {
                  const s = t[e];
                  n.shapes.push(s.uuid);
                }
              else n.shapes.push(t.uuid);
              return (
                void 0 !== e.extrudePath &&
                  (n.options.extrudePath = e.extrudePath.toJSON()),
                n
              );
            })(this.parameters.shapes, this.parameters.options, t);
          }
          static fromJSON(t, e) {
            const n = [];
            for (let s = 0, i = t.shapes.length; s < i; s++) {
              const i = e[t.shapes[s]];
              n.push(i);
            }
            const s = t.options.extrudePath;
            return (
              void 0 !== s &&
                (t.options.extrudePath = new Ho[s.type]().fromJSON(s)),
              new va(n, t.options)
            );
          }
        }
        const ya = {
          generateTopUV: function (t, e, n, s, i) {
            const r = e[3 * n],
              o = e[3 * n + 1],
              a = e[3 * s],
              c = e[3 * s + 1],
              u = e[3 * i],
              d = e[3 * i + 1];
            return [new Q(r, o), new Q(a, c), new Q(u, d)];
          },
          generateSideWallUV: function (t, e, n, s, i, r) {
            const o = e[3 * n],
              a = e[3 * n + 1],
              c = e[3 * n + 2],
              u = e[3 * s],
              d = e[3 * s + 1],
              l = e[3 * s + 2],
              h = e[3 * i],
              f = e[3 * i + 1],
              m = e[3 * i + 2],
              p = e[3 * r],
              g = e[3 * r + 1],
              x = e[3 * r + 2];
            return Math.abs(a - d) < Math.abs(o - u)
              ? [
                  new Q(o, 1 - c),
                  new Q(u, 1 - l),
                  new Q(h, 1 - m),
                  new Q(p, 1 - x),
                ]
              : [
                  new Q(a, 1 - c),
                  new Q(d, 1 - l),
                  new Q(f, 1 - m),
                  new Q(g, 1 - x),
                ];
          },
        };
        class wa extends Ze {
          constructor(
            t = new Wo([new Q(0, 0.5), new Q(-0.5, -0.5), new Q(0.5, -0.5)]),
            e = 12
          ) {
            super(),
              (this.type = "ShapeGeometry"),
              (this.parameters = { shapes: t, curveSegments: e });
            const n = [],
              s = [],
              i = [],
              r = [];
            let o = 0,
              a = 0;
            if (!1 === Array.isArray(t)) c(t);
            else
              for (let e = 0; e < t.length; e++)
                c(t[e]), this.addGroup(o, a, e), (o += a), (a = 0);
            function c(t) {
              const o = s.length / 3,
                c = t.extractPoints(e);
              let u = c.shape;
              const d = c.holes;
              !1 === pa.isClockWise(u) && (u = u.reverse());
              for (let t = 0, e = d.length; t < e; t++) {
                const e = d[t];
                !0 === pa.isClockWise(e) && (d[t] = e.reverse());
              }
              const l = pa.triangulateShape(u, d);
              for (let t = 0, e = d.length; t < e; t++) {
                const e = d[t];
                u = u.concat(e);
              }
              for (let t = 0, e = u.length; t < e; t++) {
                const e = u[t];
                s.push(e.x, e.y, 0), i.push(0, 0, 1), r.push(e.x, e.y);
              }
              for (let t = 0, e = l.length; t < e; t++) {
                const e = l[t],
                  s = e[0] + o,
                  i = e[1] + o,
                  r = e[2] + o;
                n.push(s, i, r), (a += 3);
              }
            }
            this.setIndex(n),
              this.setAttribute("position", new Ge(s, 3)),
              this.setAttribute("normal", new Ge(i, 3)),
              this.setAttribute("uv", new Ge(r, 2));
          }
          toJSON() {
            const t = super.toJSON();
            return (function (t, e) {
              if (((e.shapes = []), Array.isArray(t)))
                for (let n = 0, s = t.length; n < s; n++) {
                  const s = t[n];
                  e.shapes.push(s.uuid);
                }
              else e.shapes.push(t.uuid);
              return e;
            })(this.parameters.shapes, t);
          }
          static fromJSON(t, e) {
            const n = [];
            for (let s = 0, i = t.shapes.length; s < i; s++) {
              const i = e[t.shapes[s]];
              n.push(i);
            }
            return new wa(n, t.curveSegments);
          }
        }
        (class extends Ae {
          constructor(t) {
            super(),
              (this.type = "ShadowMaterial"),
              (this.color = new Oe(0)),
              (this.transparent = !0),
              this.setValues(t);
          }
          copy(t) {
            return super.copy(t), this.color.copy(t.color), this;
          }
        }).prototype.isShadowMaterial = !0;
        class _a extends Ae {
          constructor(t) {
            super(),
              (this.defines = { STANDARD: "" }),
              (this.type = "MeshStandardMaterial"),
              (this.color = new Oe(16777215)),
              (this.roughness = 1),
              (this.metalness = 0),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.emissive = new Oe(0)),
              (this.emissiveIntensity = 1),
              (this.emissiveMap = null),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = 0),
              (this.normalScale = new Q(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.roughnessMap = null),
              (this.metalnessMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.envMapIntensity = 1),
              (this.refractionRatio = 0.98),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = "round"),
              (this.wireframeLinejoin = "round"),
              (this.flatShading = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.defines = { STANDARD: "" }),
              this.color.copy(t.color),
              (this.roughness = t.roughness),
              (this.metalness = t.metalness),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              this.emissive.copy(t.emissive),
              (this.emissiveMap = t.emissiveMap),
              (this.emissiveIntensity = t.emissiveIntensity),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.roughnessMap = t.roughnessMap),
              (this.metalnessMap = t.metalnessMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.envMapIntensity = t.envMapIntensity),
              (this.refractionRatio = t.refractionRatio),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.flatShading = t.flatShading),
              this
            );
          }
        }
        _a.prototype.isMeshStandardMaterial = !0;
        class ba extends _a {
          constructor(t) {
            super(),
              (this.defines = { STANDARD: "", PHYSICAL: "" }),
              (this.type = "MeshPhysicalMaterial"),
              (this.clearcoatMap = null),
              (this.clearcoatRoughness = 0),
              (this.clearcoatRoughnessMap = null),
              (this.clearcoatNormalScale = new Q(1, 1)),
              (this.clearcoatNormalMap = null),
              (this.ior = 1.5),
              Object.defineProperty(this, "reflectivity", {
                get: function () {
                  return X((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
                },
                set: function (t) {
                  this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
                },
              }),
              (this.sheenColor = new Oe(0)),
              (this.sheenColorMap = null),
              (this.sheenRoughness = 1),
              (this.sheenRoughnessMap = null),
              (this.transmissionMap = null),
              (this.thickness = 0.01),
              (this.thicknessMap = null),
              (this.attenuationDistance = 0),
              (this.attenuationColor = new Oe(1, 1, 1)),
              (this.specularIntensity = 1),
              (this.specularIntensityMap = null),
              (this.specularColor = new Oe(1, 1, 1)),
              (this.specularColorMap = null),
              (this._sheen = 0),
              (this._clearcoat = 0),
              (this._transmission = 0),
              this.setValues(t);
          }
          get sheen() {
            return this._sheen;
          }
          set sheen(t) {
            this._sheen > 0 != t > 0 && this.version++, (this._sheen = t);
          }
          get clearcoat() {
            return this._clearcoat;
          }
          set clearcoat(t) {
            this._clearcoat > 0 != t > 0 && this.version++,
              (this._clearcoat = t);
          }
          get transmission() {
            return this._transmission;
          }
          set transmission(t) {
            this._transmission > 0 != t > 0 && this.version++,
              (this._transmission = t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.defines = { STANDARD: "", PHYSICAL: "" }),
              (this.clearcoat = t.clearcoat),
              (this.clearcoatMap = t.clearcoatMap),
              (this.clearcoatRoughness = t.clearcoatRoughness),
              (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
              (this.clearcoatNormalMap = t.clearcoatNormalMap),
              this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
              (this.ior = t.ior),
              (this.sheen = t.sheen),
              this.sheenColor.copy(t.sheenColor),
              (this.sheenColorMap = t.sheenColorMap),
              (this.sheenRoughness = t.sheenRoughness),
              (this.sheenRoughnessMap = t.sheenRoughnessMap),
              (this.transmission = t.transmission),
              (this.transmissionMap = t.transmissionMap),
              (this.thickness = t.thickness),
              (this.thicknessMap = t.thicknessMap),
              (this.attenuationDistance = t.attenuationDistance),
              this.attenuationColor.copy(t.attenuationColor),
              (this.specularIntensity = t.specularIntensity),
              (this.specularIntensityMap = t.specularIntensityMap),
              this.specularColor.copy(t.specularColor),
              (this.specularColorMap = t.specularColorMap),
              this
            );
          }
        }
        ba.prototype.isMeshPhysicalMaterial = !0;
        (class extends Ae {
          constructor(t) {
            super(),
              (this.type = "MeshPhongMaterial"),
              (this.color = new Oe(16777215)),
              (this.specular = new Oe(1118481)),
              (this.shininess = 30),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.emissive = new Oe(0)),
              (this.emissiveIntensity = 1),
              (this.emissiveMap = null),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = 0),
              (this.normalScale = new Q(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.specularMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.combine = 0),
              (this.reflectivity = 1),
              (this.refractionRatio = 0.98),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = "round"),
              (this.wireframeLinejoin = "round"),
              (this.flatShading = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              this.specular.copy(t.specular),
              (this.shininess = t.shininess),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              this.emissive.copy(t.emissive),
              (this.emissiveMap = t.emissiveMap),
              (this.emissiveIntensity = t.emissiveIntensity),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.specularMap = t.specularMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.combine = t.combine),
              (this.reflectivity = t.reflectivity),
              (this.refractionRatio = t.refractionRatio),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.flatShading = t.flatShading),
              this
            );
          }
        }).prototype.isMeshPhongMaterial = !0;
        (class extends Ae {
          constructor(t) {
            super(),
              (this.defines = { TOON: "" }),
              (this.type = "MeshToonMaterial"),
              (this.color = new Oe(16777215)),
              (this.map = null),
              (this.gradientMap = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.emissive = new Oe(0)),
              (this.emissiveIntensity = 1),
              (this.emissiveMap = null),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = 0),
              (this.normalScale = new Q(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.alphaMap = null),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = "round"),
              (this.wireframeLinejoin = "round"),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.gradientMap = t.gradientMap),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              this.emissive.copy(t.emissive),
              (this.emissiveMap = t.emissiveMap),
              (this.emissiveIntensity = t.emissiveIntensity),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.alphaMap = t.alphaMap),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              this
            );
          }
        }).prototype.isMeshToonMaterial = !0;
        (class extends Ae {
          constructor(t) {
            super(),
              (this.type = "MeshNormalMaterial"),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = 0),
              (this.normalScale = new Q(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.fog = !1),
              (this.flatShading = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.flatShading = t.flatShading),
              this
            );
          }
        }).prototype.isMeshNormalMaterial = !0;
        (class extends Ae {
          constructor(t) {
            super(),
              (this.type = "MeshLambertMaterial"),
              (this.color = new Oe(16777215)),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.emissive = new Oe(0)),
              (this.emissiveIntensity = 1),
              (this.emissiveMap = null),
              (this.specularMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.combine = 0),
              (this.reflectivity = 1),
              (this.refractionRatio = 0.98),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = "round"),
              (this.wireframeLinejoin = "round"),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              this.emissive.copy(t.emissive),
              (this.emissiveMap = t.emissiveMap),
              (this.emissiveIntensity = t.emissiveIntensity),
              (this.specularMap = t.specularMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.combine = t.combine),
              (this.reflectivity = t.reflectivity),
              (this.refractionRatio = t.refractionRatio),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              this
            );
          }
        }).prototype.isMeshLambertMaterial = !0;
        (class extends Ae {
          constructor(t) {
            super(),
              (this.defines = { MATCAP: "" }),
              (this.type = "MeshMatcapMaterial"),
              (this.color = new Oe(16777215)),
              (this.matcap = null),
              (this.map = null),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = 0),
              (this.normalScale = new Q(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.alphaMap = null),
              (this.flatShading = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.defines = { MATCAP: "" }),
              this.color.copy(t.color),
              (this.matcap = t.matcap),
              (this.map = t.map),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.alphaMap = t.alphaMap),
              (this.flatShading = t.flatShading),
              this
            );
          }
        }).prototype.isMeshMatcapMaterial = !0;
        (class extends so {
          constructor(t) {
            super(),
              (this.type = "LineDashedMaterial"),
              (this.scale = 1),
              (this.dashSize = 3),
              (this.gapSize = 1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.scale = t.scale),
              (this.dashSize = t.dashSize),
              (this.gapSize = t.gapSize),
              this
            );
          }
        }).prototype.isLineDashedMaterial = !0;
        const Ma = {
          arraySlice: function (t, e, n) {
            return Ma.isTypedArray(t)
              ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length))
              : t.slice(e, n);
          },
          convertArray: function (t, e, n) {
            return !t || (!n && t.constructor === e)
              ? t
              : "number" == typeof e.BYTES_PER_ELEMENT
              ? new e(t)
              : Array.prototype.slice.call(t);
          },
          isTypedArray: function (t) {
            return ArrayBuffer.isView(t) && !(t instanceof DataView);
          },
          getKeyframeOrder: function (t) {
            const e = t.length,
              n = new Array(e);
            for (let t = 0; t !== e; ++t) n[t] = t;
            return (
              n.sort(function (e, n) {
                return t[e] - t[n];
              }),
              n
            );
          },
          sortedArray: function (t, e, n) {
            const s = t.length,
              i = new t.constructor(s);
            for (let r = 0, o = 0; o !== s; ++r) {
              const s = n[r] * e;
              for (let n = 0; n !== e; ++n) i[o++] = t[s + n];
            }
            return i;
          },
          flattenJSON: function (t, e, n, s) {
            let i = 1,
              r = t[0];
            for (; void 0 !== r && void 0 === r[s]; ) r = t[i++];
            if (void 0 === r) return;
            let o = r[s];
            if (void 0 !== o)
              if (Array.isArray(o))
                do {
                  (o = r[s]),
                    void 0 !== o && (e.push(r.time), n.push.apply(n, o)),
                    (r = t[i++]);
                } while (void 0 !== r);
              else if (void 0 !== o.toArray)
                do {
                  (o = r[s]),
                    void 0 !== o && (e.push(r.time), o.toArray(n, n.length)),
                    (r = t[i++]);
                } while (void 0 !== r);
              else
                do {
                  (o = r[s]),
                    void 0 !== o && (e.push(r.time), n.push(o)),
                    (r = t[i++]);
                } while (void 0 !== r);
          },
          subclip: function (t, e, n, s, i = 30) {
            const r = t.clone();
            r.name = e;
            const o = [];
            for (let t = 0; t < r.tracks.length; ++t) {
              const e = r.tracks[t],
                a = e.getValueSize(),
                c = [],
                u = [];
              for (let t = 0; t < e.times.length; ++t) {
                const r = e.times[t] * i;
                if (!(r < n || r >= s)) {
                  c.push(e.times[t]);
                  for (let n = 0; n < a; ++n) u.push(e.values[t * a + n]);
                }
              }
              0 !== c.length &&
                ((e.times = Ma.convertArray(c, e.times.constructor)),
                (e.values = Ma.convertArray(u, e.values.constructor)),
                o.push(e));
            }
            r.tracks = o;
            let a = 1 / 0;
            for (let t = 0; t < r.tracks.length; ++t)
              a > r.tracks[t].times[0] && (a = r.tracks[t].times[0]);
            for (let t = 0; t < r.tracks.length; ++t) r.tracks[t].shift(-1 * a);
            return r.resetDuration(), r;
          },
          makeClipAdditive: function (t, e = 0, n = t, s = 30) {
            s <= 0 && (s = 30);
            const i = n.tracks.length,
              r = e / s;
            for (let e = 0; e < i; ++e) {
              const s = n.tracks[e],
                i = s.ValueTypeName;
              if ("bool" === i || "string" === i) continue;
              const o = t.tracks.find(function (t) {
                return t.name === s.name && t.ValueTypeName === i;
              });
              if (void 0 === o) continue;
              let a = 0;
              const c = s.getValueSize();
              s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
                (a = c / 3);
              let u = 0;
              const d = o.getValueSize();
              o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
                (u = d / 3);
              const l = s.times.length - 1;
              let h;
              if (r <= s.times[0]) {
                const t = a,
                  e = c - a;
                h = Ma.arraySlice(s.values, t, e);
              } else if (r >= s.times[l]) {
                const t = l * c + a,
                  e = t + c - a;
                h = Ma.arraySlice(s.values, t, e);
              } else {
                const t = s.createInterpolant(),
                  e = a,
                  n = c - a;
                t.evaluate(r), (h = Ma.arraySlice(t.resultBuffer, e, n));
              }
              "quaternion" === i &&
                new ht().fromArray(h).normalize().conjugate().toArray(h);
              const f = o.times.length;
              for (let t = 0; t < f; ++t) {
                const e = t * d + u;
                if ("quaternion" === i)
                  ht.multiplyQuaternionsFlat(o.values, e, h, 0, o.values, e);
                else {
                  const t = d - 2 * u;
                  for (let n = 0; n < t; ++n) o.values[e + n] -= h[n];
                }
              }
            }
            return (t.blendMode = 2501), t;
          },
        };
        class Sa {
          constructor(t, e, n, s) {
            (this.parameterPositions = t),
              (this._cachedIndex = 0),
              (this.resultBuffer = void 0 !== s ? s : new e.constructor(n)),
              (this.sampleValues = e),
              (this.valueSize = n),
              (this.settings = null),
              (this.DefaultSettings_ = {});
          }
          evaluate(t) {
            const e = this.parameterPositions;
            let n = this._cachedIndex,
              s = e[n],
              i = e[n - 1];
            t: {
              e: {
                let r;
                n: {
                  s: if (!(t < s)) {
                    for (let r = n + 2; ; ) {
                      if (void 0 === s) {
                        if (t < i) break s;
                        return (
                          (n = e.length),
                          (this._cachedIndex = n),
                          this.afterEnd_(n - 1, t, i)
                        );
                      }
                      if (n === r) break;
                      if (((i = s), (s = e[++n]), t < s)) break e;
                    }
                    r = e.length;
                    break n;
                  }
                  if (t >= i) break t;
                  {
                    const o = e[1];
                    t < o && ((n = 2), (i = o));
                    for (let r = n - 2; ; ) {
                      if (void 0 === i)
                        return (
                          (this._cachedIndex = 0), this.beforeStart_(0, t, s)
                        );
                      if (n === r) break;
                      if (((s = i), (i = e[--n - 1]), t >= i)) break e;
                    }
                    (r = n), (n = 0);
                  }
                }
                for (; n < r; ) {
                  const s = (n + r) >>> 1;
                  t < e[s] ? (r = s) : (n = s + 1);
                }
                if (((s = e[n]), (i = e[n - 1]), void 0 === i))
                  return (this._cachedIndex = 0), this.beforeStart_(0, t, s);
                if (void 0 === s)
                  return (
                    (n = e.length),
                    (this._cachedIndex = n),
                    this.afterEnd_(n - 1, i, t)
                  );
              }
              (this._cachedIndex = n), this.intervalChanged_(n, i, s);
            }
            return this.interpolate_(n, i, t, s);
          }
          getSettings_() {
            return this.settings || this.DefaultSettings_;
          }
          copySampleValue_(t) {
            const e = this.resultBuffer,
              n = this.sampleValues,
              s = this.valueSize,
              i = t * s;
            for (let t = 0; t !== s; ++t) e[t] = n[i + t];
            return e;
          }
          interpolate_() {
            throw new Error("call to abstract method");
          }
          intervalChanged_() {}
        }
        (Sa.prototype.beforeStart_ = Sa.prototype.copySampleValue_),
          (Sa.prototype.afterEnd_ = Sa.prototype.copySampleValue_);
        class Ta extends Sa {
          constructor(t, e, n, s) {
            super(t, e, n, s),
              (this._weightPrev = -0),
              (this._offsetPrev = -0),
              (this._weightNext = -0),
              (this._offsetNext = -0),
              (this.DefaultSettings_ = { endingStart: A, endingEnd: A });
          }
          intervalChanged_(t, e, n) {
            const s = this.parameterPositions;
            let i = t - 2,
              r = t + 1,
              o = s[i],
              a = s[r];
            if (void 0 === o)
              switch (this.getSettings_().endingStart) {
                case L:
                  (i = t), (o = 2 * e - n);
                  break;
                case R:
                  (i = s.length - 2), (o = e + s[i] - s[i + 1]);
                  break;
                default:
                  (i = t), (o = n);
              }
            if (void 0 === a)
              switch (this.getSettings_().endingEnd) {
                case L:
                  (r = t), (a = 2 * n - e);
                  break;
                case R:
                  (r = 1), (a = n + s[1] - s[0]);
                  break;
                default:
                  (r = t - 1), (a = e);
              }
            const c = 0.5 * (n - e),
              u = this.valueSize;
            (this._weightPrev = c / (e - o)),
              (this._weightNext = c / (a - n)),
              (this._offsetPrev = i * u),
              (this._offsetNext = r * u);
          }
          interpolate_(t, e, n, s) {
            const i = this.resultBuffer,
              r = this.sampleValues,
              o = this.valueSize,
              a = t * o,
              c = a - o,
              u = this._offsetPrev,
              d = this._offsetNext,
              l = this._weightPrev,
              h = this._weightNext,
              f = (n - e) / (s - e),
              m = f * f,
              p = m * f,
              g = -l * p + 2 * l * m - l * f,
              x = (1 + l) * p + (-1.5 - 2 * l) * m + (-0.5 + l) * f + 1,
              v = (-1 - h) * p + (1.5 + h) * m + 0.5 * f,
              y = h * p - h * m;
            for (let t = 0; t !== o; ++t)
              i[t] = g * r[u + t] + x * r[c + t] + v * r[a + t] + y * r[d + t];
            return i;
          }
        }
        class Ea extends Sa {
          constructor(t, e, n, s) {
            super(t, e, n, s);
          }
          interpolate_(t, e, n, s) {
            const i = this.resultBuffer,
              r = this.sampleValues,
              o = this.valueSize,
              a = t * o,
              c = a - o,
              u = (n - e) / (s - e),
              d = 1 - u;
            for (let t = 0; t !== o; ++t) i[t] = r[c + t] * d + r[a + t] * u;
            return i;
          }
        }
        class Ca extends Sa {
          constructor(t, e, n, s) {
            super(t, e, n, s);
          }
          interpolate_(t) {
            return this.copySampleValue_(t - 1);
          }
        }
        class Aa {
          constructor(t, e, n, s) {
            if (void 0 === t)
              throw new Error("THREE.KeyframeTrack: track name is undefined");
            if (void 0 === e || 0 === e.length)
              throw new Error(
                "THREE.KeyframeTrack: no keyframes in track named " + t
              );
            (this.name = t),
              (this.times = Ma.convertArray(e, this.TimeBufferType)),
              (this.values = Ma.convertArray(n, this.ValueBufferType)),
              this.setInterpolation(s || this.DefaultInterpolation);
          }
          static toJSON(t) {
            const e = t.constructor;
            let n;
            if (e.toJSON !== this.toJSON) n = e.toJSON(t);
            else {
              n = {
                name: t.name,
                times: Ma.convertArray(t.times, Array),
                values: Ma.convertArray(t.values, Array),
              };
              const e = t.getInterpolation();
              e !== t.DefaultInterpolation && (n.interpolation = e);
            }
            return (n.type = t.ValueTypeName), n;
          }
          InterpolantFactoryMethodDiscrete(t) {
            return new Ca(this.times, this.values, this.getValueSize(), t);
          }
          InterpolantFactoryMethodLinear(t) {
            return new Ea(this.times, this.values, this.getValueSize(), t);
          }
          InterpolantFactoryMethodSmooth(t) {
            return new Ta(this.times, this.values, this.getValueSize(), t);
          }
          setInterpolation(t) {
            let e;
            switch (t) {
              case T:
                e = this.InterpolantFactoryMethodDiscrete;
                break;
              case E:
                e = this.InterpolantFactoryMethodLinear;
                break;
              case C:
                e = this.InterpolantFactoryMethodSmooth;
            }
            if (void 0 === e) {
              const e =
                "unsupported interpolation for " +
                this.ValueTypeName +
                " keyframe track named " +
                this.name;
              if (void 0 === this.createInterpolant) {
                if (t === this.DefaultInterpolation) throw new Error(e);
                this.setInterpolation(this.DefaultInterpolation);
              }
              return console.warn("THREE.KeyframeTrack:", e), this;
            }
            return (this.createInterpolant = e), this;
          }
          getInterpolation() {
            switch (this.createInterpolant) {
              case this.InterpolantFactoryMethodDiscrete:
                return T;
              case this.InterpolantFactoryMethodLinear:
                return E;
              case this.InterpolantFactoryMethodSmooth:
                return C;
            }
          }
          getValueSize() {
            return this.values.length / this.times.length;
          }
          shift(t) {
            if (0 !== t) {
              const e = this.times;
              for (let n = 0, s = e.length; n !== s; ++n) e[n] += t;
            }
            return this;
          }
          scale(t) {
            if (1 !== t) {
              const e = this.times;
              for (let n = 0, s = e.length; n !== s; ++n) e[n] *= t;
            }
            return this;
          }
          trim(t, e) {
            const n = this.times,
              s = n.length;
            let i = 0,
              r = s - 1;
            for (; i !== s && n[i] < t; ) ++i;
            for (; -1 !== r && n[r] > e; ) --r;
            if ((++r, 0 !== i || r !== s)) {
              i >= r && ((r = Math.max(r, 1)), (i = r - 1));
              const t = this.getValueSize();
              (this.times = Ma.arraySlice(n, i, r)),
                (this.values = Ma.arraySlice(this.values, i * t, r * t));
            }
            return this;
          }
          validate() {
            let t = !0;
            const e = this.getValueSize();
            e - Math.floor(e) != 0 &&
              (console.error(
                "THREE.KeyframeTrack: Invalid value size in track.",
                this
              ),
              (t = !1));
            const n = this.times,
              s = this.values,
              i = n.length;
            0 === i &&
              (console.error("THREE.KeyframeTrack: Track is empty.", this),
              (t = !1));
            let r = null;
            for (let e = 0; e !== i; e++) {
              const s = n[e];
              if ("number" == typeof s && isNaN(s)) {
                console.error(
                  "THREE.KeyframeTrack: Time is not a valid number.",
                  this,
                  e,
                  s
                ),
                  (t = !1);
                break;
              }
              if (null !== r && r > s) {
                console.error(
                  "THREE.KeyframeTrack: Out of order keys.",
                  this,
                  e,
                  s,
                  r
                ),
                  (t = !1);
                break;
              }
              r = s;
            }
            if (void 0 !== s && Ma.isTypedArray(s))
              for (let e = 0, n = s.length; e !== n; ++e) {
                const n = s[e];
                if (isNaN(n)) {
                  console.error(
                    "THREE.KeyframeTrack: Value is not a valid number.",
                    this,
                    e,
                    n
                  ),
                    (t = !1);
                  break;
                }
              }
            return t;
          }
          optimize() {
            const t = Ma.arraySlice(this.times),
              e = Ma.arraySlice(this.values),
              n = this.getValueSize(),
              s = this.getInterpolation() === C,
              i = t.length - 1;
            let r = 1;
            for (let o = 1; o < i; ++o) {
              let i = !1;
              const a = t[o];
              if (a !== t[o + 1] && (1 !== o || a !== t[0]))
                if (s) i = !0;
                else {
                  const t = o * n,
                    s = t - n,
                    r = t + n;
                  for (let o = 0; o !== n; ++o) {
                    const n = e[t + o];
                    if (n !== e[s + o] || n !== e[r + o]) {
                      i = !0;
                      break;
                    }
                  }
                }
              if (i) {
                if (o !== r) {
                  t[r] = t[o];
                  const s = o * n,
                    i = r * n;
                  for (let t = 0; t !== n; ++t) e[i + t] = e[s + t];
                }
                ++r;
              }
            }
            if (i > 0) {
              t[r] = t[i];
              for (let t = i * n, s = r * n, o = 0; o !== n; ++o)
                e[s + o] = e[t + o];
              ++r;
            }
            return (
              r !== t.length
                ? ((this.times = Ma.arraySlice(t, 0, r)),
                  (this.values = Ma.arraySlice(e, 0, r * n)))
                : ((this.times = t), (this.values = e)),
              this
            );
          }
          clone() {
            const t = Ma.arraySlice(this.times, 0),
              e = Ma.arraySlice(this.values, 0),
              n = new (0, this.constructor)(this.name, t, e);
            return (n.createInterpolant = this.createInterpolant), n;
          }
        }
        (Aa.prototype.TimeBufferType = Float32Array),
          (Aa.prototype.ValueBufferType = Float32Array),
          (Aa.prototype.DefaultInterpolation = E);
        class La extends Aa {}
        (La.prototype.ValueTypeName = "bool"),
          (La.prototype.ValueBufferType = Array),
          (La.prototype.DefaultInterpolation = T),
          (La.prototype.InterpolantFactoryMethodLinear = void 0),
          (La.prototype.InterpolantFactoryMethodSmooth = void 0);
        class Ra extends Aa {}
        Ra.prototype.ValueTypeName = "color";
        class Pa extends Aa {}
        Pa.prototype.ValueTypeName = "number";
        class Ia extends Sa {
          constructor(t, e, n, s) {
            super(t, e, n, s);
          }
          interpolate_(t, e, n, s) {
            const i = this.resultBuffer,
              r = this.sampleValues,
              o = this.valueSize,
              a = (n - e) / (s - e);
            let c = t * o;
            for (let t = c + o; c !== t; c += 4)
              ht.slerpFlat(i, 0, r, c - o, r, c, a);
            return i;
          }
        }
        class Da extends Aa {
          InterpolantFactoryMethodLinear(t) {
            return new Ia(this.times, this.values, this.getValueSize(), t);
          }
        }
        (Da.prototype.ValueTypeName = "quaternion"),
          (Da.prototype.DefaultInterpolation = E),
          (Da.prototype.InterpolantFactoryMethodSmooth = void 0);
        class Na extends Aa {}
        (Na.prototype.ValueTypeName = "string"),
          (Na.prototype.ValueBufferType = Array),
          (Na.prototype.DefaultInterpolation = T),
          (Na.prototype.InterpolantFactoryMethodLinear = void 0),
          (Na.prototype.InterpolantFactoryMethodSmooth = void 0);
        class Oa extends Aa {}
        Oa.prototype.ValueTypeName = "vector";
        class ka {
          constructor(t, e = -1, n, s = 2500) {
            (this.name = t),
              (this.tracks = n),
              (this.duration = e),
              (this.blendMode = s),
              (this.uuid = j()),
              this.duration < 0 && this.resetDuration();
          }
          static parse(t) {
            const e = [],
              n = t.tracks,
              s = 1 / (t.fps || 1);
            for (let t = 0, i = n.length; t !== i; ++t)
              e.push(Ua(n[t]).scale(s));
            const i = new this(t.name, t.duration, e, t.blendMode);
            return (i.uuid = t.uuid), i;
          }
          static toJSON(t) {
            const e = [],
              n = t.tracks,
              s = {
                name: t.name,
                duration: t.duration,
                tracks: e,
                uuid: t.uuid,
                blendMode: t.blendMode,
              };
            for (let t = 0, s = n.length; t !== s; ++t) e.push(Aa.toJSON(n[t]));
            return s;
          }
          static CreateFromMorphTargetSequence(t, e, n, s) {
            const i = e.length,
              r = [];
            for (let t = 0; t < i; t++) {
              let o = [],
                a = [];
              o.push((t + i - 1) % i, t, (t + 1) % i), a.push(0, 1, 0);
              const c = Ma.getKeyframeOrder(o);
              (o = Ma.sortedArray(o, 1, c)),
                (a = Ma.sortedArray(a, 1, c)),
                s || 0 !== o[0] || (o.push(i), a.push(a[0])),
                r.push(
                  new Pa(
                    ".morphTargetInfluences[" + e[t].name + "]",
                    o,
                    a
                  ).scale(1 / n)
                );
            }
            return new this(t, -1, r);
          }
          static findByName(t, e) {
            let n = t;
            if (!Array.isArray(t)) {
              const e = t;
              n = (e.geometry && e.geometry.animations) || e.animations;
            }
            for (let t = 0; t < n.length; t++) if (n[t].name === e) return n[t];
            return null;
          }
          static CreateClipsFromMorphTargetSequences(t, e, n) {
            const s = {},
              i = /^([\w-]*?)([\d]+)$/;
            for (let e = 0, n = t.length; e < n; e++) {
              const n = t[e],
                r = n.name.match(i);
              if (r && r.length > 1) {
                const t = r[1];
                let e = s[t];
                e || (s[t] = e = []), e.push(n);
              }
            }
            const r = [];
            for (const t in s)
              r.push(this.CreateFromMorphTargetSequence(t, s[t], e, n));
            return r;
          }
          static parseAnimation(t, e) {
            if (!t)
              return (
                console.error(
                  "THREE.AnimationClip: No animation in JSONLoader data."
                ),
                null
              );
            const n = function (t, e, n, s, i) {
                if (0 !== n.length) {
                  const r = [],
                    o = [];
                  Ma.flattenJSON(n, r, o, s),
                    0 !== r.length && i.push(new t(e, r, o));
                }
              },
              s = [],
              i = t.name || "default",
              r = t.fps || 30,
              o = t.blendMode;
            let a = t.length || -1;
            const c = t.hierarchy || [];
            for (let t = 0; t < c.length; t++) {
              const i = c[t].keys;
              if (i && 0 !== i.length)
                if (i[0].morphTargets) {
                  const t = {};
                  let e;
                  for (e = 0; e < i.length; e++)
                    if (i[e].morphTargets)
                      for (let n = 0; n < i[e].morphTargets.length; n++)
                        t[i[e].morphTargets[n]] = -1;
                  for (const n in t) {
                    const t = [],
                      r = [];
                    for (let s = 0; s !== i[e].morphTargets.length; ++s) {
                      const s = i[e];
                      t.push(s.time), r.push(s.morphTarget === n ? 1 : 0);
                    }
                    s.push(new Pa(".morphTargetInfluence[" + n + "]", t, r));
                  }
                  a = t.length * (r || 1);
                } else {
                  const r = ".bones[" + e[t].name + "]";
                  n(Oa, r + ".position", i, "pos", s),
                    n(Da, r + ".quaternion", i, "rot", s),
                    n(Oa, r + ".scale", i, "scl", s);
                }
            }
            return 0 === s.length ? null : new this(i, a, s, o);
          }
          resetDuration() {
            let t = 0;
            for (let e = 0, n = this.tracks.length; e !== n; ++e) {
              const n = this.tracks[e];
              t = Math.max(t, n.times[n.times.length - 1]);
            }
            return (this.duration = t), this;
          }
          trim() {
            for (let t = 0; t < this.tracks.length; t++)
              this.tracks[t].trim(0, this.duration);
            return this;
          }
          validate() {
            let t = !0;
            for (let e = 0; e < this.tracks.length; e++)
              t = t && this.tracks[e].validate();
            return t;
          }
          optimize() {
            for (let t = 0; t < this.tracks.length; t++)
              this.tracks[t].optimize();
            return this;
          }
          clone() {
            const t = [];
            for (let e = 0; e < this.tracks.length; e++)
              t.push(this.tracks[e].clone());
            return new this.constructor(
              this.name,
              this.duration,
              t,
              this.blendMode
            );
          }
          toJSON() {
            return this.constructor.toJSON(this);
          }
        }
        function Ua(t) {
          if (void 0 === t.type)
            throw new Error(
              "THREE.KeyframeTrack: track type undefined, can not parse"
            );
          const e = (function (t) {
            switch (t.toLowerCase()) {
              case "scalar":
              case "double":
              case "float":
              case "number":
              case "integer":
                return Pa;
              case "vector":
              case "vector2":
              case "vector3":
              case "vector4":
                return Oa;
              case "color":
                return Ra;
              case "quaternion":
                return Da;
              case "bool":
              case "boolean":
                return La;
              case "string":
                return Na;
            }
            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
          })(t.type);
          if (void 0 === t.times) {
            const e = [],
              n = [];
            Ma.flattenJSON(t.keys, e, n, "value"),
              (t.times = e),
              (t.values = n);
          }
          return void 0 !== e.parse
            ? e.parse(t)
            : new e(t.name, t.times, t.values, t.interpolation);
        }
        const za = {
          enabled: !1,
          files: {},
          add: function (t, e) {
            !1 !== this.enabled && (this.files[t] = e);
          },
          get: function (t) {
            if (!1 !== this.enabled) return this.files[t];
          },
          remove: function (t) {
            delete this.files[t];
          },
          clear: function () {
            this.files = {};
          },
        };
        const Fa = new (class {
          constructor(t, e, n) {
            const s = this;
            let i,
              r = !1,
              o = 0,
              a = 0;
            const c = [];
            (this.onStart = void 0),
              (this.onLoad = t),
              (this.onProgress = e),
              (this.onError = n),
              (this.itemStart = function (t) {
                a++,
                  !1 === r && void 0 !== s.onStart && s.onStart(t, o, a),
                  (r = !0);
              }),
              (this.itemEnd = function (t) {
                o++,
                  void 0 !== s.onProgress && s.onProgress(t, o, a),
                  o === a && ((r = !1), void 0 !== s.onLoad && s.onLoad());
              }),
              (this.itemError = function (t) {
                void 0 !== s.onError && s.onError(t);
              }),
              (this.resolveURL = function (t) {
                return i ? i(t) : t;
              }),
              (this.setURLModifier = function (t) {
                return (i = t), this;
              }),
              (this.addHandler = function (t, e) {
                return c.push(t, e), this;
              }),
              (this.removeHandler = function (t) {
                const e = c.indexOf(t);
                return -1 !== e && c.splice(e, 2), this;
              }),
              (this.getHandler = function (t) {
                for (let e = 0, n = c.length; e < n; e += 2) {
                  const n = c[e],
                    s = c[e + 1];
                  if ((n.global && (n.lastIndex = 0), n.test(t))) return s;
                }
                return null;
              });
          }
        })();
        class Ba {
          constructor(t) {
            (this.manager = void 0 !== t ? t : Fa),
              (this.crossOrigin = "anonymous"),
              (this.withCredentials = !1),
              (this.path = ""),
              (this.resourcePath = ""),
              (this.requestHeader = {});
          }
          load() {}
          loadAsync(t, e) {
            const n = this;
            return new Promise(function (s, i) {
              n.load(t, s, e, i);
            });
          }
          parse() {}
          setCrossOrigin(t) {
            return (this.crossOrigin = t), this;
          }
          setWithCredentials(t) {
            return (this.withCredentials = t), this;
          }
          setPath(t) {
            return (this.path = t), this;
          }
          setResourcePath(t) {
            return (this.resourcePath = t), this;
          }
          setRequestHeader(t) {
            return (this.requestHeader = t), this;
          }
        }
        const Ha = {};
        class Ga extends Ba {
          constructor(t) {
            super(t);
          }
          load(t, e, n, s) {
            void 0 === t && (t = ""),
              void 0 !== this.path && (t = this.path + t),
              (t = this.manager.resolveURL(t));
            const i = za.get(t);
            if (void 0 !== i)
              return (
                this.manager.itemStart(t),
                setTimeout(() => {
                  e && e(i), this.manager.itemEnd(t);
                }, 0),
                i
              );
            if (void 0 !== Ha[t])
              return void Ha[t].push({ onLoad: e, onProgress: n, onError: s });
            (Ha[t] = []), Ha[t].push({ onLoad: e, onProgress: n, onError: s });
            const r = new Request(t, {
              headers: new Headers(this.requestHeader),
              credentials: this.withCredentials ? "include" : "same-origin",
            });
            fetch(r)
              .then((e) => {
                if (200 === e.status || 0 === e.status) {
                  0 === e.status &&
                    console.warn("THREE.FileLoader: HTTP Status 0 received.");
                  const n = Ha[t],
                    s = e.body.getReader(),
                    i = e.headers.get("Content-Length"),
                    r = i ? parseInt(i) : 0,
                    o = 0 !== r;
                  let a = 0;
                  return new ReadableStream({
                    start(t) {
                      !(function e() {
                        s.read().then(({ done: s, value: i }) => {
                          if (s) t.close();
                          else {
                            a += i.byteLength;
                            const s = new ProgressEvent("progress", {
                              lengthComputable: o,
                              loaded: a,
                              total: r,
                            });
                            for (let t = 0, e = n.length; t < e; t++) {
                              const e = n[t];
                              e.onProgress && e.onProgress(s);
                            }
                            t.enqueue(i), e();
                          }
                        });
                      })();
                    },
                  });
                }
                throw Error(
                  `fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`
                );
              })
              .then((t) => {
                const e = new Response(t);
                switch (this.responseType) {
                  case "arraybuffer":
                    return e.arrayBuffer();
                  case "blob":
                    return e.blob();
                  case "document":
                    return e
                      .text()
                      .then((t) =>
                        new DOMParser().parseFromString(t, this.mimeType)
                      );
                  case "json":
                    return e.json();
                  default:
                    return e.text();
                }
              })
              .then((e) => {
                za.add(t, e);
                const n = Ha[t];
                delete Ha[t];
                for (let t = 0, s = n.length; t < s; t++) {
                  const s = n[t];
                  s.onLoad && s.onLoad(e);
                }
                this.manager.itemEnd(t);
              })
              .catch((e) => {
                const n = Ha[t];
                delete Ha[t];
                for (let t = 0, s = n.length; t < s; t++) {
                  const s = n[t];
                  s.onError && s.onError(e);
                }
                this.manager.itemError(t), this.manager.itemEnd(t);
              }),
              this.manager.itemStart(t);
          }
          setResponseType(t) {
            return (this.responseType = t), this;
          }
          setMimeType(t) {
            return (this.mimeType = t), this;
          }
        }
        class Va extends Ba {
          constructor(t) {
            super(t);
          }
          load(t, e, n, s) {
            void 0 !== this.path && (t = this.path + t),
              (t = this.manager.resolveURL(t));
            const i = this,
              r = za.get(t);
            if (void 0 !== r)
              return (
                i.manager.itemStart(t),
                setTimeout(function () {
                  e && e(r), i.manager.itemEnd(t);
                }, 0),
                r
              );
            const o = nt("img");
            function a() {
              u(), za.add(t, this), e && e(this), i.manager.itemEnd(t);
            }
            function c(e) {
              u(), s && s(e), i.manager.itemError(t), i.manager.itemEnd(t);
            }
            function u() {
              o.removeEventListener("load", a, !1),
                o.removeEventListener("error", c, !1);
            }
            return (
              o.addEventListener("load", a, !1),
              o.addEventListener("error", c, !1),
              "data:" !== t.substr(0, 5) &&
                void 0 !== this.crossOrigin &&
                (o.crossOrigin = this.crossOrigin),
              i.manager.itemStart(t),
              (o.src = t),
              o
            );
          }
        }
        class Wa extends Ba {
          constructor(t) {
            super(t);
          }
          load(t, e, n, s) {
            const i = new En(),
              r = new Va(this.manager);
            r.setCrossOrigin(this.crossOrigin), r.setPath(this.path);
            let o = 0;
            function a(n) {
              r.load(
                t[n],
                function (t) {
                  (i.images[n] = t),
                    o++,
                    6 === o && ((i.needsUpdate = !0), e && e(i));
                },
                void 0,
                s
              );
            }
            for (let e = 0; e < t.length; ++e) a(e);
            return i;
          }
        }
        class ja extends Ba {
          constructor(t) {
            super(t);
          }
          load(t, e, n, s) {
            const i = new at(),
              r = new Va(this.manager);
            return (
              r.setCrossOrigin(this.crossOrigin),
              r.setPath(this.path),
              r.load(
                t,
                function (t) {
                  (i.image = t), (i.needsUpdate = !0), void 0 !== e && e(i);
                },
                n,
                s
              ),
              i
            );
          }
        }
        class Xa extends pe {
          constructor(t, e = 1) {
            super(),
              (this.type = "Light"),
              (this.color = new Oe(t)),
              (this.intensity = e);
          }
          dispose() {}
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.intensity = t.intensity),
              this
            );
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              (e.object.color = this.color.getHex()),
              (e.object.intensity = this.intensity),
              void 0 !== this.groundColor &&
                (e.object.groundColor = this.groundColor.getHex()),
              void 0 !== this.distance && (e.object.distance = this.distance),
              void 0 !== this.angle && (e.object.angle = this.angle),
              void 0 !== this.decay && (e.object.decay = this.decay),
              void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
              void 0 !== this.shadow &&
                (e.object.shadow = this.shadow.toJSON()),
              e
            );
          }
        }
        Xa.prototype.isLight = !0;
        (class extends Xa {
          constructor(t, e, n) {
            super(t, n),
              (this.type = "HemisphereLight"),
              this.position.copy(pe.DefaultUp),
              this.updateMatrix(),
              (this.groundColor = new Oe(e));
          }
          copy(t) {
            return (
              Xa.prototype.copy.call(this, t),
              this.groundColor.copy(t.groundColor),
              this
            );
          }
        }).prototype.isHemisphereLight = !0;
        const qa = new Wt(),
          Ya = new ft(),
          Ja = new ft();
        class Za {
          constructor(t) {
            (this.camera = t),
              (this.bias = 0),
              (this.normalBias = 0),
              (this.radius = 1),
              (this.blurSamples = 8),
              (this.mapSize = new Q(512, 512)),
              (this.map = null),
              (this.mapPass = null),
              (this.matrix = new Wt()),
              (this.autoUpdate = !0),
              (this.needsUpdate = !1),
              (this._frustum = new Nn()),
              (this._frameExtents = new Q(1, 1)),
              (this._viewportCount = 1),
              (this._viewports = [new ut(0, 0, 1, 1)]);
          }
          getViewportCount() {
            return this._viewportCount;
          }
          getFrustum() {
            return this._frustum;
          }
          updateMatrices(t) {
            const e = this.camera,
              n = this.matrix;
            Ya.setFromMatrixPosition(t.matrixWorld),
              e.position.copy(Ya),
              Ja.setFromMatrixPosition(t.target.matrixWorld),
              e.lookAt(Ja),
              e.updateMatrixWorld(),
              qa.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
              this._frustum.setFromProjectionMatrix(qa),
              n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
              n.multiply(e.projectionMatrix),
              n.multiply(e.matrixWorldInverse);
          }
          getViewport(t) {
            return this._viewports[t];
          }
          getFrameExtents() {
            return this._frameExtents;
          }
          dispose() {
            this.map && this.map.dispose(),
              this.mapPass && this.mapPass.dispose();
          }
          copy(t) {
            return (
              (this.camera = t.camera.clone()),
              (this.bias = t.bias),
              (this.radius = t.radius),
              this.mapSize.copy(t.mapSize),
              this
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          toJSON() {
            const t = {};
            return (
              0 !== this.bias && (t.bias = this.bias),
              0 !== this.normalBias && (t.normalBias = this.normalBias),
              1 !== this.radius && (t.radius = this.radius),
              (512 === this.mapSize.x && 512 === this.mapSize.y) ||
                (t.mapSize = this.mapSize.toArray()),
              (t.camera = this.camera.toJSON(!1).object),
              delete t.camera.matrix,
              t
            );
          }
        }
        class $a extends Za {
          constructor() {
            super(new Mn(50, 1, 0.5, 500)), (this.focus = 1);
          }
          updateMatrices(t) {
            const e = this.camera,
              n = 2 * G * t.angle * this.focus,
              s = this.mapSize.width / this.mapSize.height,
              i = t.distance || e.far;
            (n === e.fov && s === e.aspect && i === e.far) ||
              ((e.fov = n),
              (e.aspect = s),
              (e.far = i),
              e.updateProjectionMatrix()),
              super.updateMatrices(t);
          }
          copy(t) {
            return super.copy(t), (this.focus = t.focus), this;
          }
        }
        $a.prototype.isSpotLightShadow = !0;
        class Ka extends Xa {
          constructor(t, e, n = 0, s = Math.PI / 3, i = 0, r = 1) {
            super(t, e),
              (this.type = "SpotLight"),
              this.position.copy(pe.DefaultUp),
              this.updateMatrix(),
              (this.target = new pe()),
              (this.distance = n),
              (this.angle = s),
              (this.penumbra = i),
              (this.decay = r),
              (this.shadow = new $a());
          }
          get power() {
            return this.intensity * Math.PI;
          }
          set power(t) {
            this.intensity = t / Math.PI;
          }
          dispose() {
            this.shadow.dispose();
          }
          copy(t) {
            return (
              super.copy(t),
              (this.distance = t.distance),
              (this.angle = t.angle),
              (this.penumbra = t.penumbra),
              (this.decay = t.decay),
              (this.target = t.target.clone()),
              (this.shadow = t.shadow.clone()),
              this
            );
          }
        }
        Ka.prototype.isSpotLight = !0;
        const Qa = new Wt(),
          tc = new ft(),
          ec = new ft();
        class nc extends Za {
          constructor() {
            super(new Mn(90, 1, 0.5, 500)),
              (this._frameExtents = new Q(4, 2)),
              (this._viewportCount = 6),
              (this._viewports = [
                new ut(2, 1, 1, 1),
                new ut(0, 1, 1, 1),
                new ut(3, 1, 1, 1),
                new ut(1, 1, 1, 1),
                new ut(3, 0, 1, 1),
                new ut(1, 0, 1, 1),
              ]),
              (this._cubeDirections = [
                new ft(1, 0, 0),
                new ft(-1, 0, 0),
                new ft(0, 0, 1),
                new ft(0, 0, -1),
                new ft(0, 1, 0),
                new ft(0, -1, 0),
              ]),
              (this._cubeUps = [
                new ft(0, 1, 0),
                new ft(0, 1, 0),
                new ft(0, 1, 0),
                new ft(0, 1, 0),
                new ft(0, 0, 1),
                new ft(0, 0, -1),
              ]);
          }
          updateMatrices(t, e = 0) {
            const n = this.camera,
              s = this.matrix,
              i = t.distance || n.far;
            i !== n.far && ((n.far = i), n.updateProjectionMatrix()),
              tc.setFromMatrixPosition(t.matrixWorld),
              n.position.copy(tc),
              ec.copy(n.position),
              ec.add(this._cubeDirections[e]),
              n.up.copy(this._cubeUps[e]),
              n.lookAt(ec),
              n.updateMatrixWorld(),
              s.makeTranslation(-tc.x, -tc.y, -tc.z),
              Qa.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
              this._frustum.setFromProjectionMatrix(Qa);
          }
        }
        nc.prototype.isPointLightShadow = !0;
        class sc extends Xa {
          constructor(t, e, n = 0, s = 1) {
            super(t, e),
              (this.type = "PointLight"),
              (this.distance = n),
              (this.decay = s),
              (this.shadow = new nc());
          }
          get power() {
            return 4 * this.intensity * Math.PI;
          }
          set power(t) {
            this.intensity = t / (4 * Math.PI);
          }
          dispose() {
            this.shadow.dispose();
          }
          copy(t) {
            return (
              super.copy(t),
              (this.distance = t.distance),
              (this.decay = t.decay),
              (this.shadow = t.shadow.clone()),
              this
            );
          }
        }
        sc.prototype.isPointLight = !0;
        class ic extends Za {
          constructor() {
            super(new qn(-5, 5, 5, -5, 0.5, 500));
          }
        }
        ic.prototype.isDirectionalLightShadow = !0;
        class rc extends Xa {
          constructor(t, e) {
            super(t, e),
              (this.type = "DirectionalLight"),
              this.position.copy(pe.DefaultUp),
              this.updateMatrix(),
              (this.target = new pe()),
              (this.shadow = new ic());
          }
          dispose() {
            this.shadow.dispose();
          }
          copy(t) {
            return (
              super.copy(t),
              (this.target = t.target.clone()),
              (this.shadow = t.shadow.clone()),
              this
            );
          }
        }
        rc.prototype.isDirectionalLight = !0;
        (class extends Xa {
          constructor(t, e) {
            super(t, e), (this.type = "AmbientLight");
          }
        }).prototype.isAmbientLight = !0;
        (class extends Xa {
          constructor(t, e, n = 10, s = 10) {
            super(t, e),
              (this.type = "RectAreaLight"),
              (this.width = n),
              (this.height = s);
          }
          get power() {
            return this.intensity * this.width * this.height * Math.PI;
          }
          set power(t) {
            this.intensity = t / (this.width * this.height * Math.PI);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.width = t.width),
              (this.height = t.height),
              this
            );
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              (e.object.width = this.width), (e.object.height = this.height), e
            );
          }
        }).prototype.isRectAreaLight = !0;
        class oc {
          constructor() {
            this.coefficients = [];
            for (let t = 0; t < 9; t++) this.coefficients.push(new ft());
          }
          set(t) {
            for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
            return this;
          }
          zero() {
            for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
            return this;
          }
          getAt(t, e) {
            const n = t.x,
              s = t.y,
              i = t.z,
              r = this.coefficients;
            return (
              e.copy(r[0]).multiplyScalar(0.282095),
              e.addScaledVector(r[1], 0.488603 * s),
              e.addScaledVector(r[2], 0.488603 * i),
              e.addScaledVector(r[3], 0.488603 * n),
              e.addScaledVector(r[4], n * s * 1.092548),
              e.addScaledVector(r[5], s * i * 1.092548),
              e.addScaledVector(r[6], 0.315392 * (3 * i * i - 1)),
              e.addScaledVector(r[7], n * i * 1.092548),
              e.addScaledVector(r[8], 0.546274 * (n * n - s * s)),
              e
            );
          }
          getIrradianceAt(t, e) {
            const n = t.x,
              s = t.y,
              i = t.z,
              r = this.coefficients;
            return (
              e.copy(r[0]).multiplyScalar(0.886227),
              e.addScaledVector(r[1], 1.023328 * s),
              e.addScaledVector(r[2], 1.023328 * i),
              e.addScaledVector(r[3], 1.023328 * n),
              e.addScaledVector(r[4], 0.858086 * n * s),
              e.addScaledVector(r[5], 0.858086 * s * i),
              e.addScaledVector(r[6], 0.743125 * i * i - 0.247708),
              e.addScaledVector(r[7], 0.858086 * n * i),
              e.addScaledVector(r[8], 0.429043 * (n * n - s * s)),
              e
            );
          }
          add(t) {
            for (let e = 0; e < 9; e++)
              this.coefficients[e].add(t.coefficients[e]);
            return this;
          }
          addScaledSH(t, e) {
            for (let n = 0; n < 9; n++)
              this.coefficients[n].addScaledVector(t.coefficients[n], e);
            return this;
          }
          scale(t) {
            for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
            return this;
          }
          lerp(t, e) {
            for (let n = 0; n < 9; n++)
              this.coefficients[n].lerp(t.coefficients[n], e);
            return this;
          }
          equals(t) {
            for (let e = 0; e < 9; e++)
              if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
            return !0;
          }
          copy(t) {
            return this.set(t.coefficients);
          }
          clone() {
            return new this.constructor().copy(this);
          }
          fromArray(t, e = 0) {
            const n = this.coefficients;
            for (let s = 0; s < 9; s++) n[s].fromArray(t, e + 3 * s);
            return this;
          }
          toArray(t = [], e = 0) {
            const n = this.coefficients;
            for (let s = 0; s < 9; s++) n[s].toArray(t, e + 3 * s);
            return t;
          }
          static getBasisAt(t, e) {
            const n = t.x,
              s = t.y,
              i = t.z;
            (e[0] = 0.282095),
              (e[1] = 0.488603 * s),
              (e[2] = 0.488603 * i),
              (e[3] = 0.488603 * n),
              (e[4] = 1.092548 * n * s),
              (e[5] = 1.092548 * s * i),
              (e[6] = 0.315392 * (3 * i * i - 1)),
              (e[7] = 1.092548 * n * i),
              (e[8] = 0.546274 * (n * n - s * s));
          }
        }
        oc.prototype.isSphericalHarmonics3 = !0;
        class ac extends Xa {
          constructor(t = new oc(), e = 1) {
            super(void 0, e), (this.sh = t);
          }
          copy(t) {
            return super.copy(t), this.sh.copy(t.sh), this;
          }
          fromJSON(t) {
            return (
              (this.intensity = t.intensity), this.sh.fromArray(t.sh), this
            );
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (e.object.sh = this.sh.toArray()), e;
          }
        }
        ac.prototype.isLightProbe = !0;
        class cc {
          static decodeText(t) {
            if ("undefined" != typeof TextDecoder)
              return new TextDecoder().decode(t);
            let e = "";
            for (let n = 0, s = t.length; n < s; n++)
              e += String.fromCharCode(t[n]);
            try {
              return decodeURIComponent(escape(e));
            } catch (t) {
              return e;
            }
          }
          static extractUrlBase(t) {
            const e = t.lastIndexOf("/");
            return -1 === e ? "./" : t.substr(0, e + 1);
          }
          static resolveURL(t, e) {
            return "string" != typeof t || "" === t
              ? ""
              : (/^https?:\/\//i.test(e) &&
                  /^\//.test(t) &&
                  (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
                /^(https?:)?\/\//i.test(t) ||
                /^data:.*,.*$/i.test(t) ||
                /^blob:.*$/i.test(t)
                  ? t
                  : e + t);
          }
        }
        (class extends Ze {
          constructor() {
            super(),
              (this.type = "InstancedBufferGeometry"),
              (this.instanceCount = 1 / 0);
          }
          copy(t) {
            return super.copy(t), (this.instanceCount = t.instanceCount), this;
          }
          clone() {
            return new this.constructor().copy(this);
          }
          toJSON() {
            const t = super.toJSON(this);
            return (
              (t.instanceCount = this.instanceCount),
              (t.isInstancedBufferGeometry = !0),
              t
            );
          }
        }).prototype.isInstancedBufferGeometry = !0;
        class uc extends Ba {
          constructor(t) {
            super(t),
              "undefined" == typeof createImageBitmap &&
                console.warn(
                  "THREE.ImageBitmapLoader: createImageBitmap() not supported."
                ),
              "undefined" == typeof fetch &&
                console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
              (this.options = { premultiplyAlpha: "none" });
          }
          setOptions(t) {
            return (this.options = t), this;
          }
          load(t, e, n, s) {
            void 0 === t && (t = ""),
              void 0 !== this.path && (t = this.path + t),
              (t = this.manager.resolveURL(t));
            const i = this,
              r = za.get(t);
            if (void 0 !== r)
              return (
                i.manager.itemStart(t),
                setTimeout(function () {
                  e && e(r), i.manager.itemEnd(t);
                }, 0),
                r
              );
            const o = {};
            (o.credentials =
              "anonymous" === this.crossOrigin ? "same-origin" : "include"),
              (o.headers = this.requestHeader),
              fetch(t, o)
                .then(function (t) {
                  return t.blob();
                })
                .then(function (t) {
                  return createImageBitmap(
                    t,
                    Object.assign(i.options, { colorSpaceConversion: "none" })
                  );
                })
                .then(function (n) {
                  za.add(t, n), e && e(n), i.manager.itemEnd(t);
                })
                .catch(function (e) {
                  s && s(e), i.manager.itemError(t), i.manager.itemEnd(t);
                }),
              i.manager.itemStart(t);
          }
        }
        let dc;
        uc.prototype.isImageBitmapLoader = !0;
        class lc extends Ba {
          constructor(t) {
            super(t);
          }
          load(t, e, n, s) {
            const i = this,
              r = new Ga(this.manager);
            r.setResponseType("arraybuffer"),
              r.setPath(this.path),
              r.setRequestHeader(this.requestHeader),
              r.setWithCredentials(this.withCredentials),
              r.load(
                t,
                function (n) {
                  try {
                    const t = n.slice(0);
                    (void 0 === dc &&
                      (dc = new (window.AudioContext ||
                        window.webkitAudioContext)()),
                    dc).decodeAudioData(t, function (t) {
                      e(t);
                    });
                  } catch (e) {
                    s ? s(e) : console.error(e), i.manager.itemError(t);
                  }
                },
                n,
                s
              );
          }
        }
        ((class extends ac {
          constructor(t, e, n = 1) {
            super(void 0, n);
            const s = new Oe().set(t),
              i = new Oe().set(e),
              r = new ft(s.r, s.g, s.b),
              o = new ft(i.r, i.g, i.b),
              a = Math.sqrt(Math.PI),
              c = a * Math.sqrt(0.75);
            this.sh.coefficients[0].copy(r).add(o).multiplyScalar(a),
              this.sh.coefficients[1].copy(r).sub(o).multiplyScalar(c);
          }
        }).prototype.isHemisphereLightProbe = !0),
          (class extends ac {
            constructor(t, e = 1) {
              super(void 0, e);
              const n = new Oe().set(t);
              this.sh.coefficients[0]
                .set(n.r, n.g, n.b)
                .multiplyScalar(2 * Math.sqrt(Math.PI));
            }
          }.prototype.isAmbientLightProbe = !0);
        class hc {
          constructor(t, e, n) {
            let s, i, r;
            switch (((this.binding = t), (this.valueSize = n), e)) {
              case "quaternion":
                (s = this._slerp),
                  (i = this._slerpAdditive),
                  (r = this._setAdditiveIdentityQuaternion),
                  (this.buffer = new Float64Array(6 * n)),
                  (this._workIndex = 5);
                break;
              case "string":
              case "bool":
                (s = this._select),
                  (i = this._select),
                  (r = this._setAdditiveIdentityOther),
                  (this.buffer = new Array(5 * n));
                break;
              default:
                (s = this._lerp),
                  (i = this._lerpAdditive),
                  (r = this._setAdditiveIdentityNumeric),
                  (this.buffer = new Float64Array(5 * n));
            }
            (this._mixBufferRegion = s),
              (this._mixBufferRegionAdditive = i),
              (this._setIdentity = r),
              (this._origIndex = 3),
              (this._addIndex = 4),
              (this.cumulativeWeight = 0),
              (this.cumulativeWeightAdditive = 0),
              (this.useCount = 0),
              (this.referenceCount = 0);
          }
          accumulate(t, e) {
            const n = this.buffer,
              s = this.valueSize,
              i = t * s + s;
            let r = this.cumulativeWeight;
            if (0 === r) {
              for (let t = 0; t !== s; ++t) n[i + t] = n[t];
              r = e;
            } else {
              r += e;
              const t = e / r;
              this._mixBufferRegion(n, i, 0, t, s);
            }
            this.cumulativeWeight = r;
          }
          accumulateAdditive(t) {
            const e = this.buffer,
              n = this.valueSize,
              s = n * this._addIndex;
            0 === this.cumulativeWeightAdditive && this._setIdentity(),
              this._mixBufferRegionAdditive(e, s, 0, t, n),
              (this.cumulativeWeightAdditive += t);
          }
          apply(t) {
            const e = this.valueSize,
              n = this.buffer,
              s = t * e + e,
              i = this.cumulativeWeight,
              r = this.cumulativeWeightAdditive,
              o = this.binding;
            if (
              ((this.cumulativeWeight = 0),
              (this.cumulativeWeightAdditive = 0),
              i < 1)
            ) {
              const t = e * this._origIndex;
              this._mixBufferRegion(n, s, t, 1 - i, e);
            }
            r > 0 &&
              this._mixBufferRegionAdditive(n, s, this._addIndex * e, 1, e);
            for (let t = e, i = e + e; t !== i; ++t)
              if (n[t] !== n[t + e]) {
                o.setValue(n, s);
                break;
              }
          }
          saveOriginalState() {
            const t = this.binding,
              e = this.buffer,
              n = this.valueSize,
              s = n * this._origIndex;
            t.getValue(e, s);
            for (let t = n, i = s; t !== i; ++t) e[t] = e[s + (t % n)];
            this._setIdentity(),
              (this.cumulativeWeight = 0),
              (this.cumulativeWeightAdditive = 0);
          }
          restoreOriginalState() {
            const t = 3 * this.valueSize;
            this.binding.setValue(this.buffer, t);
          }
          _setAdditiveIdentityNumeric() {
            const t = this._addIndex * this.valueSize,
              e = t + this.valueSize;
            for (let n = t; n < e; n++) this.buffer[n] = 0;
          }
          _setAdditiveIdentityQuaternion() {
            this._setAdditiveIdentityNumeric(),
              (this.buffer[this._addIndex * this.valueSize + 3] = 1);
          }
          _setAdditiveIdentityOther() {
            const t = this._origIndex * this.valueSize,
              e = this._addIndex * this.valueSize;
            for (let n = 0; n < this.valueSize; n++)
              this.buffer[e + n] = this.buffer[t + n];
          }
          _select(t, e, n, s, i) {
            if (s >= 0.5) for (let s = 0; s !== i; ++s) t[e + s] = t[n + s];
          }
          _slerp(t, e, n, s) {
            ht.slerpFlat(t, e, t, e, t, n, s);
          }
          _slerpAdditive(t, e, n, s, i) {
            const r = this._workIndex * i;
            ht.multiplyQuaternionsFlat(t, r, t, e, t, n),
              ht.slerpFlat(t, e, t, e, t, r, s);
          }
          _lerp(t, e, n, s, i) {
            const r = 1 - s;
            for (let o = 0; o !== i; ++o) {
              const i = e + o;
              t[i] = t[i] * r + t[n + o] * s;
            }
          }
          _lerpAdditive(t, e, n, s, i) {
            for (let r = 0; r !== i; ++r) {
              const i = e + r;
              t[i] = t[i] + t[n + r] * s;
            }
          }
        }
        const fc = new RegExp("[\\[\\]\\.:\\/]", "g"),
          mc = "[^\\[\\]\\.:\\/]",
          pc = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
          gc = /((?:WC+[\/:])*)/.source.replace("WC", mc),
          xc = /(WCOD+)?/.source.replace("WCOD", pc),
          vc = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", mc),
          yc = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", mc),
          wc = new RegExp("^" + gc + xc + vc + yc + "$"),
          _c = ["material", "materials", "bones"];
        class bc {
          constructor(t, e, n) {
            (this.path = e),
              (this.parsedPath = n || bc.parseTrackName(e)),
              (this.node = bc.findNode(t, this.parsedPath.nodeName) || t),
              (this.rootNode = t),
              (this.getValue = this._getValue_unbound),
              (this.setValue = this._setValue_unbound);
          }
          static create(t, e, n) {
            return t && t.isAnimationObjectGroup
              ? new bc.Composite(t, e, n)
              : new bc(t, e, n);
          }
          static sanitizeNodeName(t) {
            return t.replace(/\s/g, "_").replace(fc, "");
          }
          static parseTrackName(t) {
            const e = wc.exec(t);
            if (!e)
              throw new Error("PropertyBinding: Cannot parse trackName: " + t);
            const n = {
                nodeName: e[2],
                objectName: e[3],
                objectIndex: e[4],
                propertyName: e[5],
                propertyIndex: e[6],
              },
              s = n.nodeName && n.nodeName.lastIndexOf(".");
            if (void 0 !== s && -1 !== s) {
              const t = n.nodeName.substring(s + 1);
              -1 !== _c.indexOf(t) &&
                ((n.nodeName = n.nodeName.substring(0, s)), (n.objectName = t));
            }
            if (null === n.propertyName || 0 === n.propertyName.length)
              throw new Error(
                "PropertyBinding: can not parse propertyName from trackName: " +
                  t
              );
            return n;
          }
          static findNode(t, e) {
            if (
              !e ||
              "" === e ||
              "." === e ||
              -1 === e ||
              e === t.name ||
              e === t.uuid
            )
              return t;
            if (t.skeleton) {
              const n = t.skeleton.getBoneByName(e);
              if (void 0 !== n) return n;
            }
            if (t.children) {
              const n = function (t) {
                  for (let s = 0; s < t.length; s++) {
                    const i = t[s];
                    if (i.name === e || i.uuid === e) return i;
                    const r = n(i.children);
                    if (r) return r;
                  }
                  return null;
                },
                s = n(t.children);
              if (s) return s;
            }
            return null;
          }
          _getValue_unavailable() {}
          _setValue_unavailable() {}
          _getValue_direct(t, e) {
            t[e] = this.targetObject[this.propertyName];
          }
          _getValue_array(t, e) {
            const n = this.resolvedProperty;
            for (let s = 0, i = n.length; s !== i; ++s) t[e++] = n[s];
          }
          _getValue_arrayElement(t, e) {
            t[e] = this.resolvedProperty[this.propertyIndex];
          }
          _getValue_toArray(t, e) {
            this.resolvedProperty.toArray(t, e);
          }
          _setValue_direct(t, e) {
            this.targetObject[this.propertyName] = t[e];
          }
          _setValue_direct_setNeedsUpdate(t, e) {
            (this.targetObject[this.propertyName] = t[e]),
              (this.targetObject.needsUpdate = !0);
          }
          _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
            (this.targetObject[this.propertyName] = t[e]),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _setValue_array(t, e) {
            const n = this.resolvedProperty;
            for (let s = 0, i = n.length; s !== i; ++s) n[s] = t[e++];
          }
          _setValue_array_setNeedsUpdate(t, e) {
            const n = this.resolvedProperty;
            for (let s = 0, i = n.length; s !== i; ++s) n[s] = t[e++];
            this.targetObject.needsUpdate = !0;
          }
          _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
            const n = this.resolvedProperty;
            for (let s = 0, i = n.length; s !== i; ++s) n[s] = t[e++];
            this.targetObject.matrixWorldNeedsUpdate = !0;
          }
          _setValue_arrayElement(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e];
          }
          _setValue_arrayElement_setNeedsUpdate(t, e) {
            (this.resolvedProperty[this.propertyIndex] = t[e]),
              (this.targetObject.needsUpdate = !0);
          }
          _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
            (this.resolvedProperty[this.propertyIndex] = t[e]),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _setValue_fromArray(t, e) {
            this.resolvedProperty.fromArray(t, e);
          }
          _setValue_fromArray_setNeedsUpdate(t, e) {
            this.resolvedProperty.fromArray(t, e),
              (this.targetObject.needsUpdate = !0);
          }
          _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
            this.resolvedProperty.fromArray(t, e),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _getValue_unbound(t, e) {
            this.bind(), this.getValue(t, e);
          }
          _setValue_unbound(t, e) {
            this.bind(), this.setValue(t, e);
          }
          bind() {
            let t = this.node;
            const e = this.parsedPath,
              n = e.objectName,
              s = e.propertyName;
            let i = e.propertyIndex;
            if (
              (t ||
                ((t = bc.findNode(this.rootNode, e.nodeName) || this.rootNode),
                (this.node = t)),
              (this.getValue = this._getValue_unavailable),
              (this.setValue = this._setValue_unavailable),
              !t)
            )
              return void console.error(
                "THREE.PropertyBinding: Trying to update node for track: " +
                  this.path +
                  " but it wasn't found."
              );
            if (n) {
              let s = e.objectIndex;
              switch (n) {
                case "materials":
                  if (!t.material)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                      this
                    );
                  if (!t.material.materials)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                      this
                    );
                  t = t.material.materials;
                  break;
                case "bones":
                  if (!t.skeleton)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                      this
                    );
                  t = t.skeleton.bones;
                  for (let e = 0; e < t.length; e++)
                    if (t[e].name === s) {
                      s = e;
                      break;
                    }
                  break;
                default:
                  if (void 0 === t[n])
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                      this
                    );
                  t = t[n];
              }
              if (void 0 !== s) {
                if (void 0 === t[s])
                  return void console.error(
                    "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                    this,
                    t
                  );
                t = t[s];
              }
            }
            const r = t[s];
            if (void 0 === r) {
              const n = e.nodeName;
              return void console.error(
                "THREE.PropertyBinding: Trying to update property for track: " +
                  n +
                  "." +
                  s +
                  " but it wasn't found.",
                t
              );
            }
            let o = this.Versioning.None;
            (this.targetObject = t),
              void 0 !== t.needsUpdate
                ? (o = this.Versioning.NeedsUpdate)
                : void 0 !== t.matrixWorldNeedsUpdate &&
                  (o = this.Versioning.MatrixWorldNeedsUpdate);
            let a = this.BindingType.Direct;
            if (void 0 !== i) {
              if ("morphTargetInfluences" === s) {
                if (!t.geometry)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                    this
                  );
                if (!t.geometry.isBufferGeometry)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
                    this
                  );
                if (!t.geometry.morphAttributes)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                    this
                  );
                void 0 !== t.morphTargetDictionary[i] &&
                  (i = t.morphTargetDictionary[i]);
              }
              (a = this.BindingType.ArrayElement),
                (this.resolvedProperty = r),
                (this.propertyIndex = i);
            } else
              void 0 !== r.fromArray && void 0 !== r.toArray
                ? ((a = this.BindingType.HasFromToArray),
                  (this.resolvedProperty = r))
                : Array.isArray(r)
                ? ((a = this.BindingType.EntireArray),
                  (this.resolvedProperty = r))
                : (this.propertyName = s);
            (this.getValue = this.GetterByBindingType[a]),
              (this.setValue = this.SetterByBindingTypeAndVersioning[a][o]);
          }
          unbind() {
            (this.node = null),
              (this.getValue = this._getValue_unbound),
              (this.setValue = this._setValue_unbound);
          }
        }
        (bc.Composite = class {
          constructor(t, e, n) {
            const s = n || bc.parseTrackName(e);
            (this._targetGroup = t), (this._bindings = t.subscribe_(e, s));
          }
          getValue(t, e) {
            this.bind();
            const n = this._targetGroup.nCachedObjects_,
              s = this._bindings[n];
            void 0 !== s && s.getValue(t, e);
          }
          setValue(t, e) {
            const n = this._bindings;
            for (
              let s = this._targetGroup.nCachedObjects_, i = n.length;
              s !== i;
              ++s
            )
              n[s].setValue(t, e);
          }
          bind() {
            const t = this._bindings;
            for (
              let e = this._targetGroup.nCachedObjects_, n = t.length;
              e !== n;
              ++e
            )
              t[e].bind();
          }
          unbind() {
            const t = this._bindings;
            for (
              let e = this._targetGroup.nCachedObjects_, n = t.length;
              e !== n;
              ++e
            )
              t[e].unbind();
          }
        }),
          (bc.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3,
          }),
          (bc.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2,
          }),
          (bc.prototype.GetterByBindingType = [
            bc.prototype._getValue_direct,
            bc.prototype._getValue_array,
            bc.prototype._getValue_arrayElement,
            bc.prototype._getValue_toArray,
          ]),
          (bc.prototype.SetterByBindingTypeAndVersioning = [
            [
              bc.prototype._setValue_direct,
              bc.prototype._setValue_direct_setNeedsUpdate,
              bc.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
            ],
            [
              bc.prototype._setValue_array,
              bc.prototype._setValue_array_setNeedsUpdate,
              bc.prototype._setValue_array_setMatrixWorldNeedsUpdate,
            ],
            [
              bc.prototype._setValue_arrayElement,
              bc.prototype._setValue_arrayElement_setNeedsUpdate,
              bc.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
            ],
            [
              bc.prototype._setValue_fromArray,
              bc.prototype._setValue_fromArray_setNeedsUpdate,
              bc.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
            ],
          ]);
        class Mc {
          constructor(t, e, n = null, s = e.blendMode) {
            (this._mixer = t),
              (this._clip = e),
              (this._localRoot = n),
              (this.blendMode = s);
            const i = e.tracks,
              r = i.length,
              o = new Array(r),
              a = { endingStart: A, endingEnd: A };
            for (let t = 0; t !== r; ++t) {
              const e = i[t].createInterpolant(null);
              (o[t] = e), (e.settings = a);
            }
            (this._interpolantSettings = a),
              (this._interpolants = o),
              (this._propertyBindings = new Array(r)),
              (this._cacheIndex = null),
              (this._byClipCacheIndex = null),
              (this._timeScaleInterpolant = null),
              (this._weightInterpolant = null),
              (this.loop = 2201),
              (this._loopCount = -1),
              (this._startTime = null),
              (this.time = 0),
              (this.timeScale = 1),
              (this._effectiveTimeScale = 1),
              (this.weight = 1),
              (this._effectiveWeight = 1),
              (this.repetitions = 1 / 0),
              (this.paused = !1),
              (this.enabled = !0),
              (this.clampWhenFinished = !1),
              (this.zeroSlopeAtStart = !0),
              (this.zeroSlopeAtEnd = !0);
          }
          play() {
            return this._mixer._activateAction(this), this;
          }
          stop() {
            return this._mixer._deactivateAction(this), this.reset();
          }
          reset() {
            return (
              (this.paused = !1),
              (this.enabled = !0),
              (this.time = 0),
              (this._loopCount = -1),
              (this._startTime = null),
              this.stopFading().stopWarping()
            );
          }
          isRunning() {
            return (
              this.enabled &&
              !this.paused &&
              0 !== this.timeScale &&
              null === this._startTime &&
              this._mixer._isActiveAction(this)
            );
          }
          isScheduled() {
            return this._mixer._isActiveAction(this);
          }
          startAt(t) {
            return (this._startTime = t), this;
          }
          setLoop(t, e) {
            return (this.loop = t), (this.repetitions = e), this;
          }
          setEffectiveWeight(t) {
            return (
              (this.weight = t),
              (this._effectiveWeight = this.enabled ? t : 0),
              this.stopFading()
            );
          }
          getEffectiveWeight() {
            return this._effectiveWeight;
          }
          fadeIn(t) {
            return this._scheduleFading(t, 0, 1);
          }
          fadeOut(t) {
            return this._scheduleFading(t, 1, 0);
          }
          crossFadeFrom(t, e, n) {
            if ((t.fadeOut(e), this.fadeIn(e), n)) {
              const n = this._clip.duration,
                s = t._clip.duration,
                i = s / n,
                r = n / s;
              t.warp(1, i, e), this.warp(r, 1, e);
            }
            return this;
          }
          crossFadeTo(t, e, n) {
            return t.crossFadeFrom(this, e, n);
          }
          stopFading() {
            const t = this._weightInterpolant;
            return (
              null !== t &&
                ((this._weightInterpolant = null),
                this._mixer._takeBackControlInterpolant(t)),
              this
            );
          }
          setEffectiveTimeScale(t) {
            return (
              (this.timeScale = t),
              (this._effectiveTimeScale = this.paused ? 0 : t),
              this.stopWarping()
            );
          }
          getEffectiveTimeScale() {
            return this._effectiveTimeScale;
          }
          setDuration(t) {
            return (
              (this.timeScale = this._clip.duration / t), this.stopWarping()
            );
          }
          syncWith(t) {
            return (
              (this.time = t.time),
              (this.timeScale = t.timeScale),
              this.stopWarping()
            );
          }
          halt(t) {
            return this.warp(this._effectiveTimeScale, 0, t);
          }
          warp(t, e, n) {
            const s = this._mixer,
              i = s.time,
              r = this.timeScale;
            let o = this._timeScaleInterpolant;
            null === o &&
              ((o = s._lendControlInterpolant()),
              (this._timeScaleInterpolant = o));
            const a = o.parameterPositions,
              c = o.sampleValues;
            return (
              (a[0] = i), (a[1] = i + n), (c[0] = t / r), (c[1] = e / r), this
            );
          }
          stopWarping() {
            const t = this._timeScaleInterpolant;
            return (
              null !== t &&
                ((this._timeScaleInterpolant = null),
                this._mixer._takeBackControlInterpolant(t)),
              this
            );
          }
          getMixer() {
            return this._mixer;
          }
          getClip() {
            return this._clip;
          }
          getRoot() {
            return this._localRoot || this._mixer._root;
          }
          _update(t, e, n, s) {
            if (!this.enabled) return void this._updateWeight(t);
            const i = this._startTime;
            if (null !== i) {
              const s = (t - i) * n;
              if (s < 0 || 0 === n) return;
              (this._startTime = null), (e = n * s);
            }
            e *= this._updateTimeScale(t);
            const r = this._updateTime(e),
              o = this._updateWeight(t);
            if (o > 0) {
              const t = this._interpolants,
                e = this._propertyBindings;
              if (2501 === this.blendMode)
                for (let n = 0, s = t.length; n !== s; ++n)
                  t[n].evaluate(r), e[n].accumulateAdditive(o);
              else
                for (let n = 0, i = t.length; n !== i; ++n)
                  t[n].evaluate(r), e[n].accumulate(s, o);
            }
          }
          _updateWeight(t) {
            let e = 0;
            if (this.enabled) {
              e = this.weight;
              const n = this._weightInterpolant;
              if (null !== n) {
                const s = n.evaluate(t)[0];
                (e *= s),
                  t > n.parameterPositions[1] &&
                    (this.stopFading(), 0 === s && (this.enabled = !1));
              }
            }
            return (this._effectiveWeight = e), e;
          }
          _updateTimeScale(t) {
            let e = 0;
            if (!this.paused) {
              e = this.timeScale;
              const n = this._timeScaleInterpolant;
              null !== n &&
                ((e *= n.evaluate(t)[0]),
                t > n.parameterPositions[1] &&
                  (this.stopWarping(),
                  0 === e ? (this.paused = !0) : (this.timeScale = e)));
            }
            return (this._effectiveTimeScale = e), e;
          }
          _updateTime(t) {
            const e = this._clip.duration,
              n = this.loop;
            let s = this.time + t,
              i = this._loopCount;
            const r = 2202 === n;
            if (0 === t) return -1 === i ? s : r && 1 == (1 & i) ? e - s : s;
            if (2200 === n) {
              -1 === i && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
              t: {
                if (s >= e) s = e;
                else {
                  if (!(s < 0)) {
                    this.time = s;
                    break t;
                  }
                  s = 0;
                }
                this.clampWhenFinished
                  ? (this.paused = !0)
                  : (this.enabled = !1),
                  (this.time = s),
                  this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: t < 0 ? -1 : 1,
                  });
              }
            } else {
              if (
                (-1 === i &&
                  (t >= 0
                    ? ((i = 0), this._setEndings(!0, 0 === this.repetitions, r))
                    : this._setEndings(0 === this.repetitions, !0, r)),
                s >= e || s < 0)
              ) {
                const n = Math.floor(s / e);
                (s -= e * n), (i += Math.abs(n));
                const o = this.repetitions - i;
                if (o <= 0)
                  this.clampWhenFinished
                    ? (this.paused = !0)
                    : (this.enabled = !1),
                    (s = t > 0 ? e : 0),
                    (this.time = s),
                    this._mixer.dispatchEvent({
                      type: "finished",
                      action: this,
                      direction: t > 0 ? 1 : -1,
                    });
                else {
                  if (1 === o) {
                    const e = t < 0;
                    this._setEndings(e, !e, r);
                  } else this._setEndings(!1, !1, r);
                  (this._loopCount = i),
                    (this.time = s),
                    this._mixer.dispatchEvent({
                      type: "loop",
                      action: this,
                      loopDelta: n,
                    });
                }
              } else this.time = s;
              if (r && 1 == (1 & i)) return e - s;
            }
            return s;
          }
          _setEndings(t, e, n) {
            const s = this._interpolantSettings;
            n
              ? ((s.endingStart = L), (s.endingEnd = L))
              : ((s.endingStart = t ? (this.zeroSlopeAtStart ? L : A) : R),
                (s.endingEnd = e ? (this.zeroSlopeAtEnd ? L : A) : R));
          }
          _scheduleFading(t, e, n) {
            const s = this._mixer,
              i = s.time;
            let r = this._weightInterpolant;
            null === r &&
              ((r = s._lendControlInterpolant()),
              (this._weightInterpolant = r));
            const o = r.parameterPositions,
              a = r.sampleValues;
            return (o[0] = i), (a[0] = e), (o[1] = i + t), (a[1] = n), this;
          }
        }
        class Sc extends F {
          constructor(t) {
            super(),
              (this._root = t),
              this._initMemoryManager(),
              (this._accuIndex = 0),
              (this.time = 0),
              (this.timeScale = 1);
          }
          _bindAction(t, e) {
            const n = t._localRoot || this._root,
              s = t._clip.tracks,
              i = s.length,
              r = t._propertyBindings,
              o = t._interpolants,
              a = n.uuid,
              c = this._bindingsByRootAndName;
            let u = c[a];
            void 0 === u && ((u = {}), (c[a] = u));
            for (let t = 0; t !== i; ++t) {
              const i = s[t],
                c = i.name;
              let d = u[c];
              if (void 0 !== d) r[t] = d;
              else {
                if (((d = r[t]), void 0 !== d)) {
                  null === d._cacheIndex &&
                    (++d.referenceCount, this._addInactiveBinding(d, a, c));
                  continue;
                }
                const s = e && e._propertyBindings[t].binding.parsedPath;
                (d = new hc(
                  bc.create(n, c, s),
                  i.ValueTypeName,
                  i.getValueSize()
                )),
                  ++d.referenceCount,
                  this._addInactiveBinding(d, a, c),
                  (r[t] = d);
              }
              o[t].resultBuffer = d.buffer;
            }
          }
          _activateAction(t) {
            if (!this._isActiveAction(t)) {
              if (null === t._cacheIndex) {
                const e = (t._localRoot || this._root).uuid,
                  n = t._clip.uuid,
                  s = this._actionsByClip[n];
                this._bindAction(t, s && s.knownActions[0]),
                  this._addInactiveAction(t, n, e);
              }
              const e = t._propertyBindings;
              for (let t = 0, n = e.length; t !== n; ++t) {
                const n = e[t];
                0 == n.useCount++ &&
                  (this._lendBinding(n), n.saveOriginalState());
              }
              this._lendAction(t);
            }
          }
          _deactivateAction(t) {
            if (this._isActiveAction(t)) {
              const e = t._propertyBindings;
              for (let t = 0, n = e.length; t !== n; ++t) {
                const n = e[t];
                0 == --n.useCount &&
                  (n.restoreOriginalState(), this._takeBackBinding(n));
              }
              this._takeBackAction(t);
            }
          }
          _initMemoryManager() {
            (this._actions = []),
              (this._nActiveActions = 0),
              (this._actionsByClip = {}),
              (this._bindings = []),
              (this._nActiveBindings = 0),
              (this._bindingsByRootAndName = {}),
              (this._controlInterpolants = []),
              (this._nActiveControlInterpolants = 0);
            const t = this;
            this.stats = {
              actions: {
                get total() {
                  return t._actions.length;
                },
                get inUse() {
                  return t._nActiveActions;
                },
              },
              bindings: {
                get total() {
                  return t._bindings.length;
                },
                get inUse() {
                  return t._nActiveBindings;
                },
              },
              controlInterpolants: {
                get total() {
                  return t._controlInterpolants.length;
                },
                get inUse() {
                  return t._nActiveControlInterpolants;
                },
              },
            };
          }
          _isActiveAction(t) {
            const e = t._cacheIndex;
            return null !== e && e < this._nActiveActions;
          }
          _addInactiveAction(t, e, n) {
            const s = this._actions,
              i = this._actionsByClip;
            let r = i[e];
            if (void 0 === r)
              (r = { knownActions: [t], actionByRoot: {} }),
                (t._byClipCacheIndex = 0),
                (i[e] = r);
            else {
              const e = r.knownActions;
              (t._byClipCacheIndex = e.length), e.push(t);
            }
            (t._cacheIndex = s.length), s.push(t), (r.actionByRoot[n] = t);
          }
          _removeInactiveAction(t) {
            const e = this._actions,
              n = e[e.length - 1],
              s = t._cacheIndex;
            (n._cacheIndex = s), (e[s] = n), e.pop(), (t._cacheIndex = null);
            const i = t._clip.uuid,
              r = this._actionsByClip,
              o = r[i],
              a = o.knownActions,
              c = a[a.length - 1],
              u = t._byClipCacheIndex;
            (c._byClipCacheIndex = u),
              (a[u] = c),
              a.pop(),
              (t._byClipCacheIndex = null),
              delete o.actionByRoot[(t._localRoot || this._root).uuid],
              0 === a.length && delete r[i],
              this._removeInactiveBindingsForAction(t);
          }
          _removeInactiveBindingsForAction(t) {
            const e = t._propertyBindings;
            for (let t = 0, n = e.length; t !== n; ++t) {
              const n = e[t];
              0 == --n.referenceCount && this._removeInactiveBinding(n);
            }
          }
          _lendAction(t) {
            const e = this._actions,
              n = t._cacheIndex,
              s = this._nActiveActions++,
              i = e[s];
            (t._cacheIndex = s), (e[s] = t), (i._cacheIndex = n), (e[n] = i);
          }
          _takeBackAction(t) {
            const e = this._actions,
              n = t._cacheIndex,
              s = --this._nActiveActions,
              i = e[s];
            (t._cacheIndex = s), (e[s] = t), (i._cacheIndex = n), (e[n] = i);
          }
          _addInactiveBinding(t, e, n) {
            const s = this._bindingsByRootAndName,
              i = this._bindings;
            let r = s[e];
            void 0 === r && ((r = {}), (s[e] = r)),
              (r[n] = t),
              (t._cacheIndex = i.length),
              i.push(t);
          }
          _removeInactiveBinding(t) {
            const e = this._bindings,
              n = t.binding,
              s = n.rootNode.uuid,
              i = n.path,
              r = this._bindingsByRootAndName,
              o = r[s],
              a = e[e.length - 1],
              c = t._cacheIndex;
            (a._cacheIndex = c),
              (e[c] = a),
              e.pop(),
              delete o[i],
              0 === Object.keys(o).length && delete r[s];
          }
          _lendBinding(t) {
            const e = this._bindings,
              n = t._cacheIndex,
              s = this._nActiveBindings++,
              i = e[s];
            (t._cacheIndex = s), (e[s] = t), (i._cacheIndex = n), (e[n] = i);
          }
          _takeBackBinding(t) {
            const e = this._bindings,
              n = t._cacheIndex,
              s = --this._nActiveBindings,
              i = e[s];
            (t._cacheIndex = s), (e[s] = t), (i._cacheIndex = n), (e[n] = i);
          }
          _lendControlInterpolant() {
            const t = this._controlInterpolants,
              e = this._nActiveControlInterpolants++;
            let n = t[e];
            return (
              void 0 === n &&
                ((n = new Ea(
                  new Float32Array(2),
                  new Float32Array(2),
                  1,
                  this._controlInterpolantsResultBuffer
                )),
                (n.__cacheIndex = e),
                (t[e] = n)),
              n
            );
          }
          _takeBackControlInterpolant(t) {
            const e = this._controlInterpolants,
              n = t.__cacheIndex,
              s = --this._nActiveControlInterpolants,
              i = e[s];
            (t.__cacheIndex = s), (e[s] = t), (i.__cacheIndex = n), (e[n] = i);
          }
          clipAction(t, e, n) {
            const s = e || this._root,
              i = s.uuid;
            let r = "string" == typeof t ? ka.findByName(s, t) : t;
            const o = null !== r ? r.uuid : t,
              a = this._actionsByClip[o];
            let c = null;
            if (
              (void 0 === n && (n = null !== r ? r.blendMode : 2500),
              void 0 !== a)
            ) {
              const t = a.actionByRoot[i];
              if (void 0 !== t && t.blendMode === n) return t;
              (c = a.knownActions[0]), null === r && (r = c._clip);
            }
            if (null === r) return null;
            const u = new Mc(this, r, e, n);
            return this._bindAction(u, c), this._addInactiveAction(u, o, i), u;
          }
          existingAction(t, e) {
            const n = e || this._root,
              s = n.uuid,
              i = "string" == typeof t ? ka.findByName(n, t) : t,
              r = i ? i.uuid : t,
              o = this._actionsByClip[r];
            return (void 0 !== o && o.actionByRoot[s]) || null;
          }
          stopAllAction() {
            const t = this._actions;
            for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
            return this;
          }
          update(t) {
            t *= this.timeScale;
            const e = this._actions,
              n = this._nActiveActions,
              s = (this.time += t),
              i = Math.sign(t),
              r = (this._accuIndex ^= 1);
            for (let o = 0; o !== n; ++o) e[o]._update(s, t, i, r);
            const o = this._bindings,
              a = this._nActiveBindings;
            for (let t = 0; t !== a; ++t) o[t].apply(r);
            return this;
          }
          setTime(t) {
            this.time = 0;
            for (let t = 0; t < this._actions.length; t++)
              this._actions[t].time = 0;
            return this.update(t);
          }
          getRoot() {
            return this._root;
          }
          uncacheClip(t) {
            const e = this._actions,
              n = t.uuid,
              s = this._actionsByClip,
              i = s[n];
            if (void 0 !== i) {
              const t = i.knownActions;
              for (let n = 0, s = t.length; n !== s; ++n) {
                const s = t[n];
                this._deactivateAction(s);
                const i = s._cacheIndex,
                  r = e[e.length - 1];
                (s._cacheIndex = null),
                  (s._byClipCacheIndex = null),
                  (r._cacheIndex = i),
                  (e[i] = r),
                  e.pop(),
                  this._removeInactiveBindingsForAction(s);
              }
              delete s[n];
            }
          }
          uncacheRoot(t) {
            const e = t.uuid,
              n = this._actionsByClip;
            for (const t in n) {
              const s = n[t].actionByRoot[e];
              void 0 !== s &&
                (this._deactivateAction(s), this._removeInactiveAction(s));
            }
            const s = this._bindingsByRootAndName[e];
            if (void 0 !== s)
              for (const t in s) {
                const e = s[t];
                e.restoreOriginalState(), this._removeInactiveBinding(e);
              }
          }
          uncacheAction(t, e) {
            const n = this.existingAction(t, e);
            null !== n &&
              (this._deactivateAction(n), this._removeInactiveAction(n));
          }
        }
        Sc.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
        class Tc {
          constructor(t) {
            "string" == typeof t &&
              (console.warn(
                "THREE.Uniform: Type parameter is no longer needed."
              ),
              (t = arguments[1])),
              (this.value = t);
          }
          clone() {
            return new Tc(
              void 0 === this.value.clone ? this.value : this.value.clone()
            );
          }
        }
        (class extends Mr {
          constructor(t, e, n = 1) {
            super(t, e), (this.meshPerAttribute = n);
          }
          copy(t) {
            return (
              super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this
            );
          }
          clone(t) {
            const e = super.clone(t);
            return (e.meshPerAttribute = this.meshPerAttribute), e;
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              (e.isInstancedInterleavedBuffer = !0),
              (e.meshPerAttribute = this.meshPerAttribute),
              e
            );
          }
        }).prototype.isInstancedInterleavedBuffer = !0;
        class Ec {
          constructor(t, e, n = 0, s = 1 / 0) {
            (this.ray = new Vt(t, e)),
              (this.near = n),
              (this.far = s),
              (this.camera = null),
              (this.layers = new ee()),
              (this.params = {
                Mesh: {},
                Line: { threshold: 1 },
                LOD: {},
                Points: { threshold: 1 },
                Sprite: {},
              });
          }
          set(t, e) {
            this.ray.set(t, e);
          }
          setFromCamera(t, e) {
            e && e.isPerspectiveCamera
              ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
                this.ray.direction
                  .set(t.x, t.y, 0.5)
                  .unproject(e)
                  .sub(this.ray.origin)
                  .normalize(),
                (this.camera = e))
              : e && e.isOrthographicCamera
              ? (this.ray.origin
                  .set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
                  .unproject(e),
                this.ray.direction
                  .set(0, 0, -1)
                  .transformDirection(e.matrixWorld),
                (this.camera = e))
              : console.error(
                  "THREE.Raycaster: Unsupported camera type: " + e.type
                );
          }
          intersectObject(t, e = !0, n = []) {
            return Ac(t, this, n, e), n.sort(Cc), n;
          }
          intersectObjects(t, e = !0, n = []) {
            for (let s = 0, i = t.length; s < i; s++) Ac(t[s], this, n, e);
            return n.sort(Cc), n;
          }
        }
        function Cc(t, e) {
          return t.distance - e.distance;
        }
        function Ac(t, e, n, s) {
          if ((t.layers.test(e.layers) && t.raycast(e, n), !0 === s)) {
            const s = t.children;
            for (let t = 0, i = s.length; t < i; t++) Ac(s[t], e, n, !0);
          }
        }
        class Lc {
          constructor(t = 1, e = 0, n = 0) {
            return (this.radius = t), (this.phi = e), (this.theta = n), this;
          }
          set(t, e, n) {
            return (this.radius = t), (this.phi = e), (this.theta = n), this;
          }
          copy(t) {
            return (
              (this.radius = t.radius),
              (this.phi = t.phi),
              (this.theta = t.theta),
              this
            );
          }
          makeSafe() {
            const t = 1e-6;
            return (
              (this.phi = Math.max(t, Math.min(Math.PI - t, this.phi))), this
            );
          }
          setFromVector3(t) {
            return this.setFromCartesianCoords(t.x, t.y, t.z);
          }
          setFromCartesianCoords(t, e, n) {
            return (
              (this.radius = Math.sqrt(t * t + e * e + n * n)),
              0 === this.radius
                ? ((this.theta = 0), (this.phi = 0))
                : ((this.theta = Math.atan2(t, n)),
                  (this.phi = Math.acos(X(e / this.radius, -1, 1)))),
              this
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        const Rc = new Q();
        class Pc {
          constructor(t = new Q(1 / 0, 1 / 0), e = new Q(-1 / 0, -1 / 0)) {
            (this.min = t), (this.max = e);
          }
          set(t, e) {
            return this.min.copy(t), this.max.copy(e), this;
          }
          setFromPoints(t) {
            this.makeEmpty();
            for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
            return this;
          }
          setFromCenterAndSize(t, e) {
            const n = Rc.copy(e).multiplyScalar(0.5);
            return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return this.min.copy(t.min), this.max.copy(t.max), this;
          }
          makeEmpty() {
            return (
              (this.min.x = this.min.y = 1 / 0),
              (this.max.x = this.max.y = -1 / 0),
              this
            );
          }
          isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y;
          }
          getCenter(t) {
            return this.isEmpty()
              ? t.set(0, 0)
              : t.addVectors(this.min, this.max).multiplyScalar(0.5);
          }
          getSize(t) {
            return this.isEmpty()
              ? t.set(0, 0)
              : t.subVectors(this.max, this.min);
          }
          expandByPoint(t) {
            return this.min.min(t), this.max.max(t), this;
          }
          expandByVector(t) {
            return this.min.sub(t), this.max.add(t), this;
          }
          expandByScalar(t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this;
          }
          containsPoint(t) {
            return !(
              t.x < this.min.x ||
              t.x > this.max.x ||
              t.y < this.min.y ||
              t.y > this.max.y
            );
          }
          containsBox(t) {
            return (
              this.min.x <= t.min.x &&
              t.max.x <= this.max.x &&
              this.min.y <= t.min.y &&
              t.max.y <= this.max.y
            );
          }
          getParameter(t, e) {
            return e.set(
              (t.x - this.min.x) / (this.max.x - this.min.x),
              (t.y - this.min.y) / (this.max.y - this.min.y)
            );
          }
          intersectsBox(t) {
            return !(
              t.max.x < this.min.x ||
              t.min.x > this.max.x ||
              t.max.y < this.min.y ||
              t.min.y > this.max.y
            );
          }
          clampPoint(t, e) {
            return e.copy(t).clamp(this.min, this.max);
          }
          distanceToPoint(t) {
            return Rc.copy(t).clamp(this.min, this.max).sub(t).length();
          }
          intersect(t) {
            return this.min.max(t.min), this.max.min(t.max), this;
          }
          union(t) {
            return this.min.min(t.min), this.max.max(t.max), this;
          }
          translate(t) {
            return this.min.add(t), this.max.add(t), this;
          }
          equals(t) {
            return t.min.equals(this.min) && t.max.equals(this.max);
          }
        }
        Pc.prototype.isBox2 = !0;
        const Ic = new ft(),
          Dc = new Wt(),
          Nc = new Wt();
        function Oc(t) {
          const e = [];
          t && t.isBone && e.push(t);
          for (let n = 0; n < t.children.length; n++)
            e.push.apply(e, Oc(t.children[n]));
          return e;
        }
        const kc = new Float32Array(1);
        new Int32Array(kc.buffer),
          (Mo.create = function (t, e) {
            return (
              console.log("THREE.Curve.create() has been deprecated"),
              (t.prototype = Object.create(Mo.prototype)),
              (t.prototype.constructor = t),
              (t.prototype.getPoint = e),
              t
            );
          }),
          (Vo.prototype.fromPoints = function (t) {
            return (
              console.warn(
                "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
              ),
              this.setFromPoints(t)
            );
          }),
          (class extends fo {
            constructor(t = 10, e = 10, n = 4473924, s = 8947848) {
              (n = new Oe(n)), (s = new Oe(s));
              const i = e / 2,
                r = t / e,
                o = t / 2,
                a = [],
                c = [];
              for (let t = 0, u = 0, d = -o; t <= e; t++, d += r) {
                a.push(-o, 0, d, o, 0, d), a.push(d, 0, -o, d, 0, o);
                const e = t === i ? n : s;
                e.toArray(c, u),
                  (u += 3),
                  e.toArray(c, u),
                  (u += 3),
                  e.toArray(c, u),
                  (u += 3),
                  e.toArray(c, u),
                  (u += 3);
              }
              const u = new Ze();
              u.setAttribute("position", new Ge(a, 3)),
                u.setAttribute("color", new Ge(c, 3)),
                super(u, new so({ vertexColors: !0, toneMapped: !1 })),
                (this.type = "GridHelper");
            }
          }.prototype.setColors = function () {
            console.error(
              "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
            );
          }),
          (class extends fo {
            constructor(t) {
              const e = Oc(t),
                n = new Ze(),
                s = [],
                i = [],
                r = new Oe(0, 0, 1),
                o = new Oe(0, 1, 0);
              for (let t = 0; t < e.length; t++) {
                const n = e[t];
                n.parent &&
                  n.parent.isBone &&
                  (s.push(0, 0, 0),
                  s.push(0, 0, 0),
                  i.push(r.r, r.g, r.b),
                  i.push(o.r, o.g, o.b));
              }
              n.setAttribute("position", new Ge(s, 3)),
                n.setAttribute("color", new Ge(i, 3)),
                super(
                  n,
                  new so({
                    vertexColors: !0,
                    depthTest: !1,
                    depthWrite: !1,
                    toneMapped: !1,
                    transparent: !0,
                  })
                ),
                (this.type = "SkeletonHelper"),
                (this.isSkeletonHelper = !0),
                (this.root = t),
                (this.bones = e),
                (this.matrix = t.matrixWorld),
                (this.matrixAutoUpdate = !1);
            }
            updateMatrixWorld(t) {
              const e = this.bones,
                n = this.geometry,
                s = n.getAttribute("position");
              Nc.copy(this.root.matrixWorld).invert();
              for (let t = 0, n = 0; t < e.length; t++) {
                const i = e[t];
                i.parent &&
                  i.parent.isBone &&
                  (Dc.multiplyMatrices(Nc, i.matrixWorld),
                  Ic.setFromMatrixPosition(Dc),
                  s.setXYZ(n, Ic.x, Ic.y, Ic.z),
                  Dc.multiplyMatrices(Nc, i.parent.matrixWorld),
                  Ic.setFromMatrixPosition(Dc),
                  s.setXYZ(n + 1, Ic.x, Ic.y, Ic.z),
                  (n += 2));
              }
              (n.getAttribute("position").needsUpdate = !0),
                super.updateMatrixWorld(t);
            }
          }.prototype.update = function () {
            console.error(
              "THREE.SkeletonHelper: update() no longer needs to be called."
            );
          }),
          (Ba.prototype.extractUrlBase = function (t) {
            return (
              console.warn(
                "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
              ),
              cc.extractUrlBase(t)
            );
          }),
          (Ba.Handlers = {
            add: function () {
              console.error(
                "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
              );
            },
            get: function () {
              console.error(
                "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
              );
            },
          }),
          (Pc.prototype.center = function (t) {
            return (
              console.warn(
                "THREE.Box2: .center() has been renamed to .getCenter()."
              ),
              this.getCenter(t)
            );
          }),
          (Pc.prototype.empty = function () {
            return (
              console.warn(
                "THREE.Box2: .empty() has been renamed to .isEmpty()."
              ),
              this.isEmpty()
            );
          }),
          (Pc.prototype.isIntersectionBox = function (t) {
            return (
              console.warn(
                "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
              ),
              this.intersectsBox(t)
            );
          }),
          (Pc.prototype.size = function (t) {
            return (
              console.warn(
                "THREE.Box2: .size() has been renamed to .getSize()."
              ),
              this.getSize(t)
            );
          }),
          (gt.prototype.center = function (t) {
            return (
              console.warn(
                "THREE.Box3: .center() has been renamed to .getCenter()."
              ),
              this.getCenter(t)
            );
          }),
          (gt.prototype.empty = function () {
            return (
              console.warn(
                "THREE.Box3: .empty() has been renamed to .isEmpty()."
              ),
              this.isEmpty()
            );
          }),
          (gt.prototype.isIntersectionBox = function (t) {
            return (
              console.warn(
                "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
              ),
              this.intersectsBox(t)
            );
          }),
          (gt.prototype.isIntersectionSphere = function (t) {
            return (
              console.warn(
                "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
              ),
              this.intersectsSphere(t)
            );
          }),
          (gt.prototype.size = function (t) {
            return (
              console.warn(
                "THREE.Box3: .size() has been renamed to .getSize()."
              ),
              this.getSize(t)
            );
          }),
          (Ot.prototype.empty = function () {
            return (
              console.warn(
                "THREE.Sphere: .empty() has been renamed to .isEmpty()."
              ),
              this.isEmpty()
            );
          }),
          (Nn.prototype.setFromMatrix = function (t) {
            return (
              console.warn(
                "THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
              ),
              this.setFromProjectionMatrix(t)
            );
          }),
          (tt.prototype.flattenToArrayOffset = function (t, e) {
            return (
              console.warn(
                "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
              ),
              this.toArray(t, e)
            );
          }),
          (tt.prototype.multiplyVector3 = function (t) {
            return (
              console.warn(
                "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
              ),
              t.applyMatrix3(this)
            );
          }),
          (tt.prototype.multiplyVector3Array = function () {
            console.error(
              "THREE.Matrix3: .multiplyVector3Array() has been removed."
            );
          }),
          (tt.prototype.applyToBufferAttribute = function (t) {
            return (
              console.warn(
                "THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
              ),
              t.applyMatrix3(this)
            );
          }),
          (tt.prototype.applyToVector3Array = function () {
            console.error(
              "THREE.Matrix3: .applyToVector3Array() has been removed."
            );
          }),
          (tt.prototype.getInverse = function (t) {
            return (
              console.warn(
                "THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
              ),
              this.copy(t).invert()
            );
          }),
          (Wt.prototype.extractPosition = function (t) {
            return (
              console.warn(
                "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
              ),
              this.copyPosition(t)
            );
          }),
          (Wt.prototype.flattenToArrayOffset = function (t, e) {
            return (
              console.warn(
                "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
              ),
              this.toArray(t, e)
            );
          }),
          (Wt.prototype.getPosition = function () {
            return (
              console.warn(
                "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
              ),
              new ft().setFromMatrixColumn(this, 3)
            );
          }),
          (Wt.prototype.setRotationFromQuaternion = function (t) {
            return (
              console.warn(
                "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
              ),
              this.makeRotationFromQuaternion(t)
            );
          }),
          (Wt.prototype.multiplyToArray = function () {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
          }),
          (Wt.prototype.multiplyVector3 = function (t) {
            return (
              console.warn(
                "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
              ),
              t.applyMatrix4(this)
            );
          }),
          (Wt.prototype.multiplyVector4 = function (t) {
            return (
              console.warn(
                "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
              ),
              t.applyMatrix4(this)
            );
          }),
          (Wt.prototype.multiplyVector3Array = function () {
            console.error(
              "THREE.Matrix4: .multiplyVector3Array() has been removed."
            );
          }),
          (Wt.prototype.rotateAxis = function (t) {
            console.warn(
              "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
            ),
              t.transformDirection(this);
          }),
          (Wt.prototype.crossVector = function (t) {
            return (
              console.warn(
                "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
              ),
              t.applyMatrix4(this)
            );
          }),
          (Wt.prototype.translate = function () {
            console.error("THREE.Matrix4: .translate() has been removed.");
          }),
          (Wt.prototype.rotateX = function () {
            console.error("THREE.Matrix4: .rotateX() has been removed.");
          }),
          (Wt.prototype.rotateY = function () {
            console.error("THREE.Matrix4: .rotateY() has been removed.");
          }),
          (Wt.prototype.rotateZ = function () {
            console.error("THREE.Matrix4: .rotateZ() has been removed.");
          }),
          (Wt.prototype.rotateByAxis = function () {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
          }),
          (Wt.prototype.applyToBufferAttribute = function (t) {
            return (
              console.warn(
                "THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
              ),
              t.applyMatrix4(this)
            );
          }),
          (Wt.prototype.applyToVector3Array = function () {
            console.error(
              "THREE.Matrix4: .applyToVector3Array() has been removed."
            );
          }),
          (Wt.prototype.makeFrustum = function (t, e, n, s, i, r) {
            return (
              console.warn(
                "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
              ),
              this.makePerspective(t, e, s, n, i, r)
            );
          }),
          (Wt.prototype.getInverse = function (t) {
            return (
              console.warn(
                "THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
              ),
              this.copy(t).invert()
            );
          }),
          (Pn.prototype.isIntersectionLine = function (t) {
            return (
              console.warn(
                "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
              ),
              this.intersectsLine(t)
            );
          }),
          (ht.prototype.multiplyVector3 = function (t) {
            return (
              console.warn(
                "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
              ),
              t.applyQuaternion(this)
            );
          }),
          (ht.prototype.inverse = function () {
            return (
              console.warn(
                "THREE.Quaternion: .inverse() has been renamed to invert()."
              ),
              this.invert()
            );
          }),
          (Vt.prototype.isIntersectionBox = function (t) {
            return (
              console.warn(
                "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
              ),
              this.intersectsBox(t)
            );
          }),
          (Vt.prototype.isIntersectionPlane = function (t) {
            return (
              console.warn(
                "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
              ),
              this.intersectsPlane(t)
            );
          }),
          (Vt.prototype.isIntersectionSphere = function (t) {
            return (
              console.warn(
                "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
              ),
              this.intersectsSphere(t)
            );
          }),
          (Ee.prototype.area = function () {
            return (
              console.warn(
                "THREE.Triangle: .area() has been renamed to .getArea()."
              ),
              this.getArea()
            );
          }),
          (Ee.prototype.barycoordFromPoint = function (t, e) {
            return (
              console.warn(
                "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
              ),
              this.getBarycoord(t, e)
            );
          }),
          (Ee.prototype.midpoint = function (t) {
            return (
              console.warn(
                "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
              ),
              this.getMidpoint(t)
            );
          }),
          (Ee.prototypenormal = function (t) {
            return (
              console.warn(
                "THREE.Triangle: .normal() has been renamed to .getNormal()."
              ),
              this.getNormal(t)
            );
          }),
          (Ee.prototype.plane = function (t) {
            return (
              console.warn(
                "THREE.Triangle: .plane() has been renamed to .getPlane()."
              ),
              this.getPlane(t)
            );
          }),
          (Ee.barycoordFromPoint = function (t, e, n, s, i) {
            return (
              console.warn(
                "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
              ),
              Ee.getBarycoord(t, e, n, s, i)
            );
          }),
          (Ee.normal = function (t, e, n, s) {
            return (
              console.warn(
                "THREE.Triangle: .normal() has been renamed to .getNormal()."
              ),
              Ee.getNormal(t, e, n, s)
            );
          }),
          (Wo.prototype.extractAllPoints = function (t) {
            return (
              console.warn(
                "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
              ),
              this.extractPoints(t)
            );
          }),
          (Wo.prototype.extrude = function (t) {
            return (
              console.warn(
                "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
              ),
              new va(this, t)
            );
          }),
          (Wo.prototype.makeGeometry = function (t) {
            return (
              console.warn(
                "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
              ),
              new wa(this, t)
            );
          }),
          (Q.prototype.fromAttribute = function (t, e, n) {
            return (
              console.warn(
                "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
              ),
              this.fromBufferAttribute(t, e, n)
            );
          }),
          (Q.prototype.distanceToManhattan = function (t) {
            return (
              console.warn(
                "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
              ),
              this.manhattanDistanceTo(t)
            );
          }),
          (Q.prototype.lengthManhattan = function () {
            return (
              console.warn(
                "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
              ),
              this.manhattanLength()
            );
          }),
          (ft.prototype.setEulerFromRotationMatrix = function () {
            console.error(
              "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
            );
          }),
          (ft.prototype.setEulerFromQuaternion = function () {
            console.error(
              "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
            );
          }),
          (ft.prototype.getPositionFromMatrix = function (t) {
            return (
              console.warn(
                "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
              ),
              this.setFromMatrixPosition(t)
            );
          }),
          (ft.prototype.getScaleFromMatrix = function (t) {
            return (
              console.warn(
                "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
              ),
              this.setFromMatrixScale(t)
            );
          }),
          (ft.prototype.getColumnFromMatrix = function (t, e) {
            return (
              console.warn(
                "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
              ),
              this.setFromMatrixColumn(e, t)
            );
          }),
          (ft.prototype.applyProjection = function (t) {
            return (
              console.warn(
                "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
              ),
              this.applyMatrix4(t)
            );
          }),
          (ft.prototype.fromAttribute = function (t, e, n) {
            return (
              console.warn(
                "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
              ),
              this.fromBufferAttribute(t, e, n)
            );
          }),
          (ft.prototype.distanceToManhattan = function (t) {
            return (
              console.warn(
                "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
              ),
              this.manhattanDistanceTo(t)
            );
          }),
          (ft.prototype.lengthManhattan = function () {
            return (
              console.warn(
                "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
              ),
              this.manhattanLength()
            );
          }),
          (ut.prototype.fromAttribute = function (t, e, n) {
            return (
              console.warn(
                "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
              ),
              this.fromBufferAttribute(t, e, n)
            );
          }),
          (ut.prototype.lengthManhattan = function () {
            return (
              console.warn(
                "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
              ),
              this.manhattanLength()
            );
          }),
          (pe.prototype.getChildByName = function (t) {
            return (
              console.warn(
                "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
              ),
              this.getObjectByName(t)
            );
          }),
          (pe.prototype.renderDepth = function () {
            console.warn(
              "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
            );
          }),
          (pe.prototype.translate = function (t, e) {
            return (
              console.warn(
                "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
              ),
              this.translateOnAxis(e, t)
            );
          }),
          (pe.prototype.getWorldRotation = function () {
            console.error(
              "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
            );
          }),
          (pe.prototype.applyMatrix = function (t) {
            return (
              console.warn(
                "THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
              ),
              this.applyMatrix4(t)
            );
          }),
          Object.defineProperties(pe.prototype, {
            eulerOrder: {
              get: function () {
                return (
                  console.warn(
                    "THREE.Object3D: .eulerOrder is now .rotation.order."
                  ),
                  this.rotation.order
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.Object3D: .eulerOrder is now .rotation.order."
                ),
                  (this.rotation.order = t);
              },
            },
            useQuaternion: {
              get: function () {
                console.warn(
                  "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
                );
              },
              set: function () {
                console.warn(
                  "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
                );
              },
            },
          }),
          (pn.prototype.setDrawMode = function () {
            console.error(
              "THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
            );
          }),
          Object.defineProperties(pn.prototype, {
            drawMode: {
              get: function () {
                return (
                  console.error(
                    "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
                  ),
                  0
                );
              },
              set: function () {
                console.error(
                  "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
                );
              },
            },
          }),
          (Xr.prototype.initBones = function () {
            console.error("THREE.SkinnedMesh: initBones() has been removed.");
          }),
          (Mn.prototype.setLens = function (t, e) {
            console.warn(
              "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
            ),
              void 0 !== e && (this.filmGauge = e),
              this.setFocalLength(t);
          }),
          Object.defineProperties(Xa.prototype, {
            onlyShadow: {
              set: function () {
                console.warn("THREE.Light: .onlyShadow has been removed.");
              },
            },
            shadowCameraFov: {
              set: function (t) {
                console.warn(
                  "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
                ),
                  (this.shadow.camera.fov = t);
              },
            },
            shadowCameraLeft: {
              set: function (t) {
                console.warn(
                  "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
                ),
                  (this.shadow.camera.left = t);
              },
            },
            shadowCameraRight: {
              set: function (t) {
                console.warn(
                  "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
                ),
                  (this.shadow.camera.right = t);
              },
            },
            shadowCameraTop: {
              set: function (t) {
                console.warn(
                  "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
                ),
                  (this.shadow.camera.top = t);
              },
            },
            shadowCameraBottom: {
              set: function (t) {
                console.warn(
                  "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
                ),
                  (this.shadow.camera.bottom = t);
              },
            },
            shadowCameraNear: {
              set: function (t) {
                console.warn(
                  "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
                ),
                  (this.shadow.camera.near = t);
              },
            },
            shadowCameraFar: {
              set: function (t) {
                console.warn(
                  "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
                ),
                  (this.shadow.camera.far = t);
              },
            },
            shadowCameraVisible: {
              set: function () {
                console.warn(
                  "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
                );
              },
            },
            shadowBias: {
              set: function (t) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                  (this.shadow.bias = t);
              },
            },
            shadowDarkness: {
              set: function () {
                console.warn("THREE.Light: .shadowDarkness has been removed.");
              },
            },
            shadowMapWidth: {
              set: function (t) {
                console.warn(
                  "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
                ),
                  (this.shadow.mapSize.width = t);
              },
            },
            shadowMapHeight: {
              set: function (t) {
                console.warn(
                  "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
                ),
                  (this.shadow.mapSize.height = t);
              },
            },
          }),
          Object.defineProperties(Fe.prototype, {
            length: {
              get: function () {
                return (
                  console.warn(
                    "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
                  ),
                  this.array.length
                );
              },
            },
            dynamic: {
              get: function () {
                return (
                  console.warn(
                    "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
                  ),
                  this.usage === U
                );
              },
              set: function () {
                console.warn(
                  "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
                ),
                  this.setUsage(U);
              },
            },
          }),
          (Fe.prototype.setDynamic = function (t) {
            return (
              console.warn(
                "THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
              ),
              this.setUsage(!0 === t ? U : k),
              this
            );
          }),
          (Fe.prototype.copyIndicesArray = function () {
            console.error(
              "THREE.BufferAttribute: .copyIndicesArray() has been removed."
            );
          }),
          (Fe.prototype.setArray = function () {
            console.error(
              "THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
            );
          }),
          (Ze.prototype.addIndex = function (t) {
            console.warn(
              "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
            ),
              this.setIndex(t);
          }),
          (Ze.prototype.addAttribute = function (t, e) {
            return (
              console.warn(
                "THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
              ),
              (e && e.isBufferAttribute) ||
              (e && e.isInterleavedBufferAttribute)
                ? "index" === t
                  ? (console.warn(
                      "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
                    ),
                    this.setIndex(e),
                    this)
                  : this.setAttribute(t, e)
                : (console.warn(
                    "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
                  ),
                  this.setAttribute(t, new Fe(arguments[1], arguments[2])))
            );
          }),
          (Ze.prototype.addDrawCall = function (t, e, n) {
            void 0 !== n &&
              console.warn(
                "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
              ),
              console.warn(
                "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
              ),
              this.addGroup(t, e);
          }),
          (Ze.prototype.clearDrawCalls = function () {
            console.warn(
              "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
            ),
              this.clearGroups();
          }),
          (Ze.prototype.computeOffsets = function () {
            console.warn(
              "THREE.BufferGeometry: .computeOffsets() has been removed."
            );
          }),
          (Ze.prototype.removeAttribute = function (t) {
            return (
              console.warn(
                "THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
              ),
              this.deleteAttribute(t)
            );
          }),
          (Ze.prototype.applyMatrix = function (t) {
            return (
              console.warn(
                "THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
              ),
              this.applyMatrix4(t)
            );
          }),
          Object.defineProperties(Ze.prototype, {
            drawcalls: {
              get: function () {
                return (
                  console.error(
                    "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
                  ),
                  this.groups
                );
              },
            },
            offsets: {
              get: function () {
                return (
                  console.warn(
                    "THREE.BufferGeometry: .offsets has been renamed to .groups."
                  ),
                  this.groups
                );
              },
            },
          }),
          (Mr.prototype.setDynamic = function (t) {
            return (
              console.warn(
                "THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
              ),
              this.setUsage(!0 === t ? U : k),
              this
            );
          }),
          (Mr.prototype.setArray = function () {
            console.error(
              "THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
            );
          }),
          (va.prototype.getArrays = function () {
            console.error(
              "THREE.ExtrudeGeometry: .getArrays() has been removed."
            );
          }),
          (va.prototype.addShapeList = function () {
            console.error(
              "THREE.ExtrudeGeometry: .addShapeList() has been removed."
            );
          }),
          (va.prototype.addShape = function () {
            console.error(
              "THREE.ExtrudeGeometry: .addShape() has been removed."
            );
          }),
          (br.prototype.dispose = function () {
            console.error("THREE.Scene: .dispose() has been removed.");
          }),
          (Tc.prototype.onUpdate = function () {
            return (
              console.warn(
                "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
              ),
              this
            );
          }),
          Object.defineProperties(Ae.prototype, {
            wrapAround: {
              get: function () {
                console.warn("THREE.Material: .wrapAround has been removed.");
              },
              set: function () {
                console.warn("THREE.Material: .wrapAround has been removed.");
              },
            },
            overdraw: {
              get: function () {
                console.warn("THREE.Material: .overdraw has been removed.");
              },
              set: function () {
                console.warn("THREE.Material: .overdraw has been removed.");
              },
            },
            wrapRGB: {
              get: function () {
                return (
                  console.warn("THREE.Material: .wrapRGB has been removed."),
                  new Oe()
                );
              },
            },
            shading: {
              get: function () {
                console.error(
                  "THREE." +
                    this.type +
                    ": .shading has been removed. Use the boolean .flatShading instead."
                );
              },
              set: function (t) {
                console.warn(
                  "THREE." +
                    this.type +
                    ": .shading has been removed. Use the boolean .flatShading instead."
                ),
                  (this.flatShading = 1 === t);
              },
            },
            stencilMask: {
              get: function () {
                return (
                  console.warn(
                    "THREE." +
                      this.type +
                      ": .stencilMask has been removed. Use .stencilFuncMask instead."
                  ),
                  this.stencilFuncMask
                );
              },
              set: function (t) {
                console.warn(
                  "THREE." +
                    this.type +
                    ": .stencilMask has been removed. Use .stencilFuncMask instead."
                ),
                  (this.stencilFuncMask = t);
              },
            },
            vertexTangents: {
              get: function () {
                console.warn(
                  "THREE." + this.type + ": .vertexTangents has been removed."
                );
              },
              set: function () {
                console.warn(
                  "THREE." + this.type + ": .vertexTangents has been removed."
                );
              },
            },
          }),
          Object.defineProperties(_n.prototype, {
            derivatives: {
              get: function () {
                return (
                  console.warn(
                    "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
                  ),
                  this.extensions.derivatives
                );
              },
              set: function (t) {
                console.warn(
                  "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
                ),
                  (this.extensions.derivatives = t);
              },
            },
          }),
          (yr.prototype.clearTarget = function (t, e, n, s) {
            console.warn(
              "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
            ),
              this.setRenderTarget(t),
              this.clear(e, n, s);
          }),
          (yr.prototype.animate = function (t) {
            console.warn(
              "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
            ),
              this.setAnimationLoop(t);
          }),
          (yr.prototype.getCurrentRenderTarget = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
              ),
              this.getRenderTarget()
            );
          }),
          (yr.prototype.getMaxAnisotropy = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
              ),
              this.capabilities.getMaxAnisotropy()
            );
          }),
          (yr.prototype.getPrecision = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
              ),
              this.capabilities.precision
            );
          }),
          (yr.prototype.resetGLState = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
              ),
              this.state.reset()
            );
          }),
          (yr.prototype.supportsFloatTextures = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
              ),
              this.extensions.get("OES_texture_float")
            );
          }),
          (yr.prototype.supportsHalfFloatTextures = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
              ),
              this.extensions.get("OES_texture_half_float")
            );
          }),
          (yr.prototype.supportsStandardDerivatives = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
              ),
              this.extensions.get("OES_standard_derivatives")
            );
          }),
          (yr.prototype.supportsCompressedTextureS3TC = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
              ),
              this.extensions.get("WEBGL_compressed_texture_s3tc")
            );
          }),
          (yr.prototype.supportsCompressedTexturePVRTC = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
              ),
              this.extensions.get("WEBGL_compressed_texture_pvrtc")
            );
          }),
          (yr.prototype.supportsBlendMinMax = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
              ),
              this.extensions.get("EXT_blend_minmax")
            );
          }),
          (yr.prototype.supportsVertexTextures = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
              ),
              this.capabilities.vertexTextures
            );
          }),
          (yr.prototype.supportsInstancedArrays = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
              ),
              this.extensions.get("ANGLE_instanced_arrays")
            );
          }),
          (yr.prototype.enableScissorTest = function (t) {
            console.warn(
              "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
            ),
              this.setScissorTest(t);
          }),
          (yr.prototype.initMaterial = function () {
            console.warn(
              "THREE.WebGLRenderer: .initMaterial() has been removed."
            );
          }),
          (yr.prototype.addPrePlugin = function () {
            console.warn(
              "THREE.WebGLRenderer: .addPrePlugin() has been removed."
            );
          }),
          (yr.prototype.addPostPlugin = function () {
            console.warn(
              "THREE.WebGLRenderer: .addPostPlugin() has been removed."
            );
          }),
          (yr.prototype.updateShadowMap = function () {
            console.warn(
              "THREE.WebGLRenderer: .updateShadowMap() has been removed."
            );
          }),
          (yr.prototype.setFaceCulling = function () {
            console.warn(
              "THREE.WebGLRenderer: .setFaceCulling() has been removed."
            );
          }),
          (yr.prototype.allocTextureUnit = function () {
            console.warn(
              "THREE.WebGLRenderer: .allocTextureUnit() has been removed."
            );
          }),
          (yr.prototype.setTexture = function () {
            console.warn(
              "THREE.WebGLRenderer: .setTexture() has been removed."
            );
          }),
          (yr.prototype.setTexture2D = function () {
            console.warn(
              "THREE.WebGLRenderer: .setTexture2D() has been removed."
            );
          }),
          (yr.prototype.setTextureCube = function () {
            console.warn(
              "THREE.WebGLRenderer: .setTextureCube() has been removed."
            );
          }),
          (yr.prototype.getActiveMipMapLevel = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
              ),
              this.getActiveMipmapLevel()
            );
          }),
          Object.defineProperties(yr.prototype, {
            shadowMapEnabled: {
              get: function () {
                return this.shadowMap.enabled;
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
                ),
                  (this.shadowMap.enabled = t);
              },
            },
            shadowMapType: {
              get: function () {
                return this.shadowMap.type;
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
                ),
                  (this.shadowMap.type = t);
              },
            },
            shadowMapCullFace: {
              get: function () {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
                );
              },
              set: function () {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
                );
              },
            },
            context: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
                  ),
                  this.getContext()
                );
              },
            },
            vr: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderer: .vr has been renamed to .xr"
                  ),
                  this.xr
                );
              },
            },
            gammaInput: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
                  ),
                  !1
                );
              },
              set: function () {
                console.warn(
                  "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
                );
              },
            },
            gammaOutput: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
                  ),
                  !1
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
                ),
                  (this.outputEncoding = !0 === t ? I : P);
              },
            },
            toneMappingWhitePoint: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
                  ),
                  1
                );
              },
              set: function () {
                console.warn(
                  "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
                );
              },
            },
          }),
          Object.defineProperties(ur.prototype, {
            cullFace: {
              get: function () {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
                );
              },
              set: function () {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
                );
              },
            },
            renderReverseSided: {
              get: function () {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
                );
              },
              set: function () {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
                );
              },
            },
            renderSingleSided: {
              get: function () {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
                );
              },
              set: function () {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
                );
              },
            },
          }),
          Object.defineProperties(dt.prototype, {
            wrapS: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
                  ),
                  this.texture.wrapS
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
                ),
                  (this.texture.wrapS = t);
              },
            },
            wrapT: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
                  ),
                  this.texture.wrapT
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
                ),
                  (this.texture.wrapT = t);
              },
            },
            magFilter: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
                  ),
                  this.texture.magFilter
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
                ),
                  (this.texture.magFilter = t);
              },
            },
            minFilter: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
                  ),
                  this.texture.minFilter
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
                ),
                  (this.texture.minFilter = t);
              },
            },
            anisotropy: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
                  ),
                  this.texture.anisotropy
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
                ),
                  (this.texture.anisotropy = t);
              },
            },
            offset: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .offset is now .texture.offset."
                  ),
                  this.texture.offset
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .offset is now .texture.offset."
                ),
                  (this.texture.offset = t);
              },
            },
            repeat: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
                  ),
                  this.texture.repeat
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
                ),
                  (this.texture.repeat = t);
              },
            },
            format: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .format is now .texture.format."
                  ),
                  this.texture.format
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .format is now .texture.format."
                ),
                  (this.texture.format = t);
              },
            },
            type: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .type is now .texture.type."
                  ),
                  this.texture.type
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .type is now .texture.type."
                ),
                  (this.texture.type = t);
              },
            },
            generateMipmaps: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
                  ),
                  this.texture.generateMipmaps
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
                ),
                  (this.texture.generateMipmaps = t);
              },
            },
          }),
          (class extends pe {
            constructor(t) {
              super(),
                (this.type = "Audio"),
                (this.listener = t),
                (this.context = t.context),
                (this.gain = this.context.createGain()),
                this.gain.connect(t.getInput()),
                (this.autoplay = !1),
                (this.buffer = null),
                (this.detune = 0),
                (this.loop = !1),
                (this.loopStart = 0),
                (this.loopEnd = 0),
                (this.offset = 0),
                (this.duration = void 0),
                (this.playbackRate = 1),
                (this.isPlaying = !1),
                (this.hasPlaybackControl = !0),
                (this.source = null),
                (this.sourceType = "empty"),
                (this._startedAt = 0),
                (this._progress = 0),
                (this._connected = !1),
                (this.filters = []);
            }
            getOutput() {
              return this.gain;
            }
            setNodeSource(t) {
              return (
                (this.hasPlaybackControl = !1),
                (this.sourceType = "audioNode"),
                (this.source = t),
                this.connect(),
                this
              );
            }
            setMediaElementSource(t) {
              return (
                (this.hasPlaybackControl = !1),
                (this.sourceType = "mediaNode"),
                (this.source = this.context.createMediaElementSource(t)),
                this.connect(),
                this
              );
            }
            setMediaStreamSource(t) {
              return (
                (this.hasPlaybackControl = !1),
                (this.sourceType = "mediaStreamNode"),
                (this.source = this.context.createMediaStreamSource(t)),
                this.connect(),
                this
              );
            }
            setBuffer(t) {
              return (
                (this.buffer = t),
                (this.sourceType = "buffer"),
                this.autoplay && this.play(),
                this
              );
            }
            play(t = 0) {
              if (!0 === this.isPlaying)
                return void console.warn(
                  "THREE.Audio: Audio is already playing."
                );
              if (!1 === this.hasPlaybackControl)
                return void console.warn(
                  "THREE.Audio: this Audio has no playback control."
                );
              this._startedAt = this.context.currentTime + t;
              const e = this.context.createBufferSource();
              return (
                (e.buffer = this.buffer),
                (e.loop = this.loop),
                (e.loopStart = this.loopStart),
                (e.loopEnd = this.loopEnd),
                (e.onended = this.onEnded.bind(this)),
                e.start(
                  this._startedAt,
                  this._progress + this.offset,
                  this.duration
                ),
                (this.isPlaying = !0),
                (this.source = e),
                this.setDetune(this.detune),
                this.setPlaybackRate(this.playbackRate),
                this.connect()
              );
            }
            pause() {
              if (!1 !== this.hasPlaybackControl)
                return (
                  !0 === this.isPlaying &&
                    ((this._progress +=
                      Math.max(this.context.currentTime - this._startedAt, 0) *
                      this.playbackRate),
                    !0 === this.loop &&
                      (this._progress =
                        this._progress %
                        (this.duration || this.buffer.duration)),
                    this.source.stop(),
                    (this.source.onended = null),
                    (this.isPlaying = !1)),
                  this
                );
              console.warn("THREE.Audio: this Audio has no playback control.");
            }
            stop() {
              if (!1 !== this.hasPlaybackControl)
                return (
                  (this._progress = 0),
                  this.source.stop(),
                  (this.source.onended = null),
                  (this.isPlaying = !1),
                  this
                );
              console.warn("THREE.Audio: this Audio has no playback control.");
            }
            connect() {
              if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (let t = 1, e = this.filters.length; t < e; t++)
                  this.filters[t - 1].connect(this.filters[t]);
                this.filters[this.filters.length - 1].connect(this.getOutput());
              } else this.source.connect(this.getOutput());
              return (this._connected = !0), this;
            }
            disconnect() {
              if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (let t = 1, e = this.filters.length; t < e; t++)
                  this.filters[t - 1].disconnect(this.filters[t]);
                this.filters[this.filters.length - 1].disconnect(
                  this.getOutput()
                );
              } else this.source.disconnect(this.getOutput());
              return (this._connected = !1), this;
            }
            getFilters() {
              return this.filters;
            }
            setFilters(t) {
              return (
                t || (t = []),
                !0 === this._connected
                  ? (this.disconnect(),
                    (this.filters = t.slice()),
                    this.connect())
                  : (this.filters = t.slice()),
                this
              );
            }
            setDetune(t) {
              if (((this.detune = t), void 0 !== this.source.detune))
                return (
                  !0 === this.isPlaying &&
                    this.source.detune.setTargetAtTime(
                      this.detune,
                      this.context.currentTime,
                      0.01
                    ),
                  this
                );
            }
            getDetune() {
              return this.detune;
            }
            getFilter() {
              return this.getFilters()[0];
            }
            setFilter(t) {
              return this.setFilters(t ? [t] : []);
            }
            setPlaybackRate(t) {
              if (!1 !== this.hasPlaybackControl)
                return (
                  (this.playbackRate = t),
                  !0 === this.isPlaying &&
                    this.source.playbackRate.setTargetAtTime(
                      this.playbackRate,
                      this.context.currentTime,
                      0.01
                    ),
                  this
                );
              console.warn("THREE.Audio: this Audio has no playback control.");
            }
            getPlaybackRate() {
              return this.playbackRate;
            }
            onEnded() {
              this.isPlaying = !1;
            }
            getLoop() {
              return !1 === this.hasPlaybackControl
                ? (console.warn(
                    "THREE.Audio: this Audio has no playback control."
                  ),
                  !1)
                : this.loop;
            }
            setLoop(t) {
              if (!1 !== this.hasPlaybackControl)
                return (
                  (this.loop = t),
                  !0 === this.isPlaying && (this.source.loop = this.loop),
                  this
                );
              console.warn("THREE.Audio: this Audio has no playback control.");
            }
            setLoopStart(t) {
              return (this.loopStart = t), this;
            }
            setLoopEnd(t) {
              return (this.loopEnd = t), this;
            }
            getVolume() {
              return this.gain.gain.value;
            }
            setVolume(t) {
              return (
                this.gain.gain.setTargetAtTime(
                  t,
                  this.context.currentTime,
                  0.01
                ),
                this
              );
            }
          }.prototype.load = function (t) {
            console.warn(
              "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
            );
            const e = this;
            return (
              new lc().load(t, function (t) {
                e.setBuffer(t);
              }),
              this
            );
          }),
          (Tn.prototype.updateCubeMap = function (t, e) {
            return (
              console.warn(
                "THREE.CubeCamera: .updateCubeMap() is now .update()."
              ),
              this.update(t, e)
            );
          }),
          (Tn.prototype.clear = function (t, e, n, s) {
            return (
              console.warn(
                "THREE.CubeCamera: .clear() is now .renderTarget.clear()."
              ),
              this.renderTarget.clear(t, e, n, s)
            );
          }),
          (rt.crossOrigin = void 0),
          (rt.loadTexture = function (t, e, n, s) {
            console.warn(
              "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
            );
            const i = new ja();
            i.setCrossOrigin(this.crossOrigin);
            const r = i.load(t, n, void 0, s);
            return e && (r.mapping = e), r;
          }),
          (rt.loadTextureCube = function (t, e, n, s) {
            console.warn(
              "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
            );
            const i = new Wa();
            i.setCrossOrigin(this.crossOrigin);
            const r = i.load(t, n, void 0, s);
            return e && (r.mapping = e), r;
          }),
          (rt.loadCompressedTexture = function () {
            console.error(
              "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
            );
          }),
          (rt.loadCompressedTextureCube = function () {
            console.error(
              "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
            );
          }),
          "undefined" != typeof __THREE_DEVTOOLS__ &&
            __THREE_DEVTOOLS__.dispatchEvent(
              new CustomEvent("register", { detail: { revision: "134" } })
            ),
          "undefined" != typeof window &&
            (window.__THREE__
              ? console.warn(
                  "WARNING: Multiple instances of Three.js being imported."
                )
              : (window.__THREE__ = "134"));
        class Uc {
          constructor(t, e, n, s, i = "div") {
            (this.parent = t),
              (this.object = e),
              (this.property = n),
              (this._disabled = !1),
              (this.initialValue = this.getValue()),
              (this.domElement = document.createElement("div")),
              this.domElement.classList.add("controller"),
              this.domElement.classList.add(s),
              (this.$name = document.createElement("div")),
              this.$name.classList.add("name"),
              (Uc.nextNameID = Uc.nextNameID || 0),
              (this.$name.id = "lil-gui-name-" + ++Uc.nextNameID),
              (this.$widget = document.createElement(i)),
              this.$widget.classList.add("widget"),
              (this.$disable = this.$widget),
              this.domElement.appendChild(this.$name),
              this.domElement.appendChild(this.$widget),
              this.parent.children.push(this),
              this.parent.controllers.push(this),
              this.parent.$children.appendChild(this.domElement),
              (this._listenCallback = this._listenCallback.bind(this)),
              this.name(n);
          }
          name(t) {
            return (this._name = t), (this.$name.innerHTML = t), this;
          }
          onChange(t) {
            return (this._onChange = t), this;
          }
          _callOnChange() {
            this.parent._callOnChange(this),
              void 0 !== this._onChange &&
                this._onChange.call(this, this.getValue());
          }
          onFinishChange(t) {
            return this.onChange(t);
          }
          reset() {
            return this.setValue(this.initialValue), this;
          }
          enable(t = !0) {
            return this.disable(!t);
          }
          disable(t = !0) {
            return (
              t === this._disabled ||
                ((this._disabled = t),
                this.domElement.classList.toggle("disabled", t),
                t
                  ? this.$disable.setAttribute("disabled", "disabled")
                  : this.$disable.removeAttribute("disabled")),
              this
            );
          }
          options(t) {
            const e = this.parent.add(this.object, this.property, t);
            return e.name(this._name), this.destroy(), e;
          }
          min(t) {
            return this;
          }
          max(t) {
            return this;
          }
          step(t) {
            return this;
          }
          listen(t = !0) {
            return (
              (this._listening = t),
              void 0 !== this._listenCallbackID &&
                (cancelAnimationFrame(this._listenCallbackID),
                (this._listenCallbackID = void 0)),
              this._listening && this._listenCallback(),
              this
            );
          }
          _listenCallback() {
            this._listenCallbackID = requestAnimationFrame(
              this._listenCallback
            );
            const t = this.getValue();
            (t === this._listenValuePrev && Object(t) !== t) ||
              this.updateDisplay(),
              (this._listenValuePrev = t);
          }
          getValue() {
            return this.object[this.property];
          }
          setValue(t) {
            return (
              (this.object[this.property] = t),
              this._callOnChange(),
              this.updateDisplay(),
              this
            );
          }
          updateDisplay() {
            return this;
          }
          load(t) {
            this.setValue(t);
          }
          save() {
            return this.getValue();
          }
          destroy() {
            this.parent.children.splice(this.parent.children.indexOf(this), 1),
              this.parent.controllers.splice(
                this.parent.controllers.indexOf(this),
                1
              ),
              this.parent.$children.removeChild(this.domElement);
          }
        }
        class zc extends Uc {
          constructor(t, e, n) {
            super(t, e, n, "boolean", "label"),
              (this.$input = document.createElement("input")),
              this.$input.setAttribute("type", "checkbox"),
              this.$widget.appendChild(this.$input),
              this.$input.addEventListener("change", () => {
                this.setValue(this.$input.checked);
              }),
              (this.$disable = this.$input),
              this.updateDisplay();
          }
          updateDisplay() {
            return (this.$input.checked = this.getValue()), this;
          }
        }
        function Fc(t) {
          let e, n;
          return (
            (e = t.match(/(#|0x)?([a-f0-9]{6})/i))
              ? (n = e[2])
              : (e = t.match(/rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\)/))
              ? (n =
                  parseInt(e[1]).toString(16).padStart(2, 0) +
                  parseInt(e[2]).toString(16).padStart(2, 0) +
                  parseInt(e[3]).toString(16).padStart(2, 0))
              : (e = t.match(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i)) &&
                (n = e[1] + e[1] + e[2] + e[2] + e[3] + e[3]),
            !!n && "#" + n
          );
        }
        const Bc = {
            isPrimitive: !0,
            match: (t) => "string" == typeof t,
            fromHexString: Fc,
            toHexString: Fc,
          },
          Hc = {
            isPrimitive: !0,
            match: (t) => "number" == typeof t,
            fromHexString: (t) => parseInt(t.substring(1), 16),
            toHexString: (t) => "#" + t.toString(16).padStart(6, 0),
          },
          Gc = {
            isPrimitive: !1,
            match: Array.isArray,
            fromHexString(t, e, n = 1) {
              const s = Hc.fromHexString(t);
              (e[0] = (((s >> 16) & 255) / 255) * n),
                (e[1] = (((s >> 8) & 255) / 255) * n),
                (e[2] = ((255 & s) / 255) * n);
            },
            toHexString: ([t, e, n], s = 1) =>
              Hc.toHexString(
                ((t * (s = 255 / s)) << 16) ^ ((e * s) << 8) ^ ((n * s) << 0)
              ),
          },
          Vc = {
            isPrimitive: !1,
            match: (t) => Object(t) === t,
            fromHexString(t, e, n = 1) {
              const s = Hc.fromHexString(t);
              (e.r = (((s >> 16) & 255) / 255) * n),
                (e.g = (((s >> 8) & 255) / 255) * n),
                (e.b = ((255 & s) / 255) * n);
            },
            toHexString: ({ r: t, g: e, b: n }, s = 1) =>
              Hc.toHexString(
                ((t * (s = 255 / s)) << 16) ^ ((e * s) << 8) ^ ((n * s) << 0)
              ),
          },
          Wc = [Bc, Hc, Gc, Vc];
        class jc extends Uc {
          constructor(t, e, n, s) {
            var i;
            super(t, e, n, "color"),
              (this.$input = document.createElement("input")),
              this.$input.setAttribute("type", "color"),
              this.$input.setAttribute("tabindex", -1),
              this.$input.setAttribute("aria-labelledby", this.$name.id),
              (this.$text = document.createElement("input")),
              this.$text.setAttribute("type", "text"),
              this.$text.setAttribute("spellcheck", "false"),
              this.$text.setAttribute("aria-labelledby", this.$name.id),
              (this.$display = document.createElement("div")),
              this.$display.classList.add("display"),
              this.$display.appendChild(this.$input),
              this.$widget.appendChild(this.$display),
              this.$widget.appendChild(this.$text),
              (this._format =
                ((i = this.initialValue), Wc.find((t) => t.match(i)))),
              (this._rgbScale = s),
              (this._initialValueHexString = this.save()),
              (this._textFocused = !1);
            const r = () => {
              this._setValueFromHexString(this.$input.value);
            };
            this.$input.addEventListener("change", r),
              this.$input.addEventListener("input", r),
              this.$input.addEventListener("focus", () => {
                this.$display.classList.add("focus");
              }),
              this.$input.addEventListener("blur", () => {
                this.$display.classList.remove("focus");
              }),
              this.$text.addEventListener("input", () => {
                const t = Fc(this.$text.value);
                t && this._setValueFromHexString(t);
              }),
              this.$text.addEventListener("focus", () => {
                (this._textFocused = !0), this.$text.select();
              }),
              this.$text.addEventListener("blur", () => {
                (this._textFocused = !1), this.updateDisplay();
              }),
              (this.$disable = this.$text),
              this.updateDisplay();
          }
          reset() {
            return (
              this._setValueFromHexString(this._initialValueHexString), this
            );
          }
          _setValueFromHexString(t) {
            if (this._format.isPrimitive) {
              const e = this._format.fromHexString(t);
              this.setValue(e);
            } else
              this._format.fromHexString(t, this.getValue(), this._rgbScale),
                this._callOnChange(),
                this.updateDisplay();
          }
          save() {
            return this._format.toHexString(this.getValue(), this._rgbScale);
          }
          load(t) {
            this._setValueFromHexString(t);
          }
          updateDisplay() {
            return (
              (this.$input.value = this._format.toHexString(
                this.getValue(),
                this._rgbScale
              )),
              this._textFocused ||
                (this.$text.value = this.$input.value.substring(1)),
              (this.$display.style.backgroundColor = this.$input.value),
              this
            );
          }
        }
        class Xc extends Uc {
          constructor(t, e, n) {
            super(t, e, n, "function"),
              (this.$button = document.createElement("button")),
              this.$button.appendChild(this.$name),
              this.$widget.appendChild(this.$button),
              this.$button.addEventListener("click", (t) => {
                t.preventDefault(), this.getValue().call(this.object);
              }),
              this.$button.addEventListener("touchstart", () => {}),
              (this.$disable = this.$button);
          }
        }
        class qc extends Uc {
          constructor(t, e, n, s, i, r) {
            super(t, e, n, "number"),
              this._initInput(),
              this.min(s),
              this.max(i);
            const o = void 0 !== r;
            this.step(o ? r : this._getImplicitStep(), o), this.updateDisplay();
          }
          min(t) {
            return (this._min = t), this._onUpdateMinMax(), this;
          }
          max(t) {
            return (this._max = t), this._onUpdateMinMax(), this;
          }
          step(t, e = !0) {
            return (this._step = t), (this._stepExplicit = e), this;
          }
          updateDisplay() {
            const t = this.getValue();
            if (this._hasSlider) {
              const e = (t - this._min) / (this._max - this._min);
              this.$fill.style.setProperty("width", 100 * e + "%");
            }
            return this._inputFocused || (this.$input.value = t), this;
          }
          _initInput() {
            (this.$input = document.createElement("input")),
              this.$input.setAttribute("type", "text"),
              this.$input.setAttribute("inputmode", "numeric"),
              this.$input.setAttribute("aria-labelledby", this.$name.id),
              this.$widget.appendChild(this.$input),
              (this.$disable = this.$input);
            const t = (t) => {
              const e = parseFloat(this.$input.value);
              isNaN(e) ||
                (this._snapClampSetValue(e + t),
                (this.$input.value = this.getValue()));
            };
            this.$input.addEventListener("focus", () => {
              this._inputFocused = !0;
            }),
              this.$input.addEventListener("input", () => {
                const t = parseFloat(this.$input.value);
                isNaN(t) || this.setValue(this._clamp(t));
              }),
              this.$input.addEventListener("blur", () => {
                (this._inputFocused = !1), this.updateDisplay();
              }),
              this.$input.addEventListener("keydown", (e) => {
                "Enter" === e.code && this.$input.blur(),
                  "ArrowUp" === e.code &&
                    (e.preventDefault(),
                    t(this._step * this._arrowKeyMultiplier(e))),
                  "ArrowDown" === e.code &&
                    (e.preventDefault(),
                    t(-1 * this._step * this._arrowKeyMultiplier(e)));
              }),
              this.$input.addEventListener(
                "wheel",
                (e) => {
                  this._inputFocused &&
                    (e.preventDefault(),
                    t(this._normalizeMouseWheel(e) * this._step));
                },
                { passive: !1 }
              );
          }
          _initSlider() {
            (this._hasSlider = !0),
              (this.$slider = document.createElement("div")),
              this.$slider.classList.add("slider"),
              (this.$fill = document.createElement("div")),
              this.$fill.classList.add("fill"),
              this.$slider.appendChild(this.$fill),
              this.$widget.insertBefore(this.$slider, this.$input),
              this.domElement.classList.add("hasSlider");
            const t = (t) => {
                const e = this.$slider.getBoundingClientRect();
                let n =
                  ((s = t),
                  (i = e.left),
                  (r = e.right),
                  (o = this._min),
                  ((s - i) / (r - i)) * (this._max - o) + o);
                var s, i, r, o;
                this._snapClampSetValue(n);
              },
              e = (e) => {
                t(e.clientX);
              },
              n = () => {
                this._setActiveStyle(!1),
                  window.removeEventListener("mousemove", e),
                  window.removeEventListener("mouseup", n);
              };
            this.$slider.addEventListener("mousedown", (s) => {
              t(s.clientX),
                this._setActiveStyle(!0),
                window.addEventListener("mousemove", e),
                window.addEventListener("mouseup", n);
            });
            let s,
              i,
              r = !1;
            const o = (e) => {
                if (r) {
                  const n = e.touches[0].clientX - s,
                    c = e.touches[0].clientY - i;
                  Math.abs(n) > Math.abs(c)
                    ? (e.preventDefault(),
                      t(e.touches[0].clientX),
                      this._setActiveStyle(!0),
                      (r = !1))
                    : (window.removeEventListener("touchmove", o),
                      window.removeEventListener("touchend", a));
                } else e.preventDefault(), t(e.touches[0].clientX);
              },
              a = () => {
                this._setActiveStyle(!1),
                  window.removeEventListener("touchmove", o),
                  window.removeEventListener("touchend", a);
              };
            this.$slider.addEventListener("touchstart", (e) => {
              e.touches.length > 1 ||
                (this._hasScrollBar
                  ? ((s = e.touches[0].clientX),
                    (i = e.touches[0].clientY),
                    (r = !0))
                  : (e.preventDefault(),
                    t(e.touches[0].clientX),
                    this._setActiveStyle(!0),
                    (r = !1)),
                window.addEventListener("touchmove", o, { passive: !1 }),
                window.addEventListener("touchend", a));
            }),
              this.$slider.addEventListener(
                "wheel",
                (t) => {
                  if (
                    Math.abs(t.deltaX) < Math.abs(t.deltaY) &&
                    this._hasScrollBar
                  )
                    return;
                  t.preventDefault();
                  const e = this._normalizeMouseWheel(t) * this._step;
                  this._snapClampSetValue(this.getValue() + e);
                },
                { passive: !1 }
              );
          }
          _setActiveStyle(t) {
            this.$slider.classList.toggle("active", t),
              document.body.classList.toggle("lil-gui-slider-active", t);
          }
          _getImplicitStep() {
            return this._hasMin && this._hasMax
              ? (this._max - this._min) / 1e3
              : 0.1;
          }
          _onUpdateMinMax() {
            !this._hasSlider &&
              this._hasMin &&
              this._hasMax &&
              (this._stepExplicit || this.step(this._getImplicitStep(), !1),
              this._initSlider(),
              this.updateDisplay());
          }
          _normalizeMouseWheel(t) {
            let { deltaX: e, deltaY: n } = t;
            return (
              Math.floor(t.deltaY) !== t.deltaY &&
                t.wheelDelta &&
                ((e = 0), (n = -t.wheelDelta / 120)),
              e + -n
            );
          }
          _arrowKeyMultiplier(t) {
            return this._stepExplicit
              ? t.shiftKey
                ? 10
                : 1
              : t.shiftKey
              ? 100
              : t.altKey
              ? 1
              : 10;
          }
          _snap(t) {
            const e = Math.round(t / this._step) * this._step;
            return parseFloat(e.toPrecision(15));
          }
          _clamp(t) {
            const e = this._hasMin ? this._min : -1 / 0,
              n = this._hasMax ? this._max : 1 / 0;
            return Math.max(e, Math.min(n, t));
          }
          _snapClampSetValue(t) {
            this.setValue(this._clamp(this._snap(t)));
          }
          get _hasScrollBar() {
            const t = this.parent.root.$children;
            return t.scrollHeight > t.clientHeight;
          }
          get _hasMin() {
            return void 0 !== this._min;
          }
          get _hasMax() {
            return void 0 !== this._max;
          }
        }
        class Yc extends Uc {
          constructor(t, e, n, s) {
            super(t, e, n, "option"),
              (this.$select = document.createElement("select")),
              this.$select.setAttribute("aria-labelledby", this.$name.id),
              (this.$display = document.createElement("div")),
              this.$display.classList.add("display"),
              (this._values = Array.isArray(s) ? s : Object.values(s)),
              (this._names = Array.isArray(s) ? s : Object.keys(s)),
              this._names.forEach((t) => {
                const e = document.createElement("option");
                (e.innerHTML = t), this.$select.appendChild(e);
              }),
              this.$select.addEventListener("change", () => {
                this.setValue(this._values[this.$select.selectedIndex]);
              }),
              this.$select.addEventListener("focus", () => {
                this.$display.classList.add("focus");
              }),
              this.$select.addEventListener("blur", () => {
                this.$display.classList.remove("focus");
              }),
              this.$widget.appendChild(this.$select),
              this.$widget.appendChild(this.$display),
              (this.$disable = this.$select),
              this.updateDisplay();
          }
          updateDisplay() {
            const t = this.getValue(),
              e = this._values.indexOf(t);
            return (
              (this.$select.selectedIndex = e),
              (this.$display.innerHTML = -1 === e ? t : this._names[e]),
              this
            );
          }
        }
        class Jc extends Uc {
          constructor(t, e, n) {
            super(t, e, n, "string"),
              (this.$input = document.createElement("input")),
              this.$input.setAttribute("type", "text"),
              this.$input.setAttribute("aria-labelledby", this.$name.id),
              this.$input.addEventListener("input", () => {
                this.setValue(this.$input.value);
              }),
              this.$input.addEventListener("keydown", (t) => {
                "Enter" === t.code && this.$input.blur();
              }),
              this.$widget.appendChild(this.$input),
              (this.$disable = this.$input),
              this.updateDisplay();
          }
          updateDisplay() {
            return (this.$input.value = this.getValue()), this;
          }
        }
        let Zc = !1;
        class $c {
          constructor({
            parent: t,
            autoPlace: e = void 0 === t,
            touchStyles: n = !0,
            container: s,
            injectStyles: i = !0,
            title: r = "Controls",
            width: o,
          } = {}) {
            if (
              ((this.parent = t),
              (this.root = t ? t.root : this),
              (this.children = []),
              (this.controllers = []),
              (this.folders = []),
              (this._closed = !1),
              (this.domElement = document.createElement("div")),
              this.domElement.classList.add("lil-gui"),
              (this.$title = document.createElement("div")),
              this.$title.classList.add("title"),
              this.$title.setAttribute("role", "button"),
              this.$title.setAttribute("aria-expanded", !0),
              this.$title.setAttribute("tabindex", 0),
              this.$title.addEventListener("click", () =>
                this.openAnimated(this._closed)
              ),
              this.$title.addEventListener("keydown", (t) => {
                ("Enter" !== t.code && "Space" !== t.code) ||
                  (t.preventDefault(), this.$title.click());
              }),
              this.$title.addEventListener("touchstart", () => {}),
              (this.$children = document.createElement("div")),
              this.$children.classList.add("children"),
              this.domElement.appendChild(this.$title),
              this.domElement.appendChild(this.$children),
              this.title(r),
              this.parent)
            )
              return (
                this.parent.children.push(this),
                this.parent.folders.push(this),
                void this.parent.$children.appendChild(this.domElement)
              );
            this.domElement.classList.add("root"),
              !Zc &&
                i &&
                ((function (t) {
                  const e = document.createElement("style");
                  e.innerHTML =
                    '.lil-gui {\n  font-family: var(--font-family);\n  font-size: var(--font-size);\n  line-height: 1;\n  font-weight: normal;\n  font-style: normal;\n  text-align: left;\n  background-color: var(--background-color);\n  color: var(--text-color);\n  user-select: none;\n  -webkit-user-select: none;\n  touch-action: manipulation;\n  --background-color: #1f1f1f;\n  --text-color: #ebebeb;\n  --title-background-color: #111111;\n  --title-text-color: #ebebeb;\n  --widget-color: #424242;\n  --hover-color: #4f4f4f;\n  --focus-color: #595959;\n  --number-color: #2cc9ff;\n  --string-color: #a2db3c;\n  --font-size: 11px;\n  --input-font-size: 11px;\n  --font-family: -apple-system, BlinkMacSystemFont, "Lucida Grande", "Segoe UI", Roboto, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";\n  --font-family-mono: Menlo, Monaco, Consolas, "Droid Sans Mono", monospace, "Droid Sans Fallback";\n  --padding: 4px;\n  --spacing: 4px;\n  --widget-height: 20px;\n  --name-width: 45%;\n  --slider-knob-width: 2px;\n  --slider-input-width: 27%;\n  --color-input-width: 27%;\n  --slider-input-min-width: 45px;\n  --color-input-min-width: 45px;\n  --folder-indent: 7px;\n  --widget-padding: 0 0 0 3px;\n  --widget-border-radius: 2px;\n  --checkbox-size: calc(0.75 * var(--widget-height));\n  --scrollbar-width: 5px;\n}\n.lil-gui, .lil-gui * {\n  box-sizing: border-box;\n  margin: 0;\n}\n.lil-gui.root {\n  width: var(--width, 245px);\n  display: flex;\n  flex-direction: column;\n}\n.lil-gui.root > .title {\n  background: var(--title-background-color);\n  color: var(--title-text-color);\n}\n.lil-gui.root > .children {\n  overflow: auto;\n}\n.lil-gui.root > .children::-webkit-scrollbar {\n  width: var(--scrollbar-width);\n  height: var(--scrollbar-width);\n  background: var(--background-color);\n}\n.lil-gui.root > .children::-webkit-scrollbar-thumb {\n  border-radius: var(--scrollbar-width);\n  background: var(--focus-color);\n}\n.lil-gui .lil-gui {\n  --background-color: inherit;\n  --text-color: inherit;\n  --title-background-color: inherit;\n  --title-text-color: inherit;\n  --widget-color: inherit;\n  --hover-color: inherit;\n  --focus-color: inherit;\n  --number-color: inherit;\n  --string-color: inherit;\n  --font-size: inherit;\n  --input-font-size: inherit;\n  --font-family: inherit;\n  --font-family-mono: inherit;\n  --padding: inherit;\n  --spacing: inherit;\n  --widget-height: inherit;\n  --name-width: inherit;\n  --slider-knob-width: inherit;\n  --slider-input-width: inherit;\n  --color-input-width: inherit;\n  --slider-input-min-width: inherit;\n  --color-input-min-width: inherit;\n  --folder-indent: inherit;\n  --widget-padding: inherit;\n  --widget-border-radius: inherit;\n  --checkbox-size: inherit;\n}\n@media (pointer: coarse) {\n  .lil-gui.allow-touch-styles {\n    --widget-height: 28px;\n    --padding: 6px;\n    --spacing: 6px;\n    --font-size: 13px;\n    --input-font-size: 16px;\n    --folder-indent: 10px;\n    --widget-padding: 0 0 0 3px;\n    --scrollbar-width: 7px;\n    --slider-input-min-width: 50px;\n    --color-input-min-width: 65px;\n  }\n}\n.lil-gui.force-touch-styles {\n  --widget-height: 28px;\n  --padding: 6px;\n  --spacing: 6px;\n  --font-size: 13px;\n  --input-font-size: 16px;\n  --folder-indent: 10px;\n  --widget-padding: 0 0 0 3px;\n  --scrollbar-width: 7px;\n  --slider-input-min-width: 50px;\n  --color-input-min-width: 65px;\n}\n.lil-gui.autoPlace {\n  max-height: 100%;\n  position: fixed;\n  top: 0;\n  right: 15px;\n  z-index: 1001;\n}\n\n.lil-gui .controller {\n  display: flex;\n  align-items: center;\n  padding: 0 var(--padding);\n  margin: var(--spacing) 0;\n}\n.lil-gui .controller.disabled {\n  opacity: 0.5;\n}\n.lil-gui .controller.disabled, .lil-gui .controller.disabled * {\n  pointer-events: none !important;\n}\n.lil-gui .controller .name {\n  min-width: var(--name-width);\n  flex-shrink: 0;\n  white-space: pre;\n  padding-right: var(--spacing);\n  line-height: var(--widget-height);\n}\n.lil-gui .controller .widget {\n  position: relative;\n  display: flex;\n  align-items: center;\n  width: 100%;\n  min-height: var(--widget-height);\n}\n.lil-gui .controller.function .name {\n  line-height: unset;\n  padding: 0;\n}\n.lil-gui .controller.string input {\n  color: var(--string-color);\n}\n.lil-gui .controller.boolean .widget {\n  cursor: pointer;\n}\n.lil-gui .controller.color .display {\n  width: 100%;\n  height: var(--widget-height);\n  border-radius: var(--widget-border-radius);\n  position: relative;\n}\n@media (hover: hover) {\n  .lil-gui .controller.color .display:hover:before {\n    content: " ";\n    display: block;\n    position: absolute;\n    border-radius: var(--widget-border-radius);\n    border: 1px solid #fff9;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n  }\n}\n.lil-gui .controller.color input[type=color] {\n  opacity: 0;\n  width: 100%;\n  height: 100%;\n  cursor: pointer;\n}\n.lil-gui .controller.color input[type=text] {\n  margin-left: var(--spacing);\n  font-family: var(--font-family-mono);\n  min-width: var(--color-input-min-width);\n  width: var(--color-input-width);\n  flex-shrink: 0;\n}\n.lil-gui .controller.option select {\n  opacity: 0;\n  position: absolute;\n  width: 100%;\n  max-width: 100%;\n}\n.lil-gui .controller.option .display {\n  position: relative;\n  pointer-events: none;\n  border-radius: var(--widget-border-radius);\n  height: var(--widget-height);\n  line-height: var(--widget-height);\n  max-width: 100%;\n  overflow: hidden;\n  word-break: break-all;\n  padding-left: 0.55em;\n  padding-right: 1.75em;\n  background: var(--widget-color);\n}\n@media (hover: hover) {\n  .lil-gui .controller.option .display.focus {\n    background: var(--focus-color);\n  }\n}\n.lil-gui .controller.option .display.active {\n  background: var(--focus-color);\n}\n.lil-gui .controller.option .display:after {\n  font-family: "lil-gui";\n  content: "↕";\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  padding-right: 0.375em;\n}\n.lil-gui .controller.option .widget,\n.lil-gui .controller.option select {\n  cursor: pointer;\n}\n@media (hover: hover) {\n  .lil-gui .controller.option .widget:hover .display {\n    background: var(--hover-color);\n  }\n}\n.lil-gui .controller.number input {\n  color: var(--number-color);\n}\n.lil-gui .controller.number.hasSlider input {\n  margin-left: var(--spacing);\n  width: var(--slider-input-width);\n  min-width: var(--slider-input-min-width);\n  flex-shrink: 0;\n}\n.lil-gui .controller.number .slider {\n  width: 100%;\n  height: var(--widget-height);\n  background-color: var(--widget-color);\n  border-radius: var(--widget-border-radius);\n  padding-right: var(--slider-knob-width);\n  overflow: hidden;\n  cursor: ew-resize;\n  touch-action: pan-y;\n}\n@media (hover: hover) {\n  .lil-gui .controller.number .slider:hover {\n    background-color: var(--hover-color);\n  }\n}\n.lil-gui .controller.number .slider.active {\n  background-color: var(--focus-color);\n}\n.lil-gui .controller.number .slider.active .fill {\n  opacity: 0.95;\n}\n.lil-gui .controller.number .fill {\n  height: 100%;\n  border-right: var(--slider-knob-width) solid var(--number-color);\n  box-sizing: content-box;\n}\n\n.lil-gui-slider-active .lil-gui {\n  --hover-color: var(--widget-color);\n}\n.lil-gui-slider-active * {\n  cursor: ew-resize !important;\n}\n\n.lil-gui .title {\n  --title-height: calc(var(--widget-height) + var(--spacing) * 1.25);\n  height: var(--title-height);\n  line-height: calc(var(--title-height) - 4px);\n  font-weight: 600;\n  padding: 0 var(--padding);\n  -webkit-tap-highlight-color: transparent;\n  cursor: pointer;\n  outline: none;\n  text-decoration-skip: objects;\n}\n.lil-gui .title:before {\n  font-family: "lil-gui";\n  content: "▾";\n  padding-right: 2px;\n  display: inline-block;\n}\n.lil-gui .title:active {\n  background: var(--title-background-color);\n  opacity: 0.75;\n}\n@media (hover: hover) {\n  .lil-gui .title:hover {\n    background: var(--title-background-color);\n    opacity: 0.85;\n  }\n  .lil-gui .title:focus {\n    text-decoration: underline var(--focus-color);\n  }\n}\n.lil-gui.root > .title:focus {\n  text-decoration: none !important;\n}\n.lil-gui.closed > .title:before {\n  content: "▸";\n}\n.lil-gui.closed > .children {\n  transform: translateY(-7px);\n  opacity: 0;\n}\n.lil-gui.closed:not(.transition) > .children {\n  display: none;\n}\n.lil-gui.transition > .children {\n  transition-duration: 300ms;\n  transition-property: height, opacity, transform;\n  transition-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);\n  overflow: hidden;\n  pointer-events: none;\n}\n.lil-gui .children:empty:before {\n  content: "Empty";\n  padding: 0 var(--padding);\n  margin: var(--spacing) 0;\n  display: block;\n  height: var(--widget-height);\n  font-style: italic;\n  line-height: var(--widget-height);\n  opacity: 0.5;\n}\n.lil-gui.root > .children > .lil-gui > .title {\n  border: 0 solid var(--widget-color);\n  border-width: 1px 0;\n  transition: border-color 300ms;\n}\n.lil-gui.root > .children > .lil-gui.closed > .title {\n  border-bottom-color: transparent;\n}\n.lil-gui + .controller {\n  border-top: 1px solid var(--widget-color);\n  margin-top: 0;\n  padding-top: var(--spacing);\n}\n.lil-gui .lil-gui .lil-gui > .title {\n  border: none;\n}\n.lil-gui .lil-gui .lil-gui > .children {\n  border: none;\n  margin-left: var(--folder-indent);\n  border-left: 2px solid var(--widget-color);\n}\n.lil-gui .lil-gui .controller {\n  border: none;\n}\n\n.lil-gui input {\n  -webkit-tap-highlight-color: transparent;\n  border: 0;\n  outline: none;\n  font-family: var(--font-family);\n  font-size: var(--input-font-size);\n  border-radius: var(--widget-border-radius);\n  height: var(--widget-height);\n  background: var(--widget-color);\n  color: var(--text-color);\n  width: 100%;\n}\n@media (hover: hover) {\n  .lil-gui input:hover {\n    background: var(--hover-color);\n  }\n  .lil-gui input:active {\n    background: var(--focus-color);\n  }\n}\n.lil-gui input[type=text] {\n  padding: var(--widget-padding);\n}\n.lil-gui input[type=text]:focus {\n  background: var(--focus-color);\n}\n.lil-gui input[type=checkbox] {\n  appearance: none;\n  -webkit-appearance: none;\n  height: var(--checkbox-size);\n  width: var(--checkbox-size);\n  border-radius: var(--widget-border-radius);\n  text-align: center;\n}\n.lil-gui input[type=checkbox]:checked:before {\n  font-family: "lil-gui";\n  content: "✓";\n  font-size: var(--checkbox-size);\n  line-height: var(--checkbox-size);\n}\n@media (hover: hover) {\n  .lil-gui input[type=checkbox]:focus {\n    box-shadow: inset 0 0 0 1px var(--focus-color);\n  }\n}\n.lil-gui button {\n  -webkit-tap-highlight-color: transparent;\n  outline: none;\n  cursor: pointer;\n  font-family: var(--font-family);\n  font-size: var(--font-size);\n  color: var(--text-color);\n  width: 100%;\n  height: var(--widget-height);\n  text-transform: none;\n  background: var(--widget-color);\n  border-radius: var(--widget-border-radius);\n  border: 1px solid var(--widget-color);\n  text-align: center;\n  line-height: calc(var(--widget-height) * 0.725);\n}\n@media (hover: hover) {\n  .lil-gui button:hover {\n    background: var(--hover-color);\n    border-color: var(--hover-color);\n  }\n  .lil-gui button:focus {\n    border-color: var(--focus-color);\n  }\n}\n.lil-gui button:active {\n  background: var(--focus-color);\n}\n\n@font-face {\n  font-family: "lil-gui";\n  src: url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZ5WI2hlYWQAAAMcAAAAJwAAADZfcj23aGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhjAGJgZWBgZ7RnFRdnVJELCRlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB76woyAHicY2BkYGAA4sklsQ/j+W2+MnAzpDBgAyEMYUCSg4EJxAEAvVwFCgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==") format("woff");\n}';
                  const n = document.querySelector(
                    "head link[rel=stylesheet], head style"
                  );
                  n
                    ? document.head.insertBefore(e, n)
                    : document.head.appendChild(e);
                })(),
                (Zc = !0)),
              s
                ? s.appendChild(this.domElement)
                : e &&
                  (this.domElement.classList.add("autoPlace"),
                  document.body.appendChild(this.domElement)),
              n && this.domElement.classList.add("allow-touch-styles"),
              o && this.domElement.style.setProperty("--width", o + "px");
          }
          add(t, e, n, s, i) {
            if (Object(n) === n) return new Yc(this, t, e, n);
            const r = t[e];
            switch (typeof r) {
              case "number":
                return new qc(this, t, e, n, s, i);
              case "boolean":
                return new zc(this, t, e);
              case "string":
                return new Jc(this, t, e);
              case "function":
                return new Xc(this, t, e);
            }
            console.error(`Failed to add controller for "${e}"`, r, t);
          }
          addColor(t, e, n = 1) {
            return new jc(this, t, e, n);
          }
          addFolder(t) {
            return new $c({ parent: this, title: t });
          }
          load(t, e = !0) {
            if (!("controllers" in t))
              throw new Error(
                'Invalid load object. Should contain a "controllers" key.'
              );
            return (
              this.controllers.forEach((e) => {
                e instanceof Xc ||
                  (e._name in t.controllers && e.load(t.controllers[e._name]));
              }),
              e &&
                t.folders &&
                this.folders.forEach((e) => {
                  e._title in t.folders && e.load(t.folders[e._title]);
                }),
              this
            );
          }
          save(t = !0) {
            const e = { controllers: {}, folders: {} };
            return (
              this.controllers.forEach((t) => {
                if (!(t instanceof Xc)) {
                  if (t._name in e.controllers)
                    throw new Error(
                      `Cannot save GUI with duplicate property "${t._name}"`
                    );
                  e.controllers[t._name] = t.save();
                }
              }),
              t &&
                this.folders.forEach((t) => {
                  if (t._title in e.folders)
                    throw new Error(
                      `Cannot save GUI with duplicate folder "${t._title}"`
                    );
                  e.folders[t._title] = t.save();
                }),
              e
            );
          }
          open(t = !0) {
            return (
              (this._closed = !t),
              this.$title.setAttribute("aria-expanded", !this._closed),
              this.domElement.classList.toggle("closed", this._closed),
              this
            );
          }
          close() {
            return this.open(!1);
          }
          openAnimated(t = !0) {
            return (
              (this._closed = !t),
              this.$title.setAttribute("aria-expanded", !this._closed),
              requestAnimationFrame(() => {
                const e = this.$children.clientHeight;
                (this.$children.style.height = e + "px"),
                  this.domElement.classList.add("transition");
                const n = (t) => {
                  t.target === this.$children &&
                    ((this.$children.style.height = ""),
                    this.domElement.classList.remove("transition"),
                    this.$children.removeEventListener("transitionend", n));
                };
                this.$children.addEventListener("transitionend", n);
                const s = t ? this.$children.scrollHeight : 0;
                this.domElement.classList.toggle("closed", !t),
                  requestAnimationFrame(() => {
                    this.$children.style.height = s + "px";
                  });
              }),
              this
            );
          }
          title(t) {
            return (this._title = t), (this.$title.innerHTML = t), this;
          }
          reset(t = !0) {
            return (
              (t ? this.controllersRecursive() : this.controllers).forEach(
                (t) => t.reset()
              ),
              this
            );
          }
          onChange(t) {
            return (this._onChange = t), this;
          }
          _callOnChange(t) {
            this.parent && this.parent._callOnChange(t),
              void 0 !== this._onChange &&
                this._onChange.call(this, {
                  object: t.object,
                  property: t.property,
                  value: t.getValue(),
                  controller: t,
                });
          }
          destroy() {
            this.parent &&
              (this.parent.children.splice(
                this.parent.children.indexOf(this),
                1
              ),
              this.parent.folders.splice(this.parent.folders.indexOf(this), 1)),
              this.domElement.parentElement &&
                this.domElement.parentElement.removeChild(this.domElement),
              Array.from(this.children).forEach((t) => t.destroy()),
              this._onResize &&
                window.removeEventListener("resize", this._onResize);
          }
          controllersRecursive() {
            let t = Array.from(this.controllers);
            return (
              this.folders.forEach((e) => {
                t = t.concat(e.controllersRecursive());
              }),
              t
            );
          }
          foldersRecursive() {
            let t = Array.from(this.folders);
            return (
              this.folders.forEach((e) => {
                t = t.concat(e.foldersRecursive());
              }),
              t
            );
          }
        }
        class Kc {
          constructor() {
            (this.active = "#debug" === window.location.hash),
              this.active && (this.ui = new $c());
          }
        }
        class Qc {
          constructor() {
            (this.callbacks = {}), (this.callbacks.base = {});
          }
          on(t, e) {
            return void 0 === t || "" === t
              ? (console.warn("wrong names"), !1)
              : void 0 === e
              ? (console.warn("wrong callback"), !1)
              : (this.resolveNames(t).forEach((t) => {
                  const n = this.resolveName(t);
                  this.callbacks[n.namespace] instanceof Object ||
                    (this.callbacks[n.namespace] = {}),
                    this.callbacks[n.namespace][n.value] instanceof Array ||
                      (this.callbacks[n.namespace][n.value] = []),
                    this.callbacks[n.namespace][n.value].push(e);
                }),
                this);
          }
          off(t) {
            return void 0 === t || "" === t
              ? (console.warn("wrong name"), !1)
              : (this.resolveNames(t).forEach((t) => {
                  const e = this.resolveName(t);
                  if ("base" !== e.namespace && "" === e.value)
                    delete this.callbacks[e.namespace];
                  else if ("base" === e.namespace)
                    for (const t in this.callbacks)
                      this.callbacks[t] instanceof Object &&
                        this.callbacks[t][e.value] instanceof Array &&
                        (delete this.callbacks[t][e.value],
                        0 === Object.keys(this.callbacks[t]).length &&
                          delete this.callbacks[t]);
                  else
                    this.callbacks[e.namespace] instanceof Object &&
                      this.callbacks[e.namespace][e.value] instanceof Array &&
                      (delete this.callbacks[e.namespace][e.value],
                      0 === Object.keys(this.callbacks[e.namespace]).length &&
                        delete this.callbacks[e.namespace]);
                }),
                this);
          }
          trigger(t, e) {
            if (void 0 === t || "" === t) return console.warn("wrong name"), !1;
            let n = null,
              s = null;
            const i = e instanceof Array ? e : [];
            let r = this.resolveNames(t);
            if (((r = this.resolveName(r[0])), "base" === r.namespace))
              for (const t in this.callbacks)
                this.callbacks[t] instanceof Object &&
                  this.callbacks[t][r.value] instanceof Array &&
                  this.callbacks[t][r.value].forEach(function (t) {
                    (s = t.apply(this, i)), void 0 === n && (n = s);
                  });
            else if (this.callbacks[r.namespace] instanceof Object) {
              if ("" === r.value) return console.warn("wrong name"), this;
              this.callbacks[r.namespace][r.value].forEach(function (t) {
                (s = t.apply(this, i)), void 0 === n && (n = s);
              });
            }
            return n;
          }
          resolveNames(t) {
            let e = t;
            return (
              (e = e.replace(/[^a-zA-Z0-9 ,/.]/g, "")),
              (e = e.replace(/[,/]+/g, " ")),
              (e = e.split(" ")),
              e
            );
          }
          resolveName(t) {
            const e = {},
              n = t.split(".");
            return (
              (e.original = t),
              (e.value = n[0]),
              (e.namespace = "base"),
              n.length > 1 && "" !== n[1] && (e.namespace = n[1]),
              e
            );
          }
        }
        class tu extends Qc {
          constructor() {
            super(),
              (this.width = window.innerWidth),
              (this.height = window.innerHeight),
              (this.pixelRatio = Math.min(window.devicePixelRatio, 2)),
              window.addEventListener("resize", () => {
                (this.width = window.innerWidth),
                  (this.height = window.innerHeight),
                  (this.pixelRatio = Math.min(window.devicePixelRatio, 2)),
                  this.trigger("resize");
              });
          }
        }
        class eu extends Qc {
          constructor() {
            super(),
              (this.start = Date.now()),
              (this.current = this.start),
              (this.elapsed = 0),
              (this.delta = 16),
              window.requestAnimationFrame(() => {
                this.tick();
              });
          }
          tick() {
            const t = Date.now();
            (this.delta = t - this.current),
              (this.current = t),
              (this.elapsed = this.current - this.start),
              this.trigger("tick"),
              window.requestAnimationFrame(() => {
                this.tick();
              });
          }
        }
        const nu = { type: "change" },
          su = { type: "start" },
          iu = { type: "end" };
        class ru extends F {
          constructor(t, e) {
            super(),
              void 0 === e &&
                console.warn(
                  'THREE.OrbitControls: The second parameter "domElement" is now mandatory.'
                ),
              e === document &&
                console.error(
                  'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
                ),
              (this.object = t),
              (this.domElement = e),
              (this.domElement.style.touchAction = "none"),
              (this.enabled = !0),
              (this.target = new ft()),
              (this.minDistance = 0),
              (this.maxDistance = 1 / 0),
              (this.minZoom = 0),
              (this.maxZoom = 1 / 0),
              (this.minPolarAngle = 0),
              (this.maxPolarAngle = Math.PI),
              (this.minAzimuthAngle = -1 / 0),
              (this.maxAzimuthAngle = 1 / 0),
              (this.enableDamping = !1),
              (this.dampingFactor = 0.05),
              (this.enableZoom = !0),
              (this.zoomSpeed = 1),
              (this.enableRotate = !0),
              (this.rotateSpeed = 1),
              (this.enablePan = !0),
              (this.panSpeed = 1),
              (this.screenSpacePanning = !0),
              (this.keyPanSpeed = 7),
              (this.autoRotate = !1),
              (this.autoRotateSpeed = 2),
              (this.keys = {
                LEFT: "ArrowLeft",
                UP: "ArrowUp",
                RIGHT: "ArrowRight",
                BOTTOM: "ArrowDown",
              }),
              (this.mouseButtons = { LEFT: 0, MIDDLE: 1, RIGHT: 2 }),
              (this.touches = { ONE: 0, TWO: 2 }),
              (this.target0 = this.target.clone()),
              (this.position0 = this.object.position.clone()),
              (this.zoom0 = this.object.zoom),
              (this._domElementKeyEvents = null),
              (this.getPolarAngle = function () {
                return o.phi;
              }),
              (this.getAzimuthalAngle = function () {
                return o.theta;
              }),
              (this.getDistance = function () {
                return this.object.position.distanceTo(this.target);
              }),
              (this.listenToKeyEvents = function (t) {
                t.addEventListener("keydown", V),
                  (this._domElementKeyEvents = t);
              }),
              (this.saveState = function () {
                n.target0.copy(n.target),
                  n.position0.copy(n.object.position),
                  (n.zoom0 = n.object.zoom);
              }),
              (this.reset = function () {
                n.target.copy(n.target0),
                  n.object.position.copy(n.position0),
                  (n.object.zoom = n.zoom0),
                  n.object.updateProjectionMatrix(),
                  n.dispatchEvent(nu),
                  n.update(),
                  (i = s.NONE);
              }),
              (this.update = (function () {
                const e = new ft(),
                  l = new ht().setFromUnitVectors(t.up, new ft(0, 1, 0)),
                  h = l.clone().invert(),
                  f = new ft(),
                  m = new ht(),
                  p = 2 * Math.PI;
                return function () {
                  const t = n.object.position;
                  e.copy(t).sub(n.target),
                    e.applyQuaternion(l),
                    o.setFromVector3(e),
                    n.autoRotate &&
                      i === s.NONE &&
                      M(((2 * Math.PI) / 60 / 60) * n.autoRotateSpeed),
                    n.enableDamping
                      ? ((o.theta += a.theta * n.dampingFactor),
                        (o.phi += a.phi * n.dampingFactor))
                      : ((o.theta += a.theta), (o.phi += a.phi));
                  let g = n.minAzimuthAngle,
                    x = n.maxAzimuthAngle;
                  return (
                    isFinite(g) &&
                      isFinite(x) &&
                      (g < -Math.PI ? (g += p) : g > Math.PI && (g -= p),
                      x < -Math.PI ? (x += p) : x > Math.PI && (x -= p),
                      (o.theta =
                        g <= x
                          ? Math.max(g, Math.min(x, o.theta))
                          : o.theta > (g + x) / 2
                          ? Math.max(g, o.theta)
                          : Math.min(x, o.theta))),
                    (o.phi = Math.max(
                      n.minPolarAngle,
                      Math.min(n.maxPolarAngle, o.phi)
                    )),
                    o.makeSafe(),
                    (o.radius *= c),
                    (o.radius = Math.max(
                      n.minDistance,
                      Math.min(n.maxDistance, o.radius)
                    )),
                    !0 === n.enableDamping
                      ? n.target.addScaledVector(u, n.dampingFactor)
                      : n.target.add(u),
                    e.setFromSpherical(o),
                    e.applyQuaternion(h),
                    t.copy(n.target).add(e),
                    n.object.lookAt(n.target),
                    !0 === n.enableDamping
                      ? ((a.theta *= 1 - n.dampingFactor),
                        (a.phi *= 1 - n.dampingFactor),
                        u.multiplyScalar(1 - n.dampingFactor))
                      : (a.set(0, 0, 0), u.set(0, 0, 0)),
                    (c = 1),
                    !!(
                      d ||
                      f.distanceToSquared(n.object.position) > r ||
                      8 * (1 - m.dot(n.object.quaternion)) > r
                    ) &&
                      (n.dispatchEvent(nu),
                      f.copy(n.object.position),
                      m.copy(n.object.quaternion),
                      (d = !1),
                      !0)
                  );
                };
              })()),
              (this.dispose = function () {
                n.domElement.removeEventListener("contextmenu", W),
                  n.domElement.removeEventListener("pointerdown", z),
                  n.domElement.removeEventListener("pointercancel", H),
                  n.domElement.removeEventListener("wheel", G),
                  n.domElement.removeEventListener("pointermove", F),
                  n.domElement.removeEventListener("pointerup", B),
                  null !== n._domElementKeyEvents &&
                    n._domElementKeyEvents.removeEventListener("keydown", V);
              });
            const n = this,
              s = {
                NONE: -1,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2,
                TOUCH_ROTATE: 3,
                TOUCH_PAN: 4,
                TOUCH_DOLLY_PAN: 5,
                TOUCH_DOLLY_ROTATE: 6,
              };
            let i = s.NONE;
            const r = 1e-6,
              o = new Lc(),
              a = new Lc();
            let c = 1;
            const u = new ft();
            let d = !1;
            const l = new Q(),
              h = new Q(),
              f = new Q(),
              m = new Q(),
              p = new Q(),
              g = new Q(),
              x = new Q(),
              v = new Q(),
              y = new Q(),
              w = [],
              _ = {};
            function b() {
              return Math.pow(0.95, n.zoomSpeed);
            }
            function M(t) {
              a.theta -= t;
            }
            function S(t) {
              a.phi -= t;
            }
            const T = (function () {
                const t = new ft();
                return function (e, n) {
                  t.setFromMatrixColumn(n, 0), t.multiplyScalar(-e), u.add(t);
                };
              })(),
              E = (function () {
                const t = new ft();
                return function (e, s) {
                  !0 === n.screenSpacePanning
                    ? t.setFromMatrixColumn(s, 1)
                    : (t.setFromMatrixColumn(s, 0),
                      t.crossVectors(n.object.up, t)),
                    t.multiplyScalar(e),
                    u.add(t);
                };
              })(),
              C = (function () {
                const t = new ft();
                return function (e, s) {
                  const i = n.domElement;
                  if (n.object.isPerspectiveCamera) {
                    const r = n.object.position;
                    t.copy(r).sub(n.target);
                    let o = t.length();
                    (o *= Math.tan(((n.object.fov / 2) * Math.PI) / 180)),
                      T((2 * e * o) / i.clientHeight, n.object.matrix),
                      E((2 * s * o) / i.clientHeight, n.object.matrix);
                  } else
                    n.object.isOrthographicCamera
                      ? (T(
                          (e * (n.object.right - n.object.left)) /
                            n.object.zoom /
                            i.clientWidth,
                          n.object.matrix
                        ),
                        E(
                          (s * (n.object.top - n.object.bottom)) /
                            n.object.zoom /
                            i.clientHeight,
                          n.object.matrix
                        ))
                      : (console.warn(
                          "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                        ),
                        (n.enablePan = !1));
                };
              })();
            function A(t) {
              n.object.isPerspectiveCamera
                ? (c /= t)
                : n.object.isOrthographicCamera
                ? ((n.object.zoom = Math.max(
                    n.minZoom,
                    Math.min(n.maxZoom, n.object.zoom * t)
                  )),
                  n.object.updateProjectionMatrix(),
                  (d = !0))
                : (console.warn(
                    "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
                  ),
                  (n.enableZoom = !1));
            }
            function L(t) {
              n.object.isPerspectiveCamera
                ? (c *= t)
                : n.object.isOrthographicCamera
                ? ((n.object.zoom = Math.max(
                    n.minZoom,
                    Math.min(n.maxZoom, n.object.zoom / t)
                  )),
                  n.object.updateProjectionMatrix(),
                  (d = !0))
                : (console.warn(
                    "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
                  ),
                  (n.enableZoom = !1));
            }
            function R(t) {
              l.set(t.clientX, t.clientY);
            }
            function P(t) {
              m.set(t.clientX, t.clientY);
            }
            function I() {
              if (1 === w.length) l.set(w[0].pageX, w[0].pageY);
              else {
                const t = 0.5 * (w[0].pageX + w[1].pageX),
                  e = 0.5 * (w[0].pageY + w[1].pageY);
                l.set(t, e);
              }
            }
            function D() {
              if (1 === w.length) m.set(w[0].pageX, w[0].pageY);
              else {
                const t = 0.5 * (w[0].pageX + w[1].pageX),
                  e = 0.5 * (w[0].pageY + w[1].pageY);
                m.set(t, e);
              }
            }
            function N() {
              const t = w[0].pageX - w[1].pageX,
                e = w[0].pageY - w[1].pageY,
                n = Math.sqrt(t * t + e * e);
              x.set(0, n);
            }
            function O(t) {
              if (1 == w.length) h.set(t.pageX, t.pageY);
              else {
                const e = q(t),
                  n = 0.5 * (t.pageX + e.x),
                  s = 0.5 * (t.pageY + e.y);
                h.set(n, s);
              }
              f.subVectors(h, l).multiplyScalar(n.rotateSpeed);
              const e = n.domElement;
              M((2 * Math.PI * f.x) / e.clientHeight),
                S((2 * Math.PI * f.y) / e.clientHeight),
                l.copy(h);
            }
            function k(t) {
              if (1 === w.length) p.set(t.pageX, t.pageY);
              else {
                const e = q(t),
                  n = 0.5 * (t.pageX + e.x),
                  s = 0.5 * (t.pageY + e.y);
                p.set(n, s);
              }
              g.subVectors(p, m).multiplyScalar(n.panSpeed),
                C(g.x, g.y),
                m.copy(p);
            }
            function U(t) {
              const e = q(t),
                s = t.pageX - e.x,
                i = t.pageY - e.y,
                r = Math.sqrt(s * s + i * i);
              v.set(0, r),
                y.set(0, Math.pow(v.y / x.y, n.zoomSpeed)),
                A(y.y),
                x.copy(v);
            }
            function z(t) {
              !1 !== n.enabled &&
                (0 === w.length &&
                  (n.domElement.setPointerCapture(t.pointerId),
                  n.domElement.addEventListener("pointermove", F),
                  n.domElement.addEventListener("pointerup", B)),
                (function (t) {
                  w.push(t);
                })(t),
                "touch" === t.pointerType
                  ? (function (t) {
                      switch ((X(t), w.length)) {
                        case 1:
                          switch (n.touches.ONE) {
                            case 0:
                              if (!1 === n.enableRotate) return;
                              I(), (i = s.TOUCH_ROTATE);
                              break;
                            case 1:
                              if (!1 === n.enablePan) return;
                              D(), (i = s.TOUCH_PAN);
                              break;
                            default:
                              i = s.NONE;
                          }
                          break;
                        case 2:
                          switch (n.touches.TWO) {
                            case 2:
                              if (!1 === n.enableZoom && !1 === n.enablePan)
                                return;
                              n.enableZoom && N(),
                                n.enablePan && D(),
                                (i = s.TOUCH_DOLLY_PAN);
                              break;
                            case 3:
                              if (!1 === n.enableZoom && !1 === n.enableRotate)
                                return;
                              n.enableZoom && N(),
                                n.enableRotate && I(),
                                (i = s.TOUCH_DOLLY_ROTATE);
                              break;
                            default:
                              i = s.NONE;
                          }
                          break;
                        default:
                          i = s.NONE;
                      }
                      i !== s.NONE && n.dispatchEvent(su);
                    })(t)
                  : (function (t) {
                      let e;
                      switch (t.button) {
                        case 0:
                          e = n.mouseButtons.LEFT;
                          break;
                        case 1:
                          e = n.mouseButtons.MIDDLE;
                          break;
                        case 2:
                          e = n.mouseButtons.RIGHT;
                          break;
                        default:
                          e = -1;
                      }
                      switch (e) {
                        case 1:
                          if (!1 === n.enableZoom) return;
                          !(function (t) {
                            x.set(t.clientX, t.clientY);
                          })(t),
                            (i = s.DOLLY);
                          break;
                        case 0:
                          if (t.ctrlKey || t.metaKey || t.shiftKey) {
                            if (!1 === n.enablePan) return;
                            P(t), (i = s.PAN);
                          } else {
                            if (!1 === n.enableRotate) return;
                            R(t), (i = s.ROTATE);
                          }
                          break;
                        case 2:
                          if (t.ctrlKey || t.metaKey || t.shiftKey) {
                            if (!1 === n.enableRotate) return;
                            R(t), (i = s.ROTATE);
                          } else {
                            if (!1 === n.enablePan) return;
                            P(t), (i = s.PAN);
                          }
                          break;
                        default:
                          i = s.NONE;
                      }
                      i !== s.NONE && n.dispatchEvent(su);
                    })(t));
            }
            function F(t) {
              !1 !== n.enabled &&
                ("touch" === t.pointerType
                  ? (function (t) {
                      switch ((X(t), i)) {
                        case s.TOUCH_ROTATE:
                          if (!1 === n.enableRotate) return;
                          O(t), n.update();
                          break;
                        case s.TOUCH_PAN:
                          if (!1 === n.enablePan) return;
                          k(t), n.update();
                          break;
                        case s.TOUCH_DOLLY_PAN:
                          if (!1 === n.enableZoom && !1 === n.enablePan) return;
                          !(function (t) {
                            n.enableZoom && U(t), n.enablePan && k(t);
                          })(t),
                            n.update();
                          break;
                        case s.TOUCH_DOLLY_ROTATE:
                          if (!1 === n.enableZoom && !1 === n.enableRotate)
                            return;
                          !(function (t) {
                            n.enableZoom && U(t), n.enableRotate && O(t);
                          })(t),
                            n.update();
                          break;
                        default:
                          i = s.NONE;
                      }
                    })(t)
                  : (function (t) {
                      if (!1 !== n.enabled)
                        switch (i) {
                          case s.ROTATE:
                            if (!1 === n.enableRotate) return;
                            !(function (t) {
                              h.set(t.clientX, t.clientY),
                                f
                                  .subVectors(h, l)
                                  .multiplyScalar(n.rotateSpeed);
                              const e = n.domElement;
                              M((2 * Math.PI * f.x) / e.clientHeight),
                                S((2 * Math.PI * f.y) / e.clientHeight),
                                l.copy(h),
                                n.update();
                            })(t);
                            break;
                          case s.DOLLY:
                            if (!1 === n.enableZoom) return;
                            !(function (t) {
                              v.set(t.clientX, t.clientY),
                                y.subVectors(v, x),
                                y.y > 0 ? A(b()) : y.y < 0 && L(b()),
                                x.copy(v),
                                n.update();
                            })(t);
                            break;
                          case s.PAN:
                            if (!1 === n.enablePan) return;
                            !(function (t) {
                              p.set(t.clientX, t.clientY),
                                g.subVectors(p, m).multiplyScalar(n.panSpeed),
                                C(g.x, g.y),
                                m.copy(p),
                                n.update();
                            })(t);
                        }
                    })(t));
            }
            function B(t) {
              !1 !== n.enabled &&
                (t.pointerType,
                n.dispatchEvent(iu),
                (i = s.NONE),
                j(t),
                0 === w.length &&
                  (n.domElement.releasePointerCapture(t.pointerId),
                  n.domElement.removeEventListener("pointermove", F),
                  n.domElement.removeEventListener("pointerup", B)));
            }
            function H(t) {
              j(t);
            }
            function G(t) {
              !1 !== n.enabled &&
                !1 !== n.enableZoom &&
                i === s.NONE &&
                (t.preventDefault(),
                n.dispatchEvent(su),
                (function (t) {
                  t.deltaY < 0 ? L(b()) : t.deltaY > 0 && A(b()), n.update();
                })(t),
                n.dispatchEvent(iu));
            }
            function V(t) {
              !1 !== n.enabled &&
                !1 !== n.enablePan &&
                (function (t) {
                  let e = !1;
                  switch (t.code) {
                    case n.keys.UP:
                      C(0, n.keyPanSpeed), (e = !0);
                      break;
                    case n.keys.BOTTOM:
                      C(0, -n.keyPanSpeed), (e = !0);
                      break;
                    case n.keys.LEFT:
                      C(n.keyPanSpeed, 0), (e = !0);
                      break;
                    case n.keys.RIGHT:
                      C(-n.keyPanSpeed, 0), (e = !0);
                  }
                  e && (t.preventDefault(), n.update());
                })(t);
            }
            function W(t) {
              !1 !== n.enabled && t.preventDefault();
            }
            function j(t) {
              delete _[t.pointerId];
              for (let e = 0; e < w.length; e++)
                if (w[e].pointerId == t.pointerId) return void w.splice(e, 1);
            }
            function X(t) {
              let e = _[t.pointerId];
              void 0 === e && ((e = new Q()), (_[t.pointerId] = e)),
                e.set(t.pageX, t.pageY);
            }
            function q(t) {
              const e = t.pointerId === w[0].pointerId ? w[1] : w[0];
              return _[e.pointerId];
            }
            n.domElement.addEventListener("contextmenu", W),
              n.domElement.addEventListener("pointerdown", z),
              n.domElement.addEventListener("pointercancel", H),
              n.domElement.addEventListener("wheel", G, { passive: !1 }),
              this.update();
          }
        }
        class ou {
          constructor() {
            (this.experience = new th()),
              (this.sizes = this.experience.sizes),
              (this.scene = this.experience.scene),
              (this.canvas = this.experience.canvas),
              (this.player = this.experience.player),
              this.setInstance(),
              this.setControls();
          }
          setInstance() {
            (this.instance = new Mn(
              70,
              this.sizes.width / this.sizes.height,
              0.01,
              2e4
            )),
              this.instance.position.set(0, 0, -26),
              this.scene.add(this.instance);
          }
          setControls() {
            (this.controls = new ru(this.instance, this.canvas)),
              (this.controls.enableDamping = !0);
          }
          resize() {
            (this.instance.aspect = this.sizes.width / this.sizes.height),
              this.instance.updateProjectionMatrix();
          }
          update() {
            this.controls.update(),
              this.experience.world.player &&
                (this.controls.target = this.experience.world.player.position),
              this.instance.rotateX(0.4),
              this.experience.cameraTempPos &&
                this.instance.position.lerp(this.experience.cameraTempPos, 0.2);
          }
        }
        class au {
          constructor() {
            (this.experience = new th()),
              (this.canvas = this.experience.canvas),
              (this.sizes = this.experience.sizes),
              (this.scene = this.experience.scene),
              (this.camera = this.experience.camera),
              this.setInstance();
          }
          setInstance() {
            (this.instance = new yr({ canvas: this.canvas, antialias: !0 })),
              (this.instance.physicallyCorrectLights = !0),
              (this.instance.outputEncoding = I),
              (this.instance.toneMapping = 3),
              (this.instance.toneMappingExposure = 1.75),
              (this.instance.shadowMap.enabled = !0),
              (this.instance.shadowMap.type = 2),
              this.instance.setClearColor("#211d20"),
              this.instance.setSize(this.sizes.width, this.sizes.height),
              this.instance.setPixelRatio(Math.min(this.sizes.pixelRatio, 2));
          }
          resize() {
            this.instance.setSize(this.sizes.width, this.sizes.height),
              this.instance.setPixelRatio(Math.min(this.sizes.pixelRatio, 2));
          }
          update() {
            this.instance.render(this.scene, this.camera.instance);
          }
        }
        class cu {
          constructor() {
            (this.experience = new th()),
              (this.scene = this.experience.scene),
              (this.resources = this.experience.resources),
              (this.debug = this.experience.debug),
              this.debug.active &&
                (this.debugFolder = this.debug.ui.addFolder("environment")),
              this.setSunLight(),
              this.setEnvironmentMap();
          }
          setSunLight() {
            (this.sunLight = new rc("#ffffff", 4)),
              (this.sunLight.castShadow = !0),
              (this.sunLight.shadow.camera.far = 15),
              this.sunLight.shadow.mapSize.set(1024, 1024),
              (this.sunLight.shadow.normalBias = 0.05),
              this.sunLight.position.set(3.5, 2, -1.25),
              this.scene.add(this.sunLight),
              this.debug.active &&
                (this.debugFolder
                  .add(this.sunLight, "intensity")
                  .name("sunLightIntensity")
                  .min(0)
                  .max(10)
                  .step(0.001),
                this.debugFolder
                  .add(this.sunLight.position, "x")
                  .name("sunLightX")
                  .min(-5)
                  .max(5)
                  .step(0.001),
                this.debugFolder
                  .add(this.sunLight.position, "y")
                  .name("sunLightY")
                  .min(-5)
                  .max(5)
                  .step(0.001),
                this.debugFolder
                  .add(this.sunLight.position, "z")
                  .name("sunLightZ")
                  .min(-5)
                  .max(5)
                  .step(0.001));
          }
          setEnvironmentMap() {
            (this.environmentMap = {}),
              (this.environmentMap.intensity = 2.4),
              (this.environmentMap.texture =
                this.resources.items.environmentMapTexture),
              (this.environmentMap.texture.encoding = I),
              (this.scene.environment = this.environmentMap.texture),
              (this.environmentMap.updateMaterials = () => {
                this.scene.traverse((t) => {
                  t instanceof pn &&
                    t.material instanceof _a &&
                    ((t.material.envMap = this.environmentMap.texture),
                    (t.material.envMapIntensity =
                      this.environmentMap.intensity),
                    (t.material.needsUpdate = !0));
                });
              }),
              this.environmentMap.updateMaterials(),
              this.debug.active &&
                this.debugFolder
                  .add(this.environmentMap, "intensity")
                  .name("envMapIntensity")
                  .min(0)
                  .max(4)
                  .step(0.001)
                  .onChange(this.environmentMap.updateMaterials);
          }
        }
        class uu {
          constructor(t, e, n) {
            (this.experience = new th()),
              (this.run = !1),
              this.currentAction,
              (this.player = t),
              (this.currentAction = n),
              (this.time = t.time),
              (this.animation = e),
              (this.animation.play = (t) => {
                const e = this.animation.actions[t],
                  n = this.animation.actions.current;
                typeof n == typeof e && n.fadeOut(0.5),
                  e !== n && (e.reset(), e.play()),
                  (this.animation.actions.current = e);
              }),
              (this.keysPressed = {});
          }
          walkDirection = new ft();
          rotateAngle = new ft(0, 1, 0);
          rotateQuarternion = new ht();
          fadeDuration = 0.2;
          runVelocity = 1;
          walkVelocity = 0.4;
          update() {
            const t = [37, 38, 39, 40].some((t) => 1 == this.keysPressed[t]);
            var e = "";
            e = t && this.run ? "Running" : t ? "Walking" : "Idle";
            this.player.time.delta;
            let n = this.directionOffset(this.keysPressed);
            t &&
              (this.rotateQuarternion.setFromAxisAngle(this.rotateAngle, n),
              this.player.model.quaternion.rotateTowards(
                this.rotateQuarternion,
                0.2
              )),
              (this.walkDirection.y = 0),
              this.walkDirection.normalize(),
              this.walkDirection.applyAxisAngle(this.rotateAngle, n);
            const s = this.keysPressed[16]
              ? this.runVelocity
              : this.walkVelocity;
            this.walkDirection.x,
              this.keysPressed[16] && (e = "Running"),
              this.experience.selectState && (e = "Punch"),
              this.keysPressed[38] && (this.player.position.z += s),
              this.keysPressed[40] && (this.player.position.z -= s),
              this.keysPressed[37] && (this.player.position.x += s),
              this.keysPressed[39] && (this.player.position.x -= s),
              this.animation.play(e),
              (this.animation.current = this.animation.actions[e]);
          }
          directionOffset(t) {
            var e = 0;
            return (
              t[38]
                ? t[37]
                  ? (e = Math.PI / 4)
                  : t[39] && (e = -Math.PI / 4)
                : t[40]
                ? (e = t[37]
                    ? Math.PI / 4 + Math.PI / 2
                    : t[39]
                    ? -Math.PI / 4 - Math.PI / 2
                    : Math.PI)
                : t[37]
                ? (e = Math.PI / 2)
                : t[39] && (e = -Math.PI / 2),
              e
            );
          }
        }
        var du = {
            d: (t, e) => {
              for (var n in e)
                du.o(e, n) &&
                  !du.o(t, n) &&
                  Object.defineProperty(t, n, { enumerable: !0, get: e[n] });
            },
            o: (t, e) => Object.prototype.hasOwnProperty.call(t, e),
            r: (t) => {
              "undefined" != typeof Symbol &&
                Symbol.toStringTag &&
                Object.defineProperty(t, Symbol.toStringTag, {
                  value: "Module",
                }),
                Object.defineProperty(t, "__esModule", { value: !0 });
            },
          },
          lu = {};
        du.d(lu, {
          g1: () => fu,
          gO: () => Id,
          km: () => hu,
          zV: () => yd,
          ol: () => Bd,
          uM: () => mu,
          N1: () => Jd,
          xv: () => Fd,
          PH: () => gu,
          UH: () => pu,
          ZP: () => Kd,
          Vx: () => Zd,
        });
        var hu = {};
        du.r(hu),
          du.d(hu, {
            COLUMN: () => wu,
            COLUMN_REVERSE: () => _u,
            ROW: () => vu,
            ROW_REVERSE: () => yu,
            contentDirection: () => Su,
          });
        var fu = {};
        du.r(fu),
          du.d(fu, {
            CENTER: () => Eu,
            END: () => Cu,
            START: () => Tu,
            STRETCH: () => Au,
            alignItems: () => Lu,
            warnAboutDeprecatedAlignItems: () => Ru,
          });
        var mu = {};
        du.r(mu),
          du.d(mu, {
            CENTER: () => Nu,
            END: () => Ou,
            SPACE_AROUND: () => ku,
            SPACE_BETWEEN: () => Uu,
            SPACE_EVENLY: () => zu,
            START: () => Du,
            justifyContent: () => Fu,
          });
        var pu = {};
        du.r(pu),
          du.d(pu, {
            NORMAL: () => Vu,
            NOWRAP: () => Wu,
            PRE: () => ju,
            PRE_LINE: () => Xu,
            PRE_WRAP: () => qu,
            WHITE_CHARS: () => Gu,
            collapseWhitespaceOnInlines: () => $u,
            collapseWhitespaceOnString: () => Yu,
            newlineBreakability: () => Ju,
            shouldBreak: () => Zu,
          });
        var gu = {};
        du.r(gu),
          du.d(gu, {
            CENTER: () => sd,
            JUSTIFY: () => id,
            JUSTIFY_CENTER: () => ad,
            JUSTIFY_LEFT: () => rd,
            JUSTIFY_RIGHT: () => od,
            LEFT: () => ed,
            RIGHT: () => nd,
            textAlign: () => cd,
          });
        const xu =
            ((bu = {
              BufferAttribute: () => Fe,
              BufferGeometry: () => Ze,
              CanvasTexture: () => bo,
              Color: () => Oe,
              FileLoader: () => Ga,
              LinearFilter: () => f,
              Mesh: () => pn,
              Object3D: () => pe,
              Plane: () => Pn,
              PlaneBufferGeometry: () => Un,
              PlaneGeometry: () => Un,
              ShaderMaterial: () => _n,
              TextureLoader: () => ja,
              Vector2: () => Q,
              Vector3: () => ft,
            }),
            (Mu = {}),
            du.d(Mu, bu),
            Mu),
          vu = "row",
          yu = "row-reverse",
          wu = "column",
          _u = "column-reverse";
        var bu, Mu;
        function Su(t, e, n, s) {
          let i = n,
            r = "getWidth",
            o = "x",
            a = "y";
          0 === e.indexOf(wu) && ((r = "getHeight"), (o = "y"), (a = "x"));
          for (let e = 0; e < t.childrenBoxes.length; e++) {
            const n = t.childrenBoxes[e],
              c = n.id,
              u = n[r](),
              d = n.margin || 0;
            (i += d * s),
              (t.childrenPos[c] = { [o]: i + (u / 2) * s, [a]: 0 }),
              (i += s * (u + d));
          }
        }
        const Tu = "start",
          Eu = "center",
          Cu = "end",
          Au = "stretch";
        function Lu(t, e) {
          const n = t.getAlignItems();
          -1 === Pu.indexOf(n) &&
            console.warn(`alignItems === '${n}' is not supported`);
          let s = "getWidth",
            i = "x";
          0 === e.indexOf(vu) && ((s = "getHeight"), (i = "y"));
          const r = t[s]() / 2 - (t.padding || 0);
          t.childrenBoxes.forEach((o) => {
            let a;
            switch (n) {
              case Cu:
              case "right":
              case "bottom":
                a =
                  0 === e.indexOf(vu)
                    ? -r + o[s]() / 2 + (o.margin || 0)
                    : r - o[s]() / 2 - (o.margin || 0);
                break;
              case Tu:
              case "left":
              case "top":
                a =
                  0 === e.indexOf(vu)
                    ? r - o[s]() / 2 - (o.margin || 0)
                    : -r + o[s]() / 2 + (o.margin || 0);
            }
            t.childrenPos[o.id][i] = a || 0;
          });
        }
        function Ru(t) {
          -1 !== Iu.indexOf(t) &&
            console.warn(
              `alignItems === '${t}' is deprecated and will be remove in 7.x.x. Fallback are 'start'|'end'`
            );
        }
        const Pu = [Tu, Eu, Cu, Au, "top", "right", "bottom", "left"],
          Iu = ["top", "right", "bottom", "left"],
          Du = "start",
          Nu = "center",
          Ou = "end",
          ku = "space-around",
          Uu = "space-between",
          zu = "space-evenly";
        function Fu(t, e, n, s) {
          const i = t.getJustifyContent();
          -1 === Bu.indexOf(i) &&
            console.warn(`justifyContent === '${i}' is not supported`);
          const r = 0 === e.indexOf("row") ? "width" : "height",
            o = t.getChildrenSideSum(r),
            a = ("width" === r ? t.getInnerWidth() : t.getInnerHeight()) - o,
            c = (function (t, e) {
              switch (t) {
                case Ou:
                  return e;
                case Nu:
                  return e / 2;
              }
              return 0;
            })(i, 2 * n - o * Math.sign(n)),
            u = (function (t, e, n, s) {
              const i = Array(t.length).fill(0);
              if (e > 0)
                switch (n) {
                  case Uu:
                    if (t.length > 1) {
                      const n = (e / (t.length - 1)) * s;
                      i[0] = 0;
                      for (let e = 1; e < t.length; e++) i[e] = n * e;
                    }
                    break;
                  case zu:
                    if (t.length > 1) {
                      const n = (e / (t.length + 1)) * s;
                      for (let e = 0; e < t.length; e++) i[e] = n * (e + 1);
                    }
                    break;
                  case ku:
                    if (t.length > 1) {
                      const n = (e / t.length) * s,
                        r = n / 2;
                      i[0] = r;
                      for (let e = 1; e < t.length; e++) i[e] = r + n * e;
                    }
                }
              return i;
            })(t.childrenBoxes, a, i, s),
            d = 0 === e.indexOf("row") ? "x" : "y";
          t.childrenBoxes.forEach((e, n) => {
            t.childrenPos[e.id][d] -= c - u[n];
          });
        }
        const Bu = [Du, Nu, Ou, ku, Uu, zu];
        function Hu(t) {
          return class extends t {
            constructor(t) {
              super(t), (this.isBoxComponent = !0), (this.childrenPos = {});
            }
            getInnerWidth() {
              const t = this.getContentDirection();
              switch (t) {
                case "row":
                case "row-reverse":
                  return (
                    this.width - (2 * this.padding || 0) ||
                    this.getChildrenSideSum("width")
                  );
                case "column":
                case "column-reverse":
                  return this.getHighestChildSizeOn("width");
                default:
                  console.error(`Invalid contentDirection : ${t}`);
              }
            }
            getInnerHeight() {
              const t = this.getContentDirection();
              switch (t) {
                case "row":
                case "row-reverse":
                  return this.getHighestChildSizeOn("height");
                case "column":
                case "column-reverse":
                  return (
                    this.height - (2 * this.padding || 0) ||
                    this.getChildrenSideSum("height")
                  );
                default:
                  console.error(`Invalid contentDirection : ${t}`);
              }
            }
            getChildrenSideSum(t) {
              return this.childrenBoxes.reduce((e, n) => {
                const s = 2 * n.margin || 0;
                return (
                  e + ("width" === t ? n.getWidth() + s : n.getHeight() + s)
                );
              }, 0);
            }
            setPosFromParentRecords() {
              this.parentUI &&
                this.parentUI.childrenPos[this.id] &&
                ((this.position.x = this.parentUI.childrenPos[this.id].x),
                (this.position.y = this.parentUI.childrenPos[this.id].y));
            }
            computeChildrenPosition() {
              if (this.children.length > 0) {
                const t = this.getContentDirection();
                let e;
                switch (t) {
                  case vu:
                    e = -this.getInnerWidth() / 2;
                    break;
                  case yu:
                    e = this.getInnerWidth() / 2;
                    break;
                  case wu:
                    e = this.getInnerHeight() / 2;
                    break;
                  case _u:
                    e = -this.getInnerHeight() / 2;
                }
                const n = -Math.sign(e);
                Su(this, t, e, n), Fu(this, t, e, n), Lu(this, t);
              }
            }
            getHighestChildSizeOn(t) {
              return this.childrenBoxes.reduce((e, n) => {
                const s = n.margin || 0,
                  i =
                    "width" === t
                      ? n.getWidth() + 2 * s
                      : n.getHeight() + 2 * s;
                return Math.max(e, i);
              }, 0);
            }
            getWidth() {
              return this.parentUI &&
                "stretch" === this.parentUI.getAlignItems() &&
                -1 !== this.parentUI.getContentDirection().indexOf("column")
                ? this.parentUI.getWidth() - (2 * this.parentUI.padding || 0)
                : this.width || this.getInnerWidth() + (2 * this.padding || 0);
            }
            getHeight() {
              return this.parentUI &&
                "stretch" === this.parentUI.getAlignItems() &&
                -1 !== this.parentUI.getContentDirection().indexOf("row")
                ? this.parentUI.getHeight() - (2 * this.parentUI.padding || 0)
                : this.height ||
                    this.getInnerHeight() + (2 * this.padding || 0);
            }
          };
        }
        const Gu = { "\t": "\t", "\n": "\n", "\r": "\r", " ": " " },
          Vu = "normal",
          Wu = "nowrap",
          ju = "pre",
          Xu = "pre-line",
          qu = "pre-wrap",
          Yu = function (t, e) {
            switch (e) {
              case Wu:
              case Vu:
                t = t.replace(/\n/g, " ");
              case Xu:
                t = t.replace(/[ ]{2,}/g, " ");
            }
            return t;
          },
          Ju = function (t) {
            switch (t) {
              case ju:
              case qu:
              case Xu:
                return "mandatory";
            }
          },
          Zu = function (t, e, n, s) {
            const i = t[e];
            switch (s.WHITESPACE) {
              case Vu:
              case Xu:
              case qu:
                if ("mandatory" === i.lineBreak) return !0;
                const r = i.kerning ? i.kerning : 0,
                  o = i.xoffset ? i.xoffset : 0;
                if (
                  n + (i.xadvance ? i.xadvance : i.width) + o + r >
                  s.INNER_WIDTH
                )
                  return !0;
                const a = td(t, e, s);
                return (function (t, e, n, s) {
                  return (
                    !(!t || !t.glyph) &&
                    !(e + n < s.INNER_WIDTH) &&
                    s.BREAKON.indexOf(t.glyph) > -1
                  );
                })(t[e - 1], n, a, s);
              case ju:
                return "mandatory" === i.lineBreak;
              default:
                return !1;
            }
          },
          $u = function (t, e) {
            const n = t[0],
              s = t[t.length - 1];
            switch (e) {
              case qu:
                n.glyph && "\n" === n.glyph && t.length > 1 && Qu([n], t[1]),
                  s.glyph &&
                    "\n" === s.glyph &&
                    t.length > 1 &&
                    Ku([s], t[t.length - 2]);
                break;
              case Xu:
              case Wu:
              case Vu:
                let i,
                  r = [];
                for (let e = 0; e < t.length; e++) {
                  const n = t[e];
                  if (!(n.glyph && Gu[n.glyph] && t.length > e)) break;
                  r.push(n), (i = t[e + 1]);
                }
                Qu(r, i), (r = []), (i = null);
                for (let e = t.length - 1; e > 0; e--) {
                  const n = t[e];
                  if (!(n.glyph && Gu[n.glyph] && e > 0)) break;
                  r.push(n), (i = t[e - 1]);
                }
                Ku(r, i);
                break;
              case ju:
                break;
              default:
                return console.warn(`whiteSpace: '${e}' is not valid`), 0;
            }
            return n.offsetX;
          };
        function Ku(t, e) {
          if (e)
            for (let n = 0; n < t.length; n++) {
              const s = t[n];
              (s.width = 0), (s.height = 0), (s.offsetX = e.offsetX + e.width);
            }
        }
        function Qu(t, e) {
          if (e)
            for (let n = 0; n < t.length; n++) {
              const s = t[n];
              (s.width = 0), (s.height = 0), (s.offsetX = e.offsetX);
            }
        }
        function td(t, e, n, s) {
          if (((s = s || 0), !t[e])) return s;
          const i = t[e],
            r = i.kerning ? i.kerning : 0,
            o = i.xoffset ? i.xoffset : 0,
            a = i.xadvance ? i.xadvance : i.width;
          return i.lineBreak
            ? s + a
            : td(t, e + 1, n, s + a + n.LETTERSPACING + o + r);
        }
        const ed = "left",
          nd = "right",
          sd = "center",
          id = "justify",
          rd = "justify-left",
          od = "justify-right",
          ad = "justify-center";
        function cd(t, e, n) {
          for (let s = 0; s < t.length; s++) {
            const i = t[s],
              r = ud(i, e, n, s === t.length - 1);
            for (let t = 0; t < i.length; t++) i[t].offsetX += r;
          }
          if (0 === e.indexOf(id))
            for (let s = 0; s < t.length; s++) {
              const i = t[s];
              if (-1 !== e.indexOf("-") && s === t.length - 1) return;
              const r = n - i.width;
              if (r <= 0) return;
              let o = 0;
              for (let t = 1; t < i.length - 1; t++)
                o += " " === i[t].glyph ? 1 : 0;
              const a = r / o;
              let c = 1;
              e === od && (i.reverse(), (c = -1));
              let u = 0;
              for (let t = 1; t <= i.length - 1; t++) {
                const e = i[t];
                (e.offsetX += u * c), (u += " " === e.glyph ? a : 0);
              }
              e === od && i.reverse();
            }
        }
        const ud = (t, e, n, s) => {
          switch (e) {
            case rd:
            case id:
            case ed:
              return -n / 2;
            case od:
            case nd:
              return -t.width + n / 2;
            case sd:
              return -t.width / 2;
            case ad:
              return s ? -t.width / 2 : -n / 2;
            default:
              console.warn(`textAlign: '${e}' is not valid`);
          }
        };
        function dd(t) {
          return class extends t {
            computeInlinesPosition() {
              const t = this.getWidth() - (2 * this.padding || 0),
                e = this.getHeight() - (2 * this.padding || 0),
                n = this.getJustifyContent(),
                s = this.getTextAlign(),
                i = this.getInterLine(),
                r = this.computeLines();
              let o =
                r.reduce((t, e, n, s) => {
                  const r = e.lineHeight - e.lineBase;
                  return (
                    e.forEach((n) => {
                      n.offsetY = t - e.lineHeight + r + s[0].lineHeight;
                    }),
                    t - e.lineHeight - i
                  );
                }, 0) + i;
              o = Math.abs(o);
              const a = (() => {
                switch (n) {
                  case "start":
                    return e / 2 - r[0].lineHeight;
                  case "end":
                    return (
                      o -
                      r[0].lineHeight -
                      e / 2 +
                      (r[r.length - 1].lineHeight - r[r.length - 1].lineHeight)
                    );
                  case "center":
                    return o / 2 - r[0].lineHeight;
                  default:
                    console.warn(`justifyContent: '${n}' is not valid`);
                }
              })();
              r.forEach((t) => {
                t.forEach((t) => {
                  t.offsetY += a;
                });
              }),
                cd(r, s, t),
                (this.lines = r);
            }
            calculateBestFit(t) {
              if (0 !== this.childrenInlines.length)
                switch (t) {
                  case "grow":
                    this.calculateGrowFit();
                    break;
                  case "shrink":
                    this.calculateShrinkFit();
                    break;
                  case "auto":
                    this.calculateAutoFit();
                }
            }
            calculateGrowFit() {
              const t = this.getHeight() - (2 * this.padding || 0);
              let e = 1;
              const n = this.childrenInlines.find((t) => t.isText);
              let s,
                i = 1,
                r = 2,
                o = n._fitFontSize ? n._fitFontSize / n.getFontSize() : 1;
              do {
                if (((s = this.calculateHeight(o)), s > t)) {
                  if (o <= i) {
                    this.childrenInlines.forEach((t) => {
                      t.isInlineBlock || (t._fitFontSize = t.getFontSize());
                    });
                    break;
                  }
                  (r = o), (o -= (r - i) / 2);
                } else {
                  if (Math.abs(t - s) < 0.075) break;
                  Math.abs(o - r) < 5e-10 && (r *= 2),
                    (i = o),
                    (o += (r - i) / 2);
                }
              } while (++e <= 10);
            }
            calculateShrinkFit() {
              const t = this.getHeight() - (2 * this.padding || 0);
              let e = 1;
              const n = this.childrenInlines.find((t) => t.isText);
              let s,
                i = 0,
                r = 1,
                o = n._fitFontSize ? n._fitFontSize / n.getFontSize() : 1;
              do {
                if (((s = this.calculateHeight(o)), s > t))
                  (r = o), (o -= (r - i) / 2);
                else {
                  if (o >= r) {
                    this.childrenInlines.forEach((t) => {
                      t.isInlineBlock || (t._fitFontSize = t.getFontSize());
                    });
                    break;
                  }
                  if (Math.abs(t - s) < 0.075) break;
                  (i = o), (o += (r - i) / 2);
                }
              } while (++e <= 10);
            }
            calculateAutoFit() {
              const t = this.getHeight() - (2 * this.padding || 0);
              let e = 1;
              const n = this.childrenInlines.find((t) => t.isText);
              let s,
                i = 0,
                r = 2,
                o = n._fitFontSize ? n._fitFontSize / n.getFontSize() : 1;
              do {
                if (((s = this.calculateHeight(o)), s > t))
                  (r = o), (o -= (r - i) / 2);
                else {
                  if (Math.abs(t - s) < 0.075) break;
                  Math.abs(o - r) < 5e-10 && (r *= 2),
                    (i = o),
                    (o += (r - i) / 2);
                }
              } while (++e <= 10);
            }
            computeLines() {
              const t = this.getWidth() - (2 * this.padding || 0),
                e = [[]];
              return (
                this.childrenInlines.reduce((n, s) => {
                  if (!s.inlines) return;
                  const i = s._fitFontSize || s.getFontSize(),
                    r = s.isText ? s.getLetterSpacing() * i : 0,
                    o = s.getWhiteSpace(),
                    a = s.getBreakOn(),
                    c = {
                      WHITESPACE: o,
                      LETTERSPACING: r,
                      BREAKON: a,
                      INNER_WIDTH: t,
                    };
                  return s.inlines.reduce((t, n, s, i) => {
                    const o = n.kerning ? n.kerning : 0,
                      a = n.xoffset ? n.xoffset : 0,
                      u = n.xadvance ? n.xadvance : n.width;
                    return Zu(i, s, t, c)
                      ? (e.push([n]),
                        (n.offsetX = a),
                        0 === n.width ? 0 : u + r)
                      : (e[e.length - 1].push(n),
                        (n.offsetX = t + a + o),
                        t + u + o + r);
                  }, n);
                }, 0),
                e.forEach((t) => {
                  if (
                    ((t.lineHeight = t.reduce((t, e) => {
                      const n =
                        void 0 !== e.lineHeight ? e.lineHeight : e.height;
                      return Math.max(t, n);
                    }, 0)),
                    (t.lineBase = t.reduce((t, e) => {
                      const n = void 0 !== e.lineBase ? e.lineBase : e.height;
                      return Math.max(t, n);
                    }, 0)),
                    (t.width = 0),
                    t[0])
                  ) {
                    const e = this.getWhiteSpace(),
                      n = $u(t, e);
                    t.forEach((t) => {
                      t.offsetX -= n;
                    }),
                      (t.width = this.computeLineWidth(t));
                  }
                }),
                e
              );
            }
            calculateHeight(t) {
              this.childrenInlines.forEach((e) => {
                e.isInlineBlock ||
                  ((e._fitFontSize = e.getFontSize() * t),
                  e.calculateInlines(e._fitFontSize));
              });
              const e = this.computeLines(),
                n = this.getInterLine(),
                s = e.reduce((t, e) => t - e.lineHeight - n, 0) + n;
              return Math.abs(s);
            }
            computeLineWidth(t) {
              const e = t[0],
                n = t[t.length - 1];
              return n.offsetX + n.width + e.offsetX;
            }
          };
        }
        const ld = new xu.FileLoader(),
          hd = [],
          fd = {},
          md = new xu.TextureLoader(),
          pd = [],
          gd = {},
          xd = {};
        function vd(t) {
          if (t._kernings) return;
          const e = {};
          for (let n = 0; n < t.kernings.length; n++) {
            const s = t.kernings[n];
            0 !== s.amount &&
              (e[String.fromCharCode(s.first, s.second)] = s.amount);
          }
          t._kernings = e;
        }
        const yd = {
          setFontFamily: function (t, e) {
            "string" == typeof e
              ? (function (t, e) {
                  -1 === hd.indexOf(e) &&
                    (hd.push(e),
                    ld.load(e, (t) => {
                      const n = JSON.parse(t);
                      vd(n), (fd[e] = n);
                      for (const t of Object.keys(xd))
                        e === xd[t].jsonURL &&
                          xd[t].component._updateFontFamily(n);
                    })),
                    xd[t.id] || (xd[t.id] = { component: t }),
                    (xd[t.id].jsonURL = e),
                    fd[e] && t._updateFontFamily(fd[e]);
                })(t, e)
              : (xd[t.id] || (xd[t.id] = { component: t }),
                vd(e),
                (xd[t.id].json = e),
                t._updateFontFamily(e));
          },
          setFontTexture: function (t, e) {
            -1 === pd.indexOf(e) &&
              (pd.push(e),
              md.load(e, (t) => {
                (t.generateMipmaps = !1),
                  (t.minFilter = xu.LinearFilter),
                  (t.magFilter = xu.LinearFilter),
                  (gd[e] = t);
                for (const n of Object.keys(xd))
                  e === xd[n].textureURL &&
                    xd[n].component._updateFontTexture(t);
              })),
              xd[t.id] || (xd[t.id] = { component: t }),
              (xd[t.id].textureURL = e),
              gd[e] && t._updateFontTexture(gd[e]);
          },
          getFontOf: function t(e) {
            const n = xd[e.id];
            return !n && e.parentUI ? t(e.parentUI) : n;
          },
          addFont: function (t, e, n) {
            (n.generateMipmaps = !1),
              (n.minFilter = xu.LinearFilter),
              (n.magFilter = xu.LinearFilter),
              hd.push(t),
              (fd[t] = e),
              vd(e),
              n && (pd.push(t), (gd[t] = n));
          },
        };
        class wd {
          static requestUpdate(t, e, n, s) {
            t.traverse((t) => {
              t.isUI &&
                (this.requestedUpdates[t.id]
                  ? (e && (this.requestedUpdates[t.id].updateParsing = !0),
                    n && (this.requestedUpdates[t.id].updateLayout = !0),
                    s && (this.requestedUpdates[t.id].updateInner = !0))
                  : (this.requestedUpdates[t.id] = {
                      updateParsing: e,
                      updateLayout: n,
                      updateInner: s,
                      needCallback: e || n || s,
                    }));
            });
          }
          static register(t) {
            this.components.includes(t) || this.components.push(t);
          }
          static disposeOf(t) {
            const e = this.components.indexOf(t);
            e > -1 && this.components.splice(e, 1);
          }
          static update() {
            if (Object.keys(this.requestedUpdates).length > 0) {
              const t = this.components.filter((t) => !t.parentUI);
              t.forEach((t) => this.traverseParsing(t)),
                t.forEach((t) => this.traverseUpdates(t));
            }
          }
          static traverseParsing(t) {
            const e = this.requestedUpdates[t.id];
            e && e.updateParsing && (t.parseParams(), (e.updateParsing = !1)),
              t.childrenUIs.forEach((t) => this.traverseParsing(t));
          }
          static traverseUpdates(t) {
            const e = this.requestedUpdates[t.id];
            delete this.requestedUpdates[t.id],
              e && e.updateLayout && ((e.updateLayout = !1), t.updateLayout()),
              e && e.updateInner && ((e.updateInner = !1), t.updateInner()),
              t.childrenUIs.forEach((t) => {
                this.traverseUpdates(t);
              }),
              e && e.needCallback && t.onAfterUpdate();
          }
        }
        (wd.components = []), (wd.requestedUpdates = {});
        const _d = {
          container: null,
          fontFamily: null,
          fontSize: 0.05,
          fontKerning: "normal",
          bestFit: "none",
          offset: 0.01,
          interLine: 0.01,
          breakOn: "- ,.:?!\n",
          whiteSpace: Xu,
          contentDirection: wu,
          alignItems: Eu,
          justifyContent: Du,
          fontTexture: null,
          textAlign: sd,
          textType: "MSDF",
          fontColor: new xu.Color(16777215),
          fontOpacity: 1,
          fontPXRange: 4,
          fontSupersampling: !0,
          borderRadius: 0.01,
          borderWidth: 0,
          borderColor: new xu.Color("black"),
          borderOpacity: 1,
          backgroundSize: "cover",
          backgroundColor: new xu.Color(2236962),
          backgroundWhiteColor: new xu.Color(16777215),
          backgroundOpacity: 0.8,
          backgroundOpaqueOpacity: 1,
          backgroundTexture: function () {
            if (!bd) {
              const t = document.createElement("canvas").getContext("2d");
              (t.canvas.width = 1),
                (t.canvas.height = 1),
                (t.fillStyle = "#ffffff"),
                t.fillRect(0, 0, 1, 1),
                (bd = new xu.CanvasTexture(t.canvas)),
                (bd.isDefault = !0);
            }
            return bd;
          },
          hiddenOverflow: !1,
          letterSpacing: 0,
        };
        let bd;
        function Md(t) {
          return class extends t {
            constructor(t) {
              super(t),
                (this.states = {}),
                (this.currentState = void 0),
                (this.isUI = !0),
                (this.autoLayout = !0),
                (this.childrenUIs = []),
                (this.childrenBoxes = []),
                (this.childrenTexts = []),
                (this.childrenInlines = []),
                (this.parentUI = null),
                this.addEventListener("added", this._rebuildParentUI),
                this.addEventListener("removed", this._rebuildParentUI);
            }
            getClippingPlanes() {
              const t = [];
              if (this.parentUI) {
                if (this.isBlock && this.parentUI.getHiddenOverflow()) {
                  const e =
                      this.parentUI.getHeight() / 2 -
                      (this.parentUI.padding || 0),
                    n =
                      this.parentUI.getWidth() / 2 -
                      (this.parentUI.padding || 0),
                    s = [
                      new xu.Plane(new xu.Vector3(0, 1, 0), e),
                      new xu.Plane(new xu.Vector3(0, -1, 0), e),
                      new xu.Plane(new xu.Vector3(1, 0, 0), n),
                      new xu.Plane(new xu.Vector3(-1, 0, 0), n),
                    ];
                  s.forEach((t) => {
                    t.applyMatrix4(this.parent.matrixWorld);
                  }),
                    t.push(...s);
                }
                this.parentUI.parentUI &&
                  t.push(...this.parentUI.getClippingPlanes());
              }
              return t;
            }
            getHighestParent() {
              return this.parentUI ? this.parent.getHighestParent() : this;
            }
            _getProperty(t) {
              return void 0 === this[t] && this.parentUI
                ? this.parent._getProperty(t)
                : void 0 !== this[t]
                ? this[t]
                : _d[t];
            }
            getFontSize() {
              return this._getProperty("fontSize");
            }
            getFontKerning() {
              return this._getProperty("fontKerning");
            }
            getLetterSpacing() {
              return this._getProperty("letterSpacing");
            }
            getFontTexture() {
              return this._getProperty("fontTexture");
            }
            getFontFamily() {
              return this._getProperty("fontFamily");
            }
            getBreakOn() {
              return this._getProperty("breakOn");
            }
            getWhiteSpace() {
              return this._getProperty("whiteSpace");
            }
            getTextAlign() {
              return this._getProperty("textAlign");
            }
            getTextType() {
              return this._getProperty("textType");
            }
            getFontColor() {
              return this._getProperty("fontColor");
            }
            getFontSupersampling() {
              return this._getProperty("fontSupersampling");
            }
            getFontOpacity() {
              return this._getProperty("fontOpacity");
            }
            getFontPXRange() {
              return this._getProperty("fontPXRange");
            }
            getBorderRadius() {
              return this._getProperty("borderRadius");
            }
            getBorderWidth() {
              return this._getProperty("borderWidth");
            }
            getBorderColor() {
              return this._getProperty("borderColor");
            }
            getBorderOpacity() {
              return this._getProperty("borderOpacity");
            }
            getContainer() {
              return !this.threeOBJ && this.parent
                ? this.parent.getContainer()
                : this.threeOBJ
                ? this
                : _d.container;
            }
            getParentsNumber(t) {
              return (
                (t = t || 0),
                this.parentUI ? this.parentUI.getParentsNumber(t + 1) : t
              );
            }
            getBackgroundOpacity() {
              return this.backgroundOpacity || 0 === this.backgroundOpacity
                ? this.backgroundOpacity
                : _d.backgroundOpacity;
            }
            getBackgroundColor() {
              return this.backgroundColor || _d.backgroundColor;
            }
            getBackgroundTexture() {
              return this.backgroundTexture || _d.backgroundTexture();
            }
            getAlignContent() {
              return this.alignContent || _d.alignContent;
            }
            getAlignItems() {
              return this.alignItems || _d.alignItems;
            }
            getContentDirection() {
              return this.contentDirection || _d.contentDirection;
            }
            getJustifyContent() {
              return this.justifyContent || _d.justifyContent;
            }
            getInterLine() {
              return void 0 === this.interLine ? _d.interLine : this.interLine;
            }
            getOffset() {
              return void 0 === this.offset ? _d.offset : this.offset;
            }
            getBackgroundSize() {
              return void 0 === this.backgroundSize
                ? _d.backgroundSize
                : this.backgroundSize;
            }
            getHiddenOverflow() {
              return void 0 === this.hiddenOverflow
                ? _d.hiddenOverflow
                : this.hiddenOverflow;
            }
            getBestFit() {
              return void 0 === this.bestFit ? _d.bestFit : this.bestFit;
            }
            _rebuildChildrenLists() {
              (this.childrenUIs = this.children.filter((t) => t.isUI)),
                (this.childrenBoxes = this.children.filter(
                  (t) => t.isBoxComponent
                )),
                (this.childrenInlines = this.children.filter(
                  (t) => t.isInline
                )),
                (this.childrenTexts = this.children.filter((t) => t.isText));
            }
            _rebuildParentUI = () => {
              this.parent && this.parent.isUI
                ? (this.parentUI = this.parent)
                : (this.parentUI = null);
            };
            add() {
              for (const t of Object.keys(arguments))
                arguments[t].isInline && this.update(null, !0);
              const t = super.add(...arguments);
              return this._rebuildChildrenLists(), t;
            }
            remove() {
              for (const t of Object.keys(arguments))
                arguments[t].isInline && this.update(null, !0);
              const t = super.remove(...arguments);
              return this._rebuildChildrenLists(), t;
            }
            update(t, e, n) {
              wd.requestUpdate(this, t, e, n);
            }
            onAfterUpdate() {}
            _updateFontFamily(t) {
              (this.fontFamily = t),
                this.traverse((t) => {
                  t.isUI && t.update(!0, !0, !1);
                }),
                this.getHighestParent().update(!1, !0, !1);
            }
            _updateFontTexture(t) {
              (this.fontTexture = t),
                this.getHighestParent().update(!1, !0, !1);
            }
            set(t) {
              let e, n, s;
              if (
                (wd.register(this),
                t && JSON.stringify(t) !== JSON.stringify({}))
              ) {
                t.alignContent &&
                  ((t.alignItems = t.alignContent),
                  t.textAlign || (t.textAlign = t.alignContent),
                  console.warn(
                    "`alignContent` property has been deprecated, please rely on `alignItems` and `textAlign` instead."
                  ),
                  delete t.alignContent),
                  t.alignItems && Ru(t.alignItems);
                for (const i of Object.keys(t))
                  if (this[i] != t[i])
                    switch (i) {
                      case "content":
                      case "fontSize":
                      case "fontKerning":
                      case "breakOn":
                      case "whiteSpace":
                        this.isText && (e = !0), (n = !0), (this[i] = t[i]);
                        break;
                      case "bestFit":
                        this.isBlock && ((e = !0), (n = !0)), (this[i] = t[i]);
                        break;
                      case "width":
                      case "height":
                      case "padding":
                        (this.isInlineBlock ||
                          (this.isBlock && "none" != this.getBestFit())) &&
                          (e = !0),
                          (n = !0),
                          (this[i] = t[i]);
                        break;
                      case "letterSpacing":
                      case "interLine":
                        this.isBlock && "none" != this.getBestFit() && (e = !0),
                          (n = !0),
                          (this[i] = t[i]);
                        break;
                      case "margin":
                      case "contentDirection":
                      case "justifyContent":
                      case "alignContent":
                      case "alignItems":
                      case "textAlign":
                      case "textType":
                        (n = !0), (this[i] = t[i]);
                        break;
                      case "fontColor":
                      case "fontOpacity":
                      case "fontSupersampling":
                      case "offset":
                      case "backgroundColor":
                      case "backgroundOpacity":
                      case "backgroundTexture":
                      case "backgroundSize":
                      case "borderRadius":
                      case "borderWidth":
                      case "borderColor":
                      case "borderOpacity":
                        (s = !0), (this[i] = t[i]);
                        break;
                      case "hiddenOverflow":
                        this[i] = t[i];
                    }
                t.fontFamily && yd.setFontFamily(this, t.fontFamily),
                  t.fontTexture && yd.setFontTexture(this, t.fontTexture),
                  this.parentUI &&
                    "none" != this.parentUI.getBestFit() &&
                    this.parentUI.update(!0, !0, !1),
                  this.update(e, n, s),
                  n && this.getHighestParent().update(!1, !0, !1);
              }
            }
            setupState(t) {
              this.states[t.state] = {
                attributes: t.attributes,
                onSet: t.onSet,
              };
            }
            setState(t) {
              const e = this.states[t];
              e
                ? t !== this.currentState &&
                  ((this.currentState = t),
                  e.onSet && e.onSet(),
                  e.attributes && this.set(e.attributes))
                : console.warn(
                    `state "${t}" does not exist within this component`
                  );
            }
            clear() {
              this.traverse((t) => {
                wd.disposeOf(t),
                  t.material && t.material.dispose(),
                  t.geometry && t.geometry.dispose();
              });
            }
          };
        }
        function Sd(t) {
          return class extends t {
            constructor(t) {
              super(t),
                (this.textUniforms = {
                  u_texture: { value: null },
                  u_color: { value: null },
                  u_opacity: { value: null },
                  u_pxRange: { value: null },
                  u_useRGSS: { value: null },
                }),
                (this.backgroundUniforms = {
                  u_texture: { value: null },
                  u_color: { value: null },
                  u_opacity: { value: null },
                  u_backgroundMapping: { value: null },
                  u_borderWidth: { value: null },
                  u_borderColor: { value: null },
                  u_borderRadiusTopLeft: { value: null },
                  u_borderRadiusTopRight: { value: null },
                  u_borderRadiusBottomRight: { value: null },
                  u_borderRadiusBottomLeft: { value: null },
                  u_borderOpacity: { value: null },
                  u_size: { value: new xu.Vector2(1, 1) },
                  u_tSize: { value: new xu.Vector2(1, 1) },
                });
            }
            updateBackgroundMaterial() {
              (this.backgroundUniforms.u_texture.value =
                this.getBackgroundTexture()),
                this.backgroundUniforms.u_tSize.value.set(
                  this.backgroundUniforms.u_texture.value.image.width,
                  this.backgroundUniforms.u_texture.value.image.height
                ),
                this.size &&
                  this.backgroundUniforms.u_size.value.copy(this.size),
                this.backgroundUniforms.u_texture.value.isDefault
                  ? ((this.backgroundUniforms.u_color.value =
                      this.getBackgroundColor()),
                    (this.backgroundUniforms.u_opacity.value =
                      this.getBackgroundOpacity()))
                  : ((this.backgroundUniforms.u_color.value =
                      this.backgroundColor || _d.backgroundWhiteColor),
                    (this.backgroundUniforms.u_opacity.value =
                      this.backgroundOpacity || 0 === this.backgroundOpacity
                        ? this.backgroundOpacity
                        : _d.backgroundOpaqueOpacity)),
                (this.backgroundUniforms.u_backgroundMapping.value = (() => {
                  switch (this.getBackgroundSize()) {
                    case "stretch":
                      return 0;
                    case "contain":
                      return 1;
                    case "cover":
                      return 2;
                  }
                })());
              const t = this.getBorderRadius();
              (this.backgroundUniforms.u_borderWidth.value =
                this.getBorderWidth()),
                (this.backgroundUniforms.u_borderColor.value =
                  this.getBorderColor()),
                (this.backgroundUniforms.u_borderOpacity.value =
                  this.getBorderOpacity()),
                Array.isArray(t)
                  ? ((this.backgroundUniforms.u_borderRadiusTopLeft.value =
                      t[0]),
                    (this.backgroundUniforms.u_borderRadiusTopRight.value =
                      t[1]),
                    (this.backgroundUniforms.u_borderRadiusBottomRight.value =
                      t[2]),
                    (this.backgroundUniforms.u_borderRadiusBottomLeft.value =
                      t[3]))
                  : ((this.backgroundUniforms.u_borderRadiusTopLeft.value = t),
                    (this.backgroundUniforms.u_borderRadiusTopRight.value = t),
                    (this.backgroundUniforms.u_borderRadiusBottomRight.value =
                      t),
                    (this.backgroundUniforms.u_borderRadiusBottomLeft.value =
                      t));
            }
            updateTextMaterial() {
              (this.textUniforms.u_texture.value = this.getFontTexture()),
                (this.textUniforms.u_color.value = this.getFontColor()),
                (this.textUniforms.u_opacity.value = this.getFontOpacity()),
                (this.textUniforms.u_pxRange.value = this.getFontPXRange()),
                (this.textUniforms.u_useRGSS.value =
                  this.getFontSupersampling());
            }
            getBackgroundMaterial() {
              return (
                (this.backgroundMaterial && this.backgroundUniforms) ||
                  (this.backgroundMaterial = this._makeBackgroundMaterial()),
                this.backgroundMaterial
              );
            }
            getFontMaterial() {
              return (
                (this.fontMaterial && this.textUniforms) ||
                  (this.fontMaterial = this._makeTextMaterial()),
                this.fontMaterial
              );
            }
            _makeTextMaterial() {
              return new xu.ShaderMaterial({
                uniforms: this.textUniforms,
                transparent: !0,
                clipping: !0,
                vertexShader: Td,
                fragmentShader: Ed,
                extensions: { derivatives: !0 },
              });
            }
            _makeBackgroundMaterial() {
              return new xu.ShaderMaterial({
                uniforms: this.backgroundUniforms,
                transparent: !0,
                clipping: !0,
                vertexShader: Cd,
                fragmentShader: Ad,
                extensions: { derivatives: !0 },
              });
            }
            updateClippingPlanes(t) {
              const e = void 0 !== t ? t : this.getClippingPlanes();
              JSON.stringify(e) !== JSON.stringify(this.clippingPlanes) &&
                ((this.clippingPlanes = e),
                this.fontMaterial &&
                  (this.fontMaterial.clippingPlanes = this.clippingPlanes),
                this.backgroundMaterial &&
                  (this.backgroundMaterial.clippingPlanes =
                    this.clippingPlanes));
            }
          };
        }
        const Td =
            "\nvarying vec2 vUv;\n\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\tvUv = uv;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\tgl_Position.z -= 0.00001;\n\n\t#include <clipping_planes_vertex>\n\n}\n",
          Ed =
            "\n\nuniform sampler2D u_texture;\nuniform vec3 u_color;\nuniform float u_opacity;\nuniform float u_pxRange;\nuniform bool u_useRGSS;\n\nvarying vec2 vUv;\n\n#include <clipping_planes_pars_fragment>\n\n// functions from the original msdf repo:\n// https://github.com/Chlumsky/msdfgen#using-a-multi-channel-distance-field\n\nfloat median(float r, float g, float b) {\n\treturn max(min(r, g), min(max(r, g), b));\n}\n\nfloat screenPxRange() {\n\tvec2 unitRange = vec2(u_pxRange)/vec2(textureSize(u_texture, 0));\n\tvec2 screenTexSize = vec2(1.0)/fwidth(vUv);\n\treturn max(0.5*dot(unitRange, screenTexSize), 1.0);\n}\n\nfloat tap(vec2 offsetUV) {\n\tvec3 msd = texture( u_texture, offsetUV ).rgb;\n\tfloat sd = median(msd.r, msd.g, msd.b);\n\tfloat screenPxDistance = screenPxRange() * (sd - 0.5);\n\tfloat alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n\treturn alpha;\n}\n\nvoid main() {\n\n\tfloat alpha;\n\n\tif ( u_useRGSS ) {\n\n\t\t// shader-based supersampling based on https://bgolus.medium.com/sharper-mipmapping-using-shader-based-supersampling-ed7aadb47bec\n\t\t// per pixel partial derivatives\n\t\tvec2 dx = dFdx(vUv);\n\t\tvec2 dy = dFdy(vUv);\n\n\t\t// rotated grid uv offsets\n\t\tvec2 uvOffsets = vec2(0.125, 0.375);\n\t\tvec2 offsetUV = vec2(0.0, 0.0);\n\n\t\t// supersampled using 2x2 rotated grid\n\t\talpha = 0.0;\n\t\toffsetUV.xy = vUv + uvOffsets.x * dx + uvOffsets.y * dy;\n\t\talpha += tap(offsetUV);\n\t\toffsetUV.xy = vUv - uvOffsets.x * dx - uvOffsets.y * dy;\n\t\talpha += tap(offsetUV);\n\t\toffsetUV.xy = vUv + uvOffsets.y * dx - uvOffsets.x * dy;\n\t\talpha += tap(offsetUV);\n\t\toffsetUV.xy = vUv - uvOffsets.y * dx + uvOffsets.x * dy;\n\t\talpha += tap(offsetUV);\n\t\talpha *= 0.25;\n\n\t} else {\n\n\t\talpha = tap( vUv );\n\n\t}\n\n\n\t// apply the opacity\n\talpha *= u_opacity;\n\n\t// this is useful to avoid z-fighting when quads overlap because of kerning\n\tif ( alpha < 0.02) discard;\n\n\n\tgl_FragColor = vec4( u_color, alpha );\n\n\t#include <clipping_planes_fragment>\n\n}\n",
          Cd =
            "\nvarying vec2 vUv;\n\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\tvUv = uv;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <clipping_planes_vertex>\n\n}\n",
          Ad =
            "\n\nuniform sampler2D u_texture;\nuniform vec3 u_color;\nuniform float u_opacity;\n\nuniform float u_borderRadiusTopLeft;\nuniform float u_borderRadiusTopRight;\nuniform float u_borderRadiusBottomLeft;\nuniform float u_borderRadiusBottomRight;\nuniform float u_borderWidth;\nuniform vec3 u_borderColor;\nuniform float u_borderOpacity;\nuniform vec2 u_size;\nuniform vec2 u_tSize;\nuniform int u_backgroundMapping;\n\nvarying vec2 vUv;\n\n#include <clipping_planes_pars_fragment>\n\nfloat getEdgeDist() {\n\tvec2 ndc = vec2( vUv.x * 2.0 - 1.0, vUv.y * 2.0 - 1.0 );\n\tvec2 planeSpaceCoord = vec2( u_size.x * 0.5 * ndc.x, u_size.y * 0.5 * ndc.y );\n\tvec2 corner = u_size * 0.5;\n\tvec2 offsetCorner = corner - abs( planeSpaceCoord );\n\tfloat innerRadDist = min( offsetCorner.x, offsetCorner.y ) * -1.0;\n\tif (vUv.x < 0.5 && vUv.y >= 0.5) {\n\t\tfloat roundedDist = length( max( abs( planeSpaceCoord ) - u_size * 0.5 + u_borderRadiusTopLeft, 0.0 ) ) - u_borderRadiusTopLeft;\n\t\tfloat s = step( innerRadDist * -1.0, u_borderRadiusTopLeft );\n\t\treturn mix( innerRadDist, roundedDist, s );\n\t}\n\tif (vUv.x >= 0.5 && vUv.y >= 0.5) {\n\t\tfloat roundedDist = length( max( abs( planeSpaceCoord ) - u_size * 0.5 + u_borderRadiusTopRight, 0.0 ) ) - u_borderRadiusTopRight;\n\t\tfloat s = step( innerRadDist * -1.0, u_borderRadiusTopRight );\n\t\treturn mix( innerRadDist, roundedDist, s );\n\t}\n\tif (vUv.x >= 0.5 && vUv.y < 0.5) {\n\t\tfloat roundedDist = length( max( abs( planeSpaceCoord ) - u_size * 0.5 + u_borderRadiusBottomRight, 0.0 ) ) - u_borderRadiusBottomRight;\n\t\tfloat s = step( innerRadDist * -1.0, u_borderRadiusBottomRight );\n\t\treturn mix( innerRadDist, roundedDist, s );\n\t}\n\tif (vUv.x < 0.5 && vUv.y < 0.5) {\n\t\tfloat roundedDist = length( max( abs( planeSpaceCoord ) - u_size * 0.5 + u_borderRadiusBottomLeft, 0.0 ) ) - u_borderRadiusBottomLeft;\n\t\tfloat s = step( innerRadDist * -1.0, u_borderRadiusBottomLeft );\n\t\treturn mix( innerRadDist, roundedDist, s );\n\t}\n}\n\nvec4 sampleTexture() {\n\tfloat textureRatio = u_tSize.x / u_tSize.y;\n\tfloat panelRatio = u_size.x / u_size.y;\n\tvec2 uv = vUv;\n\tif ( u_backgroundMapping == 1 ) { // contain\n\t\tif ( textureRatio < panelRatio ) { // repeat on X\n\t\t\tfloat newX = uv.x * ( panelRatio / textureRatio );\n\t\t\tnewX += 0.5 - 0.5 * ( panelRatio / textureRatio );\n\t\t\tuv.x = newX;\n\t\t} else { // repeat on Y\n\t\t\tfloat newY = uv.y * ( textureRatio / panelRatio );\n\t\t\tnewY += 0.5 - 0.5 * ( textureRatio / panelRatio );\n\t\t\tuv.y = newY;\n\t\t}\n\t} else if ( u_backgroundMapping == 2 ) { // cover\n\t\tif ( textureRatio < panelRatio ) { // stretch on Y\n\t\t\tfloat newY = uv.y * ( textureRatio / panelRatio );\n\t\t\tnewY += 0.5 - 0.5 * ( textureRatio / panelRatio );\n\t\t\tuv.y = newY;\n\t\t} else { // stretch on X\n\t\t\tfloat newX = uv.x * ( panelRatio / textureRatio );\n\t\t\tnewX += 0.5 - 0.5 * ( panelRatio / textureRatio );\n\t\t\tuv.x = newX;\n\t\t}\n\t}\n\treturn texture2D( u_texture, uv ).rgba;\n}\n\nvoid main() {\n\n\tfloat edgeDist = getEdgeDist();\n\tfloat change = fwidth( edgeDist );\n\n\tvec4 textureSample = sampleTexture();\n\tvec3 blendedColor = textureSample.rgb * u_color;\n\n\tfloat alpha = smoothstep( change, 0.0, edgeDist );\n\tfloat blendedOpacity = u_opacity * textureSample.a * alpha;\n\n\tvec4 frameColor = vec4( blendedColor, blendedOpacity );\n\n\tif ( u_borderWidth <= 0.0 ) {\n\t\tgl_FragColor = frameColor;\n\t} else {\n\t\tvec4 borderColor = vec4( u_borderColor, u_borderOpacity * alpha );\n\t\tfloat stp = smoothstep( edgeDist + change, edgeDist, u_borderWidth * -1.0 );\n\t\tgl_FragColor = mix( frameColor, borderColor, stp );\n\t}\n\n\t#include <clipping_planes_fragment>\n}\n";
        class Ld extends xu.Mesh {
          constructor(t) {
            super(new xu.PlaneGeometry(), t),
              (this.castShadow = !0),
              (this.receiveShadow = !0),
              (this.name = "MeshUI-Frame");
          }
        }
        let Rd = null;
        function Pd(...t) {
          if (!Rd) throw new Error("Cannot use mixins with Base null");
          let e = Rd;
          Rd = null;
          let n,
            s = t.length;
          for (; --s >= 0; ) (n = t[s]), (e = n(e));
          return e;
        }
        Pd.withBase = (t) => ((Rd = t), Pd);
        class Id extends Pd.withBase(xu.Object3D)(Hu, dd, Sd, Md) {
          constructor(t) {
            super(t),
              (this.isBlock = !0),
              (this.size = new xu.Vector2(1, 1)),
              (this.frame = new Ld(this.getBackgroundMaterial())),
              (this.frame.onBeforeRender = () => {
                this.updateClippingPlanes && this.updateClippingPlanes();
              }),
              this.add(this.frame),
              this.set(t);
          }
          parseParams() {
            const t = this.getBestFit();
            "none" != t && this.childrenTexts.length
              ? this.calculateBestFit(t)
              : this.childrenTexts.forEach((t) => {
                  t._fitFontSize = void 0;
                });
          }
          updateLayout() {
            const t = this.getWidth(),
              e = this.getHeight();
            t && e
              ? (this.size.set(t, e),
                this.frame.scale.set(t, e, 1),
                this.frame && this.updateBackgroundMaterial(),
                (this.frame.renderOrder = this.getParentsNumber()),
                this.autoLayout && this.setPosFromParentRecords(),
                this.childrenInlines.length && this.computeInlinesPosition(),
                this.computeChildrenPosition(),
                this.parentUI && (this.position.z = this.getOffset()))
              : console.warn(
                  "Block got no dimension from its parameters or from children parameters"
                );
          }
          updateInner() {
            this.parentUI && (this.position.z = this.getOffset()),
              this.frame && this.updateBackgroundMaterial();
          }
        }
        function Dd(t) {
          return class extends t {
            constructor(t) {
              super(t), (this.isInline = !0);
            }
          };
        }
        function Nd(t) {
          let e,
            n,
            s,
            i = 0;
          for (let r = 0; r < t.length; ++r) {
            const o = t[r];
            if (o.isInterleavedBufferAttribute)
              return (
                console.error(
                  "THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."
                ),
                null
              );
            if (
              (void 0 === e && (e = o.array.constructor),
              e !== o.array.constructor)
            )
              return (
                console.error(
                  "THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."
                ),
                null
              );
            if ((void 0 === n && (n = o.itemSize), n !== o.itemSize))
              return (
                console.error(
                  "THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."
                ),
                null
              );
            if ((void 0 === s && (s = o.normalized), s !== o.normalized))
              return (
                console.error(
                  "THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."
                ),
                null
              );
            i += o.array.length;
          }
          const r = new e(i);
          let o = 0;
          for (let e = 0; e < t.length; ++e)
            r.set(t[e].array, o), (o += t[e].array.length);
          return new xu.BufferAttribute(r, n, s);
        }
        class Od extends xu.PlaneBufferGeometry {
          constructor(t, e) {
            const n = t.glyph,
              s = t.fontSize;
            super(s, s),
              null === n.match(/\s/g)
                ? (-1 === e.info.charset.indexOf(n) &&
                    console.error(
                      `The character '${n}' is not included in the font characters set.`
                    ),
                  this.mapUVs(e, n),
                  this.transformGeometry(e, s, n, t))
                : (this.nullifyUVs(),
                  this.scale(0, 0, 1),
                  this.translate(0, s / 2, 0));
          }
          mapUVs(t, e) {
            const n = t.chars.find((t) => t.char === e),
              s = t.common,
              i = n.x / s.scaleW,
              r = (n.x + n.width) / s.scaleW,
              o = 1 - (n.y + n.height) / s.scaleH,
              a = 1 - n.y / s.scaleH,
              c = this.attributes.uv;
            for (let t = 0; t < c.count; t++) {
              let e = c.getX(t),
                n = c.getY(t);
              ([e, n] = (() => {
                switch (t) {
                  case 0:
                    return [i, a];
                  case 1:
                    return [r, a];
                  case 2:
                    return [i, o];
                  case 3:
                    return [r, o];
                }
              })()),
                c.setXY(t, e, n);
            }
          }
          nullifyUVs() {
            const t = this.attributes.uv;
            for (let e = 0; e < t.count; e++) t.setXY(e, 0, 0);
          }
          transformGeometry(t, e, n, s) {
            const i = t.chars.find((t) => t.char === n),
              r = t.common,
              o = i.height / r.lineHeight,
              a = (i.width * o) / i.height;
            this.scale(a, o, 1),
              this.translate(s.width / 2, s.height / 2 - s.anchor, 0);
          }
        }
        const kd = {
          getGlyphDimensions: function (t) {
            const e = t.font,
              n = t.fontSize,
              s = t.glyph,
              i = n / e.info.size,
              r = e.chars.find((t) => t.char === s);
            let o = r ? r.width * i : n / 3,
              a = r ? r.height * i : 0;
            0 === o && (o = r ? r.xadvance * i : n),
              0 === a && (a = 0.7 * n),
              "\n" === s && (o = 0);
            const c = r ? r.xadvance * i : o,
              u = r ? r.xoffset * i : 0;
            return {
              width: o,
              height: a,
              anchor: r
                ? ((r.yoffset + r.height - e.common.base) * n) /
                  e.common.lineHeight
                : 0,
              xadvance: c,
              xoffset: u,
            };
          },
          getGlyphPairKerning: function (t, e) {
            const n = t._kernings;
            return n[e] ? n[e] : 0;
          },
          buildText: function () {
            const t = [];
            this.inlines.forEach((e, n) => {
              (t[n] = new Od(e, this.getFontFamily())),
                t[n].translate(e.offsetX, e.offsetY, 0);
            });
            const e = (function (t, e = !1) {
              const n = null !== t[0].index,
                s = new Set(Object.keys(t[0].attributes)),
                i = new Set(Object.keys(t[0].morphAttributes)),
                r = {},
                o = {},
                a = t[0].morphTargetsRelative,
                c = new xu.BufferGeometry();
              let u = 0;
              for (let d = 0; d < t.length; ++d) {
                const l = t[d];
                let h = 0;
                if (n !== (null !== l.index))
                  return (
                    console.error(
                      "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
                        d +
                        ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."
                    ),
                    null
                  );
                for (const t in l.attributes) {
                  if (!s.has(t))
                    return (
                      console.error(
                        "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
                          d +
                          '. All geometries must have compatible attributes; make sure "' +
                          t +
                          '" attribute exists among all geometries, or in none of them.'
                      ),
                      null
                    );
                  void 0 === r[t] && (r[t] = []),
                    r[t].push(l.attributes[t]),
                    h++;
                }
                if (h !== s.size)
                  return (
                    console.error(
                      "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
                        d +
                        ". Make sure all geometries have the same number of attributes."
                    ),
                    null
                  );
                if (a !== l.morphTargetsRelative)
                  return (
                    console.error(
                      "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
                        d +
                        ". .morphTargetsRelative must be consistent throughout all geometries."
                    ),
                    null
                  );
                for (const t in l.morphAttributes) {
                  if (!i.has(t))
                    return (
                      console.error(
                        "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
                          d +
                          ".  .morphAttributes must be consistent throughout all geometries."
                      ),
                      null
                    );
                  void 0 === o[t] && (o[t] = []),
                    o[t].push(l.morphAttributes[t]);
                }
                if (
                  ((c.userData.mergedUserData =
                    c.userData.mergedUserData || []),
                  c.userData.mergedUserData.push(l.userData),
                  e)
                ) {
                  let t;
                  if (n) t = l.index.count;
                  else {
                    if (void 0 === l.attributes.position)
                      return (
                        console.error(
                          "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
                            d +
                            ". The geometry must have either an index or a position attribute"
                        ),
                        null
                      );
                    t = l.attributes.position.count;
                  }
                  c.addGroup(u, t, d), (u += t);
                }
              }
              if (n) {
                let e = 0;
                const n = [];
                for (let s = 0; s < t.length; ++s) {
                  const i = t[s].index;
                  for (let t = 0; t < i.count; ++t) n.push(i.getX(t) + e);
                  e += t[s].attributes.position.count;
                }
                c.setIndex(n);
              }
              for (const t in r) {
                const e = Nd(r[t]);
                if (!e)
                  return (
                    console.error(
                      "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " +
                        t +
                        " attribute."
                    ),
                    null
                  );
                c.setAttribute(t, e);
              }
              for (const t in o) {
                const e = o[t][0].length;
                if (0 === e) break;
                (c.morphAttributes = c.morphAttributes || {}),
                  (c.morphAttributes[t] = []);
                for (let n = 0; n < e; ++n) {
                  const e = [];
                  for (let s = 0; s < o[t].length; ++s) e.push(o[t][s][n]);
                  const s = Nd(e);
                  if (!s)
                    return (
                      console.error(
                        "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " +
                          t +
                          " morphAttribute."
                      ),
                      null
                    );
                  c.morphAttributes[t].push(s);
                }
              }
              return c;
            })(t);
            return new xu.Mesh(e, this.getFontMaterial());
          },
        };
        function Ud(t) {
          return class extends t {
            createText() {
              const t = this,
                e = (() => {
                  if ("MSDF" === this.getTextType())
                    return kd.buildText.call(this);
                  console.warn(
                    `'${this.getTextType()}' is not a supported text type.\nSee https://github.com/felixmariotto/three-mesh-ui/wiki/Using-a-custom-text-type`
                  );
                })();
              return (
                (e.renderOrder = 1 / 0),
                (e.onBeforeRender = function () {
                  t.updateClippingPlanes && t.updateClippingPlanes();
                }),
                e
              );
            }
            getGlyphDimensions(t) {
              if ("MSDF" === t.textType) return kd.getGlyphDimensions(t);
              console.warn(
                `'${t.textType}' is not a supported text type.\nSee https://github.com/felixmariotto/three-mesh-ui/wiki/Using-a-custom-text-type`
              );
            }
            getGlyphPairKerning(t, e, n) {
              if ("MSDF" === t) return kd.getGlyphPairKerning(e, n);
              console.warn(
                `'${t}' is not a supported text type.\nSee https://github.com/felixmariotto/three-mesh-ui/wiki/Using-a-custom-text-type`
              );
            }
          };
        }
        const zd = function t(e) {
          e.children.forEach((n) => {
            n.children.length > 0 && t(n),
              e.remove(n),
              wd.disposeOf(n),
              n.material && n.material.dispose(),
              n.geometry && n.geometry.dispose();
          }),
            (e.children = []);
        };
        class Fd extends Pd.withBase(xu.Object3D)(Dd, Ud, Sd, Md) {
          constructor(t) {
            super(t), (this.isText = !0), this.set(t);
          }
          parseParams() {
            this.calculateInlines(this._fitFontSize || this.getFontSize());
          }
          updateLayout() {
            zd(this),
              this.inlines &&
                ((this.textContent = this.createText()),
                this.updateTextMaterial(),
                this.add(this.textContent)),
              (this.position.z = this.getOffset());
          }
          updateInner() {
            (this.position.z = this.getOffset()),
              this.textContent && this.updateTextMaterial();
          }
          calculateInlines(t) {
            const e = this.content,
              n = this.getFontFamily(),
              s = this.getBreakOn(),
              i = this.getTextType(),
              r = this.getWhiteSpace();
            if (!n || "string" == typeof n)
              return void (
                yd.getFontOf(this) || console.warn("no font was found")
              );
            if (!this.content) return void (this.inlines = null);
            if (!i)
              return void console.error(
                "You must provide a 'textType' attribute so three-mesh-ui knows how to render your text.\n See https://github.com/felixmariotto/three-mesh-ui/wiki/Using-a-custom-text-type"
              );
            const o = Yu(e, r),
              a = Array.from ? Array.from(o) : String(o).split(""),
              c = t / n.info.size,
              u = n.common.lineHeight * c,
              d = n.common.base * c,
              l = a.map((e) => {
                const o = this.getGlyphDimensions({
                  textType: i,
                  glyph: e,
                  font: n,
                  fontSize: t,
                });
                let a = null;
                return (
                  r !== Wu &&
                    (s.includes(e) || e.match(/\s/g)) &&
                    (a = "possible"),
                  e.match(/\n/g) && (a = Ju(r)),
                  {
                    height: o.height,
                    width: o.width,
                    anchor: o.anchor,
                    xadvance: o.xadvance,
                    xoffset: o.xoffset,
                    lineBreak: a,
                    glyph: e,
                    fontSize: t,
                    lineHeight: u,
                    lineBase: d,
                  }
                );
              });
            if ("none" !== this.getFontKerning())
              for (let e = 1; e < l.length; e++) {
                const s = l[e],
                  r = l[e - 1].glyph + l[e].glyph,
                  o = this.getGlyphPairKerning(i, n, r);
                s.kerning = o * (t / n.info.size);
              }
            this.inlines = l;
          }
        }
        class Bd extends Pd.withBase(xu.Object3D)(Dd, Hu, dd, Sd, Md) {
          constructor(t) {
            super(t),
              (this.isInlineBlock = !0),
              (this.size = new xu.Vector2(1, 1)),
              (this.frame = new Ld(this.getBackgroundMaterial())),
              (this.frame.onBeforeRender = () => {
                this.updateClippingPlanes && this.updateClippingPlanes();
              }),
              this.add(this.frame),
              this.set(t);
          }
          parseParams() {
            this.width ||
              console.warn("inlineBlock has no width. Set to 0.3 by default"),
              this.height ||
                console.warn(
                  "inlineBlock has no height. Set to 0.3 by default"
                ),
              (this.inlines = [
                {
                  height: this.height || 0.3,
                  width: this.width || 0.3,
                  anchor: 0,
                  lineBreak: "possible",
                },
              ]);
          }
          updateLayout() {
            const t = this.getWidth(),
              e = this.getHeight();
            if (this.inlines) {
              const t = this.inlines[0];
              this.position.set(t.width / 2, t.height / 2, 0),
                (this.position.x += t.offsetX),
                (this.position.y += t.offsetY);
            }
            this.size.set(t, e),
              this.frame.scale.set(t, e, 1),
              this.frame && this.updateBackgroundMaterial(),
              (this.frame.renderOrder = this.getParentsNumber()),
              this.childrenInlines.length && this.computeInlinesPosition(),
              this.computeChildrenPosition(),
              (this.position.z = this.getOffset());
          }
          updateInner() {
            (this.position.z = this.getOffset()),
              this.frame && this.updateBackgroundMaterial();
          }
        }
        const Hd = [
            [
              [
                { width: 0.1, chars: [{ lowerCase: "a", upperCase: "A" }] },
                { width: 0.1, chars: [{ lowerCase: "z", upperCase: "Z" }] },
                { width: 0.1, chars: [{ lowerCase: "e", upperCase: "E" }] },
                { width: 0.1, chars: [{ lowerCase: "r", upperCase: "R" }] },
                { width: 0.1, chars: [{ lowerCase: "t", upperCase: "T" }] },
                { width: 0.1, chars: [{ lowerCase: "y", upperCase: "Y" }] },
                { width: 0.1, chars: [{ lowerCase: "u", upperCase: "U" }] },
                { width: 0.1, chars: [{ lowerCase: "i", upperCase: "I" }] },
                { width: 0.1, chars: [{ lowerCase: "o", upperCase: "O" }] },
                { width: 0.1, chars: [{ lowerCase: "p", upperCase: "P" }] },
              ],
              [
                { width: 0.1, chars: [{ lowerCase: "q", upperCase: "Q" }] },
                { width: 0.1, chars: [{ lowerCase: "s", upperCase: "S" }] },
                { width: 0.1, chars: [{ lowerCase: "d", upperCase: "D" }] },
                { width: 0.1, chars: [{ lowerCase: "f", upperCase: "F" }] },
                { width: 0.1, chars: [{ lowerCase: "g", upperCase: "G" }] },
                { width: 0.1, chars: [{ lowerCase: "h", upperCase: "H" }] },
                { width: 0.1, chars: [{ lowerCase: "j", upperCase: "J" }] },
                { width: 0.1, chars: [{ lowerCase: "k", upperCase: "K" }] },
                { width: 0.1, chars: [{ lowerCase: "l", upperCase: "L" }] },
                { width: 0.1, chars: [{ lowerCase: "m", upperCase: "M" }] },
              ],
              [
                { width: 0.2, command: "shift", chars: [{ icon: "shift" }] },
                { width: 0.1, chars: [{ lowerCase: "w", upperCase: "W" }] },
                { width: 0.1, chars: [{ lowerCase: "x", upperCase: "X" }] },
                { width: 0.1, chars: [{ lowerCase: "c", upperCase: "C" }] },
                { width: 0.1, chars: [{ lowerCase: "v", upperCase: "V" }] },
                { width: 0.1, chars: [{ lowerCase: "b", upperCase: "B" }] },
                { width: 0.1, chars: [{ lowerCase: "n", upperCase: "N" }] },
                {
                  width: 0.2,
                  command: "backspace",
                  chars: [{ icon: "backspace" }],
                },
              ],
              [
                {
                  width: 0.2,
                  command: "switch",
                  chars: [{ lowerCase: ".?12" }],
                },
                { width: 0.1, chars: [{ lowerCase: "," }] },
                { width: 0.4, command: "space", chars: [{ icon: "space" }] },
                { width: 0.1, chars: [{ lowerCase: "." }] },
                { width: 0.2, command: "enter", chars: [{ icon: "enter" }] },
              ],
            ],
            [
              [
                { width: 0.1, chars: [{ lowerCase: "1" }] },
                { width: 0.1, chars: [{ lowerCase: "2" }] },
                { width: 0.1, chars: [{ lowerCase: "3" }] },
                { width: 0.1, chars: [{ lowerCase: "4" }] },
                { width: 0.1, chars: [{ lowerCase: "5" }] },
                { width: 0.1, chars: [{ lowerCase: "6" }] },
                { width: 0.1, chars: [{ lowerCase: "7" }] },
                { width: 0.1, chars: [{ lowerCase: "8" }] },
                { width: 0.1, chars: [{ lowerCase: "9" }] },
                { width: 0.1, chars: [{ lowerCase: "0" }] },
              ],
              [
                { width: 0.1, chars: [{ lowerCase: "@" }] },
                { width: 0.1, chars: [{ lowerCase: "#" }] },
                { width: 0.1, chars: [{ lowerCase: "|" }] },
                { width: 0.1, chars: [{ lowerCase: "_" }] },
                { width: 0.1, chars: [{ lowerCase: "&" }] },
                { width: 0.1, chars: [{ lowerCase: "-" }] },
                { width: 0.1, chars: [{ lowerCase: "+" }] },
                { width: 0.1, chars: [{ lowerCase: "(" }] },
                { width: 0.1, chars: [{ lowerCase: ")" }] },
                { width: 0.1, chars: [{ lowerCase: "/" }] },
              ],
              [
                { width: 0.1, chars: [{ lowerCase: "=" }] },
                { width: 0.1, chars: [{ lowerCase: "*" }] },
                { width: 0.1, chars: [{ lowerCase: '"' }] },
                { width: 0.1, chars: [{ lowerCase: "'" }] },
                { width: 0.1, chars: [{ lowerCase: ":" }] },
                { width: 0.1, chars: [{ lowerCase: ";" }] },
                { width: 0.1, chars: [{ lowerCase: "!" }] },
                { width: 0.1, chars: [{ lowerCase: "?" }] },
                {
                  width: 0.2,
                  command: "backspace",
                  chars: [{ icon: "backspace" }],
                },
              ],
              [
                {
                  width: 0.2,
                  command: "switch",
                  chars: [{ lowerCase: ".?12" }],
                },
                { width: 0.1, chars: [{ lowerCase: "," }] },
                { width: 0.4, command: "space", chars: [{ icon: "space" }] },
                { width: 0.1, chars: [{ lowerCase: "." }] },
                { width: 0.2, command: "enter", chars: [{ icon: "enter" }] },
              ],
            ],
          ],
          Gd = [
            [
              [
                { width: 0.1, chars: [{ lowerCase: "q", upperCase: "Q" }] },
                { width: 0.1, chars: [{ lowerCase: "w", upperCase: "W" }] },
                { width: 0.1, chars: [{ lowerCase: "e", upperCase: "E" }] },
                { width: 0.1, chars: [{ lowerCase: "r", upperCase: "R" }] },
                { width: 0.1, chars: [{ lowerCase: "t", upperCase: "T" }] },
                { width: 0.1, chars: [{ lowerCase: "y", upperCase: "Y" }] },
                { width: 0.1, chars: [{ lowerCase: "u", upperCase: "U" }] },
                { width: 0.1, chars: [{ lowerCase: "i", upperCase: "I" }] },
                { width: 0.1, chars: [{ lowerCase: "o", upperCase: "O" }] },
                { width: 0.1, chars: [{ lowerCase: "p", upperCase: "P" }] },
              ],
              [
                { width: 0.1, chars: [{ lowerCase: "a", upperCase: "A" }] },
                { width: 0.1, chars: [{ lowerCase: "s", upperCase: "S" }] },
                { width: 0.1, chars: [{ lowerCase: "d", upperCase: "D" }] },
                { width: 0.1, chars: [{ lowerCase: "f", upperCase: "F" }] },
                { width: 0.1, chars: [{ lowerCase: "g", upperCase: "G" }] },
                { width: 0.1, chars: [{ lowerCase: "h", upperCase: "H" }] },
                { width: 0.1, chars: [{ lowerCase: "j", upperCase: "J" }] },
                { width: 0.1, chars: [{ lowerCase: "k", upperCase: "K" }] },
                { width: 0.1, chars: [{ lowerCase: "l", upperCase: "L" }] },
              ],
              [
                { width: 0.15, command: "shift", chars: [{ icon: "shift" }] },
                { width: 0.1, chars: [{ lowerCase: "z", upperCase: "Z" }] },
                { width: 0.1, chars: [{ lowerCase: "x", upperCase: "X" }] },
                { width: 0.1, chars: [{ lowerCase: "c", upperCase: "C" }] },
                { width: 0.1, chars: [{ lowerCase: "v", upperCase: "V" }] },
                { width: 0.1, chars: [{ lowerCase: "b", upperCase: "B" }] },
                { width: 0.1, chars: [{ lowerCase: "n", upperCase: "N" }] },
                { width: 0.1, chars: [{ lowerCase: "m", upperCase: "M" }] },
                {
                  width: 0.15,
                  command: "backspace",
                  chars: [{ icon: "backspace" }],
                },
              ],
              [
                {
                  width: 0.2,
                  command: "switch",
                  chars: [{ lowerCase: ".?12" }],
                },
                { width: 0.1, chars: [{ lowerCase: "," }] },
                { width: 0.4, command: "space", chars: [{ icon: "space" }] },
                { width: 0.1, chars: [{ lowerCase: "." }] },
                { width: 0.2, command: "enter", chars: [{ icon: "enter" }] },
              ],
            ],
            [
              [
                { width: 0.1, chars: [{ lowerCase: "1" }] },
                { width: 0.1, chars: [{ lowerCase: "2" }] },
                { width: 0.1, chars: [{ lowerCase: "3" }] },
                { width: 0.1, chars: [{ lowerCase: "4" }] },
                { width: 0.1, chars: [{ lowerCase: "5" }] },
                { width: 0.1, chars: [{ lowerCase: "6" }] },
                { width: 0.1, chars: [{ lowerCase: "7" }] },
                { width: 0.1, chars: [{ lowerCase: "8" }] },
                { width: 0.1, chars: [{ lowerCase: "9" }] },
                { width: 0.1, chars: [{ lowerCase: "0" }] },
              ],
              [
                { width: 0.1, chars: [{ lowerCase: "@" }] },
                { width: 0.1, chars: [{ lowerCase: "#" }] },
                { width: 0.1, chars: [{ lowerCase: "|" }] },
                { width: 0.1, chars: [{ lowerCase: "_" }] },
                { width: 0.1, chars: [{ lowerCase: "&" }] },
                { width: 0.1, chars: [{ lowerCase: "-" }] },
                { width: 0.1, chars: [{ lowerCase: "+" }] },
                { width: 0.1, chars: [{ lowerCase: "(" }] },
                { width: 0.1, chars: [{ lowerCase: ")" }] },
                { width: 0.1, chars: [{ lowerCase: "/" }] },
              ],
              [
                { width: 0.1, chars: [{ lowerCase: "=" }] },
                { width: 0.1, chars: [{ lowerCase: "*" }] },
                { width: 0.1, chars: [{ lowerCase: '"' }] },
                { width: 0.1, chars: [{ lowerCase: "'" }] },
                { width: 0.1, chars: [{ lowerCase: ":" }] },
                { width: 0.1, chars: [{ lowerCase: ";" }] },
                { width: 0.1, chars: [{ lowerCase: "!" }] },
                { width: 0.1, chars: [{ lowerCase: "?" }] },
                {
                  width: 0.2,
                  command: "backspace",
                  chars: [{ icon: "backspace" }],
                },
              ],
              [
                {
                  width: 0.2,
                  command: "switch",
                  chars: [{ lowerCase: ".?12" }],
                },
                { width: 0.1, chars: [{ lowerCase: "," }] },
                { width: 0.4, command: "space", chars: [{ icon: "space" }] },
                { width: 0.1, chars: [{ lowerCase: "." }] },
                { width: 0.2, command: "enter", chars: [{ icon: "enter" }] },
              ],
            ],
          ],
          Vd = [
            [
              [
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "й", upperCase: "Й" },
                    { lowerCase: "q", upperCase: "Q" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "ц", upperCase: "Ц" },
                    { lowerCase: "w", upperCase: "W" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "у", upperCase: "У" },
                    { lowerCase: "e", upperCase: "E" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "к", upperCase: "К" },
                    { lowerCase: "r", upperCase: "R" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "е", upperCase: "Е" },
                    { lowerCase: "t", upperCase: "T" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "н", upperCase: "Н" },
                    { lowerCase: "y", upperCase: "Y" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "г", upperCase: "Г" },
                    { lowerCase: "u", upperCase: "U" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "ш", upperCase: "Ш" },
                    { lowerCase: "i", upperCase: "I" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "щ", upperCase: "Щ" },
                    { lowerCase: "o", upperCase: "O" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "з", upperCase: "З" },
                    { lowerCase: "p", upperCase: "P" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "х", upperCase: "Х" },
                    { lowerCase: "{", upperCase: "[" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "ъ", upperCase: "Ъ" },
                    { lowerCase: "}", upperCase: "]" },
                  ],
                },
              ],
              [
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "ф", upperCase: "Ф" },
                    { lowerCase: "a", upperCase: "A" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "ы", upperCase: "Ы" },
                    { lowerCase: "s", upperCase: "S" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "в", upperCase: "В" },
                    { lowerCase: "d", upperCase: "D" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "а", upperCase: "А" },
                    { lowerCase: "f", upperCase: "F" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "п", upperCase: "П" },
                    { lowerCase: "g", upperCase: "G" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "р", upperCase: "Р" },
                    { lowerCase: "h", upperCase: "H" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "о", upperCase: "О" },
                    { lowerCase: "j", upperCase: "J" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "л", upperCase: "Л" },
                    { lowerCase: "k", upperCase: "K" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "д", upperCase: "Д" },
                    { lowerCase: "l", upperCase: "L" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "ж", upperCase: "Ж" },
                    { lowerCase: ":", upperCase: ";" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "э", upperCase: "Э" },
                    { lowerCase: '"', upperCase: "'" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "ё", upperCase: "Ё" },
                    { lowerCase: "|", upperCase: "\\" },
                  ],
                },
              ],
              [
                { width: 0.125, command: "shift", chars: [{ icon: "shift" }] },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "я", upperCase: "Я" },
                    { lowerCase: "z", upperCase: "Z" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "ч", upperCase: "Ч" },
                    { lowerCase: "x", upperCase: "X" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "с", upperCase: "С" },
                    { lowerCase: "c", upperCase: "C" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "м", upperCase: "М" },
                    { lowerCase: "v", upperCase: "V" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "и", upperCase: "И" },
                    { lowerCase: "b", upperCase: "B" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "т", upperCase: "Т" },
                    { lowerCase: "n", upperCase: "N" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "ь", upperCase: "Ь" },
                    { lowerCase: "m", upperCase: "M" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "б", upperCase: "Б" },
                    { lowerCase: ",", upperCase: "" },
                  ],
                },
                {
                  width: 1 / 12,
                  chars: [
                    { lowerCase: "ю", upperCase: "Ю" },
                    { lowerCase: ".", upperCase: "" },
                  ],
                },
                {
                  width: 0.125,
                  command: "backspace",
                  chars: [{ icon: "backspace" }],
                },
              ],
              [
                {
                  width: 0.15,
                  command: "switch-set",
                  chars: [{ lowerCase: "eng" }],
                },
                {
                  width: 0.15,
                  command: "switch",
                  chars: [{ lowerCase: ".?12" }],
                },
                { width: 0.4, command: "space", chars: [{ icon: "space" }] },
                { width: 0.1, chars: [{ lowerCase: "?" }] },
                { width: 0.2, command: "enter", chars: [{ icon: "enter" }] },
              ],
            ],
            [
              [
                { width: 0.1, chars: [{ lowerCase: "1" }] },
                { width: 0.1, chars: [{ lowerCase: "2" }] },
                { width: 0.1, chars: [{ lowerCase: "3" }] },
                { width: 0.1, chars: [{ lowerCase: "4" }] },
                { width: 0.1, chars: [{ lowerCase: "5" }] },
                { width: 0.1, chars: [{ lowerCase: "6" }] },
                { width: 0.1, chars: [{ lowerCase: "7" }] },
                { width: 0.1, chars: [{ lowerCase: "8" }] },
                { width: 0.1, chars: [{ lowerCase: "9" }] },
                { width: 0.1, chars: [{ lowerCase: "0" }] },
              ],
              [
                { width: 0.1, chars: [{ lowerCase: "@" }] },
                { width: 0.1, chars: [{ lowerCase: "#" }] },
                { width: 0.1, chars: [{ lowerCase: "|" }] },
                { width: 0.1, chars: [{ lowerCase: "_" }] },
                { width: 0.1, chars: [{ lowerCase: "&" }] },
                { width: 0.1, chars: [{ lowerCase: "-" }] },
                { width: 0.1, chars: [{ lowerCase: "+" }] },
                { width: 0.1, chars: [{ lowerCase: "(" }] },
                { width: 0.1, chars: [{ lowerCase: ")" }] },
                { width: 0.1, chars: [{ lowerCase: "/" }] },
              ],
              [
                { width: 0.1, chars: [{ lowerCase: "=" }] },
                { width: 0.1, chars: [{ lowerCase: "*" }] },
                { width: 0.1, chars: [{ lowerCase: '"' }] },
                { width: 0.1, chars: [{ lowerCase: "'" }] },
                { width: 0.1, chars: [{ lowerCase: ":" }] },
                { width: 0.1, chars: [{ lowerCase: ";" }] },
                { width: 0.1, chars: [{ lowerCase: "!" }] },
                { width: 0.1, chars: [{ lowerCase: "?" }] },
                {
                  width: 0.2,
                  command: "backspace",
                  chars: [{ icon: "backspace" }],
                },
              ],
              [
                {
                  width: 0.3,
                  command: "switch",
                  chars: [{ lowerCase: "АБВ" }],
                },
                { width: 0.4, command: "space", chars: [{ icon: "space" }] },
                { width: 0.1, chars: [{ lowerCase: "." }] },
                { width: 0.2, command: "enter", chars: [{ icon: "enter" }] },
              ],
            ],
          ],
          Wd = [
            [
              [
                { width: 1 / 11, chars: [{ lowerCase: "q", upperCase: "Q" }] },
                { width: 1 / 11, chars: [{ lowerCase: "w", upperCase: "W" }] },
                { width: 1 / 11, chars: [{ lowerCase: "e", upperCase: "E" }] },
                { width: 1 / 11, chars: [{ lowerCase: "r", upperCase: "R" }] },
                { width: 1 / 11, chars: [{ lowerCase: "t", upperCase: "T" }] },
                { width: 1 / 11, chars: [{ lowerCase: "z", upperCase: "Z" }] },
                { width: 1 / 11, chars: [{ lowerCase: "u", upperCase: "U" }] },
                { width: 1 / 11, chars: [{ lowerCase: "i", upperCase: "I" }] },
                { width: 1 / 11, chars: [{ lowerCase: "o", upperCase: "O" }] },
                { width: 1 / 11, chars: [{ lowerCase: "p", upperCase: "P" }] },
                { width: 1 / 11, chars: [{ lowerCase: "ü", upperCase: "Ü" }] },
              ],
              [
                { width: 1 / 11, chars: [{ lowerCase: "a", upperCase: "A" }] },
                { width: 1 / 11, chars: [{ lowerCase: "s", upperCase: "S" }] },
                { width: 1 / 11, chars: [{ lowerCase: "d", upperCase: "D" }] },
                { width: 1 / 11, chars: [{ lowerCase: "f", upperCase: "F" }] },
                { width: 1 / 11, chars: [{ lowerCase: "g", upperCase: "G" }] },
                { width: 1 / 11, chars: [{ lowerCase: "h", upperCase: "H" }] },
                { width: 1 / 11, chars: [{ lowerCase: "j", upperCase: "J" }] },
                { width: 1 / 11, chars: [{ lowerCase: "k", upperCase: "K" }] },
                { width: 1 / 11, chars: [{ lowerCase: "l", upperCase: "L" }] },
                { width: 1 / 11, chars: [{ lowerCase: "ö", upperCase: "Ö" }] },
                { width: 1 / 11, chars: [{ lowerCase: "ä", upperCase: "Ä" }] },
              ],
              [
                { width: 2 / 11, command: "shift", chars: [{ icon: "shift" }] },
                { width: 1 / 11, chars: [{ lowerCase: "y", upperCase: "Y" }] },
                { width: 1 / 11, chars: [{ lowerCase: "x", upperCase: "X" }] },
                { width: 1 / 11, chars: [{ lowerCase: "c", upperCase: "C" }] },
                { width: 1 / 11, chars: [{ lowerCase: "v", upperCase: "V" }] },
                { width: 1 / 11, chars: [{ lowerCase: "b", upperCase: "B" }] },
                { width: 1 / 11, chars: [{ lowerCase: "n", upperCase: "N" }] },
                { width: 1 / 11, chars: [{ lowerCase: "m", upperCase: "M" }] },
                {
                  width: 2 / 11,
                  command: "backspace",
                  chars: [{ icon: "backspace" }],
                },
              ],
              [
                {
                  width: 0.2,
                  command: "switch",
                  chars: [{ lowerCase: ".?12" }],
                },
                { width: 0.1, chars: [{ lowerCase: "," }] },
                { width: 0.4, command: "space", chars: [{ icon: "space" }] },
                { width: 0.1, chars: [{ lowerCase: "." }] },
                { width: 0.2, command: "enter", chars: [{ icon: "enter" }] },
              ],
            ],
            [
              [
                { width: 0.1, chars: [{ lowerCase: "1" }] },
                { width: 0.1, chars: [{ lowerCase: "2" }] },
                { width: 0.1, chars: [{ lowerCase: "3" }] },
                { width: 0.1, chars: [{ lowerCase: "4" }] },
                { width: 0.1, chars: [{ lowerCase: "5" }] },
                { width: 0.1, chars: [{ lowerCase: "6" }] },
                { width: 0.1, chars: [{ lowerCase: "7" }] },
                { width: 0.1, chars: [{ lowerCase: "8" }] },
                { width: 0.1, chars: [{ lowerCase: "9" }] },
                { width: 0.1, chars: [{ lowerCase: "0" }] },
              ],
              [
                { width: 0.1, chars: [{ lowerCase: "@" }] },
                { width: 0.1, chars: [{ lowerCase: "#" }] },
                { width: 0.1, chars: [{ lowerCase: "|" }] },
                { width: 0.1, chars: [{ lowerCase: "_" }] },
                { width: 0.1, chars: [{ lowerCase: "&" }] },
                { width: 0.1, chars: [{ lowerCase: "-" }] },
                { width: 0.1, chars: [{ lowerCase: "+" }] },
                { width: 0.1, chars: [{ lowerCase: "(" }] },
                { width: 0.1, chars: [{ lowerCase: ")" }] },
                { width: 0.1, chars: [{ lowerCase: "/" }] },
              ],
              [
                { width: 0.1, chars: [{ lowerCase: "=" }] },
                { width: 0.1, chars: [{ lowerCase: "*" }] },
                { width: 0.1, chars: [{ lowerCase: '"' }] },
                { width: 0.1, chars: [{ lowerCase: "'" }] },
                { width: 0.1, chars: [{ lowerCase: ":" }] },
                { width: 0.1, chars: [{ lowerCase: ";" }] },
                { width: 0.1, chars: [{ lowerCase: "!" }] },
                { width: 0.1, chars: [{ lowerCase: "?" }] },
                {
                  width: 0.2,
                  command: "backspace",
                  chars: [{ icon: "backspace" }],
                },
              ],
              [
                {
                  width: 0.2,
                  command: "switch",
                  chars: [{ lowerCase: ".?12" }],
                },
                { width: 0.1, chars: [{ lowerCase: "," }] },
                { width: 0.4, command: "space", chars: [{ icon: "space" }] },
                { width: 0.1, chars: [{ lowerCase: "." }] },
                { width: 0.2, command: "enter", chars: [{ icon: "enter" }] },
              ],
            ],
          ],
          jd = [
            [
              [
                { width: 0.1, chars: [{ lowerCase: "q", upperCase: "Q" }] },
                { width: 0.1, chars: [{ lowerCase: "w", upperCase: "W" }] },
                { width: 0.1, chars: [{ lowerCase: "e", upperCase: "E" }] },
                { width: 0.1, chars: [{ lowerCase: "r", upperCase: "R" }] },
                { width: 0.1, chars: [{ lowerCase: "t", upperCase: "T" }] },
                { width: 0.1, chars: [{ lowerCase: "y", upperCase: "Y" }] },
                { width: 0.1, chars: [{ lowerCase: "u", upperCase: "U" }] },
                { width: 0.1, chars: [{ lowerCase: "i", upperCase: "I" }] },
                { width: 0.1, chars: [{ lowerCase: "o", upperCase: "O" }] },
                { width: 0.1, chars: [{ lowerCase: "p", upperCase: "P" }] },
              ],
              [
                { width: 0.1, chars: [{ lowerCase: "a", upperCase: "A" }] },
                { width: 0.1, chars: [{ lowerCase: "s", upperCase: "S" }] },
                { width: 0.1, chars: [{ lowerCase: "d", upperCase: "D" }] },
                { width: 0.1, chars: [{ lowerCase: "f", upperCase: "F" }] },
                { width: 0.1, chars: [{ lowerCase: "g", upperCase: "G" }] },
                { width: 0.1, chars: [{ lowerCase: "h", upperCase: "H" }] },
                { width: 0.1, chars: [{ lowerCase: "j", upperCase: "J" }] },
                { width: 0.1, chars: [{ lowerCase: "k", upperCase: "K" }] },
                { width: 0.1, chars: [{ lowerCase: "l", upperCase: "L" }] },
                { width: 0.1, chars: [{ lowerCase: "ñ", upperCase: "Ñ" }] },
              ],
              [
                { width: 0.15, command: "shift", chars: [{ icon: "shift" }] },
                { width: 0.1, chars: [{ lowerCase: "z", upperCase: "Z" }] },
                { width: 0.1, chars: [{ lowerCase: "x", upperCase: "X" }] },
                { width: 0.1, chars: [{ lowerCase: "c", upperCase: "C" }] },
                { width: 0.1, chars: [{ lowerCase: "v", upperCase: "V" }] },
                { width: 0.1, chars: [{ lowerCase: "b", upperCase: "B" }] },
                { width: 0.1, chars: [{ lowerCase: "n", upperCase: "N" }] },
                { width: 0.1, chars: [{ lowerCase: "m", upperCase: "M" }] },
                {
                  width: 0.15,
                  command: "backspace",
                  chars: [{ icon: "backspace" }],
                },
              ],
              [
                {
                  width: 0.2,
                  command: "switch",
                  chars: [{ lowerCase: ".?12" }],
                },
                { width: 0.1, chars: [{ lowerCase: "," }] },
                { width: 0.4, command: "space", chars: [{ icon: "space" }] },
                { width: 0.1, chars: [{ lowerCase: "." }] },
                { width: 0.2, command: "enter", chars: [{ icon: "enter" }] },
              ],
            ],
            [
              [
                { width: 0.1, chars: [{ lowerCase: "1" }] },
                { width: 0.1, chars: [{ lowerCase: "2" }] },
                { width: 0.1, chars: [{ lowerCase: "3" }] },
                { width: 0.1, chars: [{ lowerCase: "4" }] },
                { width: 0.1, chars: [{ lowerCase: "5" }] },
                { width: 0.1, chars: [{ lowerCase: "6" }] },
                { width: 0.1, chars: [{ lowerCase: "7" }] },
                { width: 0.1, chars: [{ lowerCase: "8" }] },
                { width: 0.1, chars: [{ lowerCase: "9" }] },
                { width: 0.1, chars: [{ lowerCase: "0" }] },
              ],
              [
                { width: 0.1, chars: [{ lowerCase: "@" }] },
                { width: 0.1, chars: [{ lowerCase: "#" }] },
                { width: 0.1, chars: [{ lowerCase: "|" }] },
                { width: 0.1, chars: [{ lowerCase: "_" }] },
                { width: 0.1, chars: [{ lowerCase: "&" }] },
                { width: 0.1, chars: [{ lowerCase: "-" }] },
                { width: 0.1, chars: [{ lowerCase: "+" }] },
                { width: 0.1, chars: [{ lowerCase: "(" }] },
                { width: 0.1, chars: [{ lowerCase: ")" }] },
                { width: 0.1, chars: [{ lowerCase: "/" }] },
              ],
              [
                { width: 0.1, chars: [{ lowerCase: "=" }] },
                { width: 0.1, chars: [{ lowerCase: "*" }] },
                { width: 0.1, chars: [{ lowerCase: '"' }] },
                { width: 0.1, chars: [{ lowerCase: "'" }] },
                { width: 0.1, chars: [{ lowerCase: ":" }] },
                { width: 0.1, chars: [{ lowerCase: ";" }] },
                { width: 0.1, chars: [{ lowerCase: "!" }] },
                { width: 0.1, chars: [{ lowerCase: "?" }] },
                {
                  width: 0.2,
                  command: "backspace",
                  chars: [{ icon: "backspace" }],
                },
              ],
              [
                {
                  width: 0.2,
                  command: "switch",
                  chars: [{ lowerCase: ".?12" }],
                },
                { width: 0.1, chars: [{ lowerCase: "," }] },
                { width: 0.4, command: "space", chars: [{ icon: "space" }] },
                { width: 0.1, chars: [{ lowerCase: "." }] },
                { width: 0.2, command: "enter", chars: [{ icon: "enter" }] },
              ],
            ],
          ],
          Xd = [
            [
              [
                {
                  width: 0.1,
                  chars: [
                    { lowerCase: ";", upperCase: ":" },
                    { lowerCase: "q", upperCase: "Q" },
                  ],
                },
                {
                  width: 0.1,
                  chars: [
                    { lowerCase: "ς", upperCase: "ς" },
                    { lowerCase: "w", upperCase: "W" },
                  ],
                },
                {
                  width: 0.1,
                  chars: [
                    { lowerCase: "ε", upperCase: "Ε" },
                    { lowerCase: "e", upperCase: "E" },
                  ],
                },
                {
                  width: 0.1,
                  chars: [
                    { lowerCase: "ρ", upperCase: "Ρ" },
                    { lowerCase: "r", upperCase: "R" },
                  ],
                },
                {
                  width: 0.1,
                  chars: [
                    { lowerCase: "τ", upperCase: "Τ" },
                    { lowerCase: "t", upperCase: "T" },
                  ],
                },
                {
                  width: 0.1,
                  chars: [
                    { lowerCase: "υ", upperCase: "Υ" },
                    { lowerCase: "y", upperCase: "Y" },
                  ],
                },
                {
                  width: 0.1,
                  chars: [
                    { lowerCase: "θ", upperCase: "Θ" },
                    { lowerCase: "u", upperCase: "U" },
                  ],
                },
                {
                  width: 0.1,
                  chars: [
                    { lowerCase: "ι", upperCase: "Ι" },
                    { lowerCase: "i", upperCase: "I" },
                  ],
                },
                {
                  width: 0.1,
                  chars: [
                    { lowerCase: "ο", upperCase: "Ο" },
                    { lowerCase: "o", upperCase: "O" },
                  ],
                },
                {
                  width: 0.1,
                  chars: [
                    { lowerCase: "π", upperCase: "Π" },
                    { lowerCase: "p", upperCase: "P" },
                  ],
                },
              ],
              [
                {
                  width: 0.1,
                  chars: [
                    { lowerCase: "α", upperCase: "Α" },
                    { lowerCase: "a", upperCase: "A" },
                  ],
                },
                {
                  width: 0.1,
                  chars: [
                    { lowerCase: "σ", upperCase: "Σ" },
                    { lowerCase: "s", upperCase: "S" },
                  ],
                },
                {
                  width: 0.1,
                  chars: [
                    { lowerCase: "δ", upperCase: "Δ" },
                    { lowerCase: "d", upperCase: "D" },
                  ],
                },
                {
                  width: 0.1,
                  chars: [
                    { lowerCase: "φ", upperCase: "Φ" },
                    { lowerCase: "f", upperCase: "F" },
                  ],
                },
                {
                  width: 0.1,
                  chars: [
                    { lowerCase: "γ", upperCase: "Γ" },
                    { lowerCase: "g", upperCase: "G" },
                  ],
                },
                {
                  width: 0.1,
                  chars: [
                    { lowerCase: "η", upperCase: "Η" },
                    { lowerCase: "h", upperCase: "H" },
                  ],
                },
                {
                  width: 0.1,
                  chars: [
                    { lowerCase: "ξ", upperCase: "Ξ" },
                    { lowerCase: "j", upperCase: "J" },
                  ],
                },
                {
                  width: 0.1,
                  chars: [
                    { lowerCase: "κ", upperCase: "Κ" },
                    { lowerCase: "k", upperCase: "K" },
                  ],
                },
                {
                  width: 0.1,
                  chars: [
                    { lowerCase: "λ", upperCase: "Λ" },
                    { lowerCase: "l", upperCase: "L" },
                  ],
                },
              ],
              [
                { width: 0.15, command: "shift", chars: [{ icon: "shift" }] },
                {
                  width: 0.1,
                  chars: [
                    { lowerCase: "ζ", upperCase: "Ζ" },
                    { lowerCase: "z", upperCase: "Z" },
                  ],
                },
                {
                  width: 0.1,
                  chars: [
                    { lowerCase: "χ", upperCase: "Χ" },
                    { lowerCase: "x", upperCase: "X" },
                  ],
                },
                {
                  width: 0.1,
                  chars: [
                    { lowerCase: "ψ", upperCase: "Ψ" },
                    { lowerCase: "c", upperCase: "C" },
                  ],
                },
                {
                  width: 0.1,
                  chars: [
                    { lowerCase: "ω", upperCase: "Ω" },
                    { lowerCase: "v", upperCase: "V" },
                  ],
                },
                {
                  width: 0.1,
                  chars: [
                    { lowerCase: "β", upperCase: "Β" },
                    { lowerCase: "b", upperCase: "B" },
                  ],
                },
                {
                  width: 0.1,
                  chars: [
                    { lowerCase: "ν", upperCase: "Ν" },
                    { lowerCase: "n", upperCase: "N" },
                  ],
                },
                {
                  width: 0.1,
                  chars: [
                    { lowerCase: "μ", upperCase: "Μ" },
                    { lowerCase: "m", upperCase: "M" },
                  ],
                },
                {
                  width: 0.15,
                  command: "backspace",
                  chars: [{ icon: "backspace" }],
                },
              ],
              [
                {
                  width: 0.15,
                  command: "switch-set",
                  chars: [{ lowerCase: "eng" }],
                },
                {
                  width: 0.15,
                  command: "switch",
                  chars: [{ lowerCase: ".?12" }],
                },
                { width: 0.4, command: "space", chars: [{ icon: "space" }] },
                { width: 0.1, chars: [{ lowerCase: "?" }] },
                { width: 0.2, command: "enter", chars: [{ icon: "enter" }] },
              ],
            ],
            [
              [
                { width: 0.1, chars: [{ lowerCase: "1" }] },
                { width: 0.1, chars: [{ lowerCase: "2" }] },
                { width: 0.1, chars: [{ lowerCase: "3" }] },
                { width: 0.1, chars: [{ lowerCase: "4" }] },
                { width: 0.1, chars: [{ lowerCase: "5" }] },
                { width: 0.1, chars: [{ lowerCase: "6" }] },
                { width: 0.1, chars: [{ lowerCase: "7" }] },
                { width: 0.1, chars: [{ lowerCase: "8" }] },
                { width: 0.1, chars: [{ lowerCase: "9" }] },
                { width: 0.1, chars: [{ lowerCase: "0" }] },
              ],
              [
                { width: 0.1, chars: [{ lowerCase: "@" }] },
                { width: 0.1, chars: [{ lowerCase: "#" }] },
                { width: 0.1, chars: [{ lowerCase: "|" }] },
                { width: 0.1, chars: [{ lowerCase: "_" }] },
                { width: 0.1, chars: [{ lowerCase: "&" }] },
                { width: 0.1, chars: [{ lowerCase: "-" }] },
                { width: 0.1, chars: [{ lowerCase: "+" }] },
                { width: 0.1, chars: [{ lowerCase: "(" }] },
                { width: 0.1, chars: [{ lowerCase: ")" }] },
                { width: 0.1, chars: [{ lowerCase: "/" }] },
              ],
              [
                { width: 0.1, chars: [{ lowerCase: "=" }] },
                { width: 0.1, chars: [{ lowerCase: "*" }] },
                { width: 0.1, chars: [{ lowerCase: '"' }] },
                { width: 0.1, chars: [{ lowerCase: "'" }] },
                { width: 0.1, chars: [{ lowerCase: ":" }] },
                { width: 0.1, chars: [{ lowerCase: ";" }] },
                { width: 0.1, chars: [{ lowerCase: "!" }] },
                { width: 0.1, chars: [{ lowerCase: "?" }] },
                {
                  width: 0.2,
                  command: "backspace",
                  chars: [{ icon: "backspace" }],
                },
              ],
              [
                {
                  width: 0.2,
                  command: "switch",
                  chars: [{ lowerCase: ".?12" }],
                },
                { width: 0.1, chars: [{ lowerCase: "," }] },
                { width: 0.4, command: "space", chars: [{ icon: "space" }] },
                { width: 0.1, chars: [{ lowerCase: "." }] },
                { width: 0.2, command: "enter", chars: [{ icon: "enter" }] },
              ],
            ],
          ],
          qd = [
            [
              [
                { width: 1 / 11, chars: [{ lowerCase: "q", upperCase: "Q" }] },
                { width: 1 / 11, chars: [{ lowerCase: "w", upperCase: "W" }] },
                { width: 1 / 11, chars: [{ lowerCase: "e", upperCase: "E" }] },
                { width: 1 / 11, chars: [{ lowerCase: "r", upperCase: "R" }] },
                { width: 1 / 11, chars: [{ lowerCase: "t", upperCase: "T" }] },
                { width: 1 / 11, chars: [{ lowerCase: "y", upperCase: "Y" }] },
                { width: 1 / 11, chars: [{ lowerCase: "u", upperCase: "U" }] },
                { width: 1 / 11, chars: [{ lowerCase: "i", upperCase: "I" }] },
                { width: 1 / 11, chars: [{ lowerCase: "o", upperCase: "O" }] },
                { width: 1 / 11, chars: [{ lowerCase: "p", upperCase: "P" }] },
                { width: 1 / 11, chars: [{ lowerCase: "å", upperCase: "Å" }] },
              ],
              [
                { width: 1 / 11, chars: [{ lowerCase: "a", upperCase: "A" }] },
                { width: 1 / 11, chars: [{ lowerCase: "s", upperCase: "S" }] },
                { width: 1 / 11, chars: [{ lowerCase: "d", upperCase: "D" }] },
                { width: 1 / 11, chars: [{ lowerCase: "f", upperCase: "F" }] },
                { width: 1 / 11, chars: [{ lowerCase: "g", upperCase: "G" }] },
                { width: 1 / 11, chars: [{ lowerCase: "h", upperCase: "H" }] },
                { width: 1 / 11, chars: [{ lowerCase: "j", upperCase: "J" }] },
                { width: 1 / 11, chars: [{ lowerCase: "k", upperCase: "K" }] },
                { width: 1 / 11, chars: [{ lowerCase: "l", upperCase: "L" }] },
                { width: 1 / 11, chars: [{ lowerCase: "æ", upperCase: "Æ" }] },
                { width: 1 / 11, chars: [{ lowerCase: "ø", upperCase: "Ø" }] },
              ],
              [
                { width: 2 / 11, command: "shift", chars: [{ icon: "shift" }] },
                { width: 1 / 11, chars: [{ lowerCase: "z", upperCase: "Z" }] },
                { width: 1 / 11, chars: [{ lowerCase: "x", upperCase: "X" }] },
                { width: 1 / 11, chars: [{ lowerCase: "c", upperCase: "C" }] },
                { width: 1 / 11, chars: [{ lowerCase: "v", upperCase: "V" }] },
                { width: 1 / 11, chars: [{ lowerCase: "b", upperCase: "B" }] },
                { width: 1 / 11, chars: [{ lowerCase: "n", upperCase: "N" }] },
                { width: 1 / 11, chars: [{ lowerCase: "m", upperCase: "M" }] },
                {
                  width: 2 / 11,
                  command: "backspace",
                  chars: [{ icon: "backspace" }],
                },
              ],
              [
                {
                  width: 0.2,
                  command: "switch",
                  chars: [{ lowerCase: ".?12" }],
                },
                { width: 0.1, chars: [{ lowerCase: "," }] },
                { width: 0.4, command: "space", chars: [{ icon: "space" }] },
                { width: 0.1, chars: [{ lowerCase: "." }] },
                { width: 0.2, command: "enter", chars: [{ icon: "enter" }] },
              ],
            ],
            [
              [
                { width: 0.1, chars: [{ lowerCase: "1" }] },
                { width: 0.1, chars: [{ lowerCase: "2" }] },
                { width: 0.1, chars: [{ lowerCase: "3" }] },
                { width: 0.1, chars: [{ lowerCase: "4" }] },
                { width: 0.1, chars: [{ lowerCase: "5" }] },
                { width: 0.1, chars: [{ lowerCase: "6" }] },
                { width: 0.1, chars: [{ lowerCase: "7" }] },
                { width: 0.1, chars: [{ lowerCase: "8" }] },
                { width: 0.1, chars: [{ lowerCase: "9" }] },
                { width: 0.1, chars: [{ lowerCase: "0" }] },
              ],
              [
                { width: 0.1, chars: [{ lowerCase: "@" }] },
                { width: 0.1, chars: [{ lowerCase: "#" }] },
                { width: 0.1, chars: [{ lowerCase: "|" }] },
                { width: 0.1, chars: [{ lowerCase: "_" }] },
                { width: 0.1, chars: [{ lowerCase: "&" }] },
                { width: 0.1, chars: [{ lowerCase: "-" }] },
                { width: 0.1, chars: [{ lowerCase: "+" }] },
                { width: 0.1, chars: [{ lowerCase: "(" }] },
                { width: 0.1, chars: [{ lowerCase: ")" }] },
                { width: 0.1, chars: [{ lowerCase: "/" }] },
              ],
              [
                { width: 0.1, chars: [{ lowerCase: "=" }] },
                { width: 0.1, chars: [{ lowerCase: "*" }] },
                { width: 0.1, chars: [{ lowerCase: '"' }] },
                { width: 0.1, chars: [{ lowerCase: "'" }] },
                { width: 0.1, chars: [{ lowerCase: ":" }] },
                { width: 0.1, chars: [{ lowerCase: ";" }] },
                { width: 0.1, chars: [{ lowerCase: "!" }] },
                { width: 0.1, chars: [{ lowerCase: "?" }] },
                {
                  width: 0.2,
                  command: "backspace",
                  chars: [{ icon: "backspace" }],
                },
              ],
              [
                {
                  width: 0.2,
                  command: "switch",
                  chars: [{ lowerCase: ".?12" }],
                },
                { width: 0.1, chars: [{ lowerCase: "," }] },
                { width: 0.4, command: "space", chars: [{ icon: "space" }] },
                { width: 0.1, chars: [{ lowerCase: "." }] },
                { width: 0.2, command: "enter", chars: [{ icon: "enter" }] },
              ],
            ],
          ],
          Yd = new xu.TextureLoader();
        class Jd extends Pd.withBase(xu.Object3D)(Hu, Md) {
          constructor(t) {
            let e;
            if (
              (t || (t = {}),
              t.width || (t.width = 1),
              t.height || (t.height = 0.4),
              t.margin || (t.margin = 0.003),
              t.padding || (t.padding = 0.01),
              super(t),
              (this.currentPanel = 0),
              (this.isLowerCase = !0),
              (this.charsetCount = 1),
              t.language || navigator.language)
            )
              switch (t.language || navigator.language) {
                case "fr":
                case "fr-CH":
                case "fr-CA":
                  e = Hd;
                  break;
                case "ru":
                  (this.charsetCount = 2), (e = Vd);
                  break;
                case "de":
                case "de-DE":
                case "de-AT":
                case "de-LI":
                case "de-CH":
                  e = Wd;
                  break;
                case "es":
                case "es-419":
                case "es-AR":
                case "es-CL":
                case "es-CO":
                case "es-ES":
                case "es-CR":
                case "es-US":
                case "es-HN":
                case "es-MX":
                case "es-PE":
                case "es-UY":
                case "es-VE":
                  e = jd;
                  break;
                case "el":
                  (this.charsetCount = 2), (e = Xd);
                  break;
                case "nord":
                  e = qd;
                  break;
                default:
                  e = Gd;
              }
            else e = Gd;
            (this.keys = []),
              (this.panels = e.map((e) => {
                const n = t.height / e.length - 2 * t.margin,
                  s = new Id({
                    width: t.width + 2 * t.padding,
                    height: t.height + 2 * t.padding,
                    offset: 0,
                    padding: t.padding,
                    fontFamily: t.fontFamily,
                    fontTexture: t.fontTexture,
                    backgroundColor: t.backgroundColor,
                    backgroundOpacity: t.backgroundOpacity,
                  });
                return (
                  (s.charset = 0),
                  s.add(
                    ...e.map((e) => {
                      const i = new Id({
                        width: t.width,
                        height: n,
                        margin: t.margin,
                        contentDirection: "row",
                        justifyContent: "center",
                      });
                      i.frame.visible = !1;
                      const r = [];
                      return (
                        e.forEach((e) => {
                          const i = new Id({
                              width: t.width * e.width - 2 * t.margin,
                              height: n,
                              margin: t.margin,
                              justifyContent: "center",
                              offset: 0,
                            }),
                            o =
                              e.chars[s.charset].lowerCase ||
                              e.chars[s.charset].icon ||
                              "undif";
                          if (
                            ("enter" === o && t.enterTexture) ||
                            ("shift" === o && t.shiftTexture) ||
                            ("backspace" === o && t.backspaceTexture)
                          ) {
                            const e = (() => {
                              switch (o) {
                                case "backspace":
                                  return t.backspaceTexture;
                                case "enter":
                                  return t.enterTexture;
                                case "shift":
                                  return t.shiftTexture;
                                default:
                                  console.warn(
                                    "There is no icon image for this key"
                                  );
                              }
                            })();
                            Yd.load(e, (t) => {
                              i.add(
                                new Bd({
                                  width: 0.65 * i.width,
                                  height: 0.65 * i.height,
                                  backgroundSize: "contain",
                                  backgroundTexture: t,
                                })
                              );
                            });
                          } else i.add(new Fd({ content: o, offset: 0 }));
                          (i.type = "Key"),
                            (i.info = e),
                            (i.info.input = o),
                            (i.panel = s),
                            r.push(i),
                            this.keys.push(i);
                        }),
                        i.add(...r),
                        i
                      );
                    })
                  ),
                  s
                );
              })),
              this.add(this.panels[0]),
              this.set(t);
          }
          setNextPanel() {
            this.panels.forEach((t) => {
              this.remove(t);
            }),
              (this.currentPanel =
                (this.currentPanel + 1) % this.panels.length),
              this.add(this.panels[this.currentPanel]),
              this.update(!0, !0, !0);
          }
          setNextCharset() {
            (this.panels[this.currentPanel].charset =
              (this.panels[this.currentPanel].charset + 1) % this.charsetCount),
              this.keys.forEach((t) => {
                if (!this.panels[this.currentPanel].getObjectById(t.id)) return;
                const e = t.info.chars[t.panel.charset] || t.info.chars[0],
                  n =
                    this.isLowerCase || !e.upperCase
                      ? e.lowerCase
                      : e.upperCase;
                if (!t.childrenTexts.length) return;
                const s = t.childrenTexts[0];
                (t.info.input = n), s.set({ content: n }), s.update(!0, !0, !0);
              });
          }
          toggleCase() {
            (this.isLowerCase = !this.isLowerCase),
              this.keys.forEach((t) => {
                const e = t.info.chars[t.panel.charset] || t.info.chars[0],
                  n =
                    this.isLowerCase || !e.upperCase
                      ? e.lowerCase
                      : e.upperCase;
                if (!t.childrenTexts.length) return;
                const s = t.childrenTexts[0];
                (t.info.input = n), s.set({ content: n }), s.update(!0, !0, !0);
              });
          }
          parseParams() {}
          updateLayout() {}
          updateInner() {}
        }
        const Zd = () => wd.update(),
          $d = {
            Block: Id,
            Text: Fd,
            InlineBlock: Bd,
            Keyboard: Jd,
            FontLibrary: yd,
            update: Zd,
            TextAlign: gu,
            Whitespace: pu,
            JustifyContent: mu,
            AlignItems: fu,
            ContentDirection: hu,
          };
        void 0 !== n.g && (n.g.ThreeMeshUI = $d);
        const Kd = $d;
        var Qd = lu.gO,
          tl = lu.xv,
          el = lu.Vx;
        const nl = JSON.parse(
          '{"pages":["Roboto-Regular.png"],"chars":[{"id":40,"index":12,"char":"(","width":15,"height":47,"xoffset":1,"yoffset":0,"xadvance":14,"chnl":15,"x":0,"y":0,"page":0},{"id":41,"index":13,"char":")","width":15,"height":47,"xoffset":-1,"yoffset":0,"xadvance":15,"chnl":15,"x":0,"y":48,"page":0},{"id":91,"index":63,"char":"[","width":12,"height":45,"xoffset":1,"yoffset":0,"xadvance":11,"chnl":15,"x":0,"y":96,"page":0},{"id":93,"index":65,"char":"]","width":12,"height":45,"xoffset":-2,"yoffset":0,"xadvance":11,"chnl":15,"x":0,"y":142,"page":0},{"id":123,"index":95,"char":"{","width":16,"height":44,"xoffset":-1,"yoffset":1,"xadvance":14,"chnl":15,"x":0,"y":188,"page":0},{"id":125,"index":97,"char":"}","width":16,"height":44,"xoffset":-2,"yoffset":1,"xadvance":14,"chnl":15,"x":13,"y":96,"page":0},{"id":1092,"index":247,"char":"ф","width":30,"height":44,"xoffset":0,"yoffset":3,"xadvance":30,"chnl":15,"x":13,"y":141,"page":0},{"id":197,"index":644,"char":"Å","width":30,"height":44,"xoffset":-1,"yoffset":-6,"xadvance":27,"chnl":15,"x":16,"y":0,"page":0},{"id":106,"index":78,"char":"j","width":12,"height":43,"xoffset":-3,"yoffset":4,"xadvance":10,"chnl":15,"x":16,"y":45,"page":0},{"id":36,"index":8,"char":"$","width":23,"height":43,"xoffset":0,"yoffset":-1,"xadvance":24,"chnl":15,"x":29,"y":45,"page":0},{"id":64,"index":36,"char":"@","width":37,"height":43,"xoffset":0,"yoffset":5,"xadvance":38,"chnl":15,"x":47,"y":0,"page":0},{"id":198,"index":129,"char":"Æ","width":43,"height":34,"xoffset":-2,"yoffset":4,"xadvance":39,"chnl":15,"x":30,"y":89,"page":0},{"id":958,"index":197,"char":"ξ","width":21,"height":42,"xoffset":0,"yoffset":4,"xadvance":21,"chnl":15,"x":53,"y":44,"page":0},{"id":950,"index":192,"char":"ζ","width":22,"height":42,"xoffset":0,"yoffset":4,"xadvance":22,"chnl":15,"x":0,"y":233,"page":0},{"id":946,"index":188,"char":"β","width":23,"height":42,"xoffset":1,"yoffset":4,"xadvance":25,"chnl":15,"x":17,"y":186,"page":0},{"id":1044,"index":217,"char":"Д","width":33,"height":41,"xoffset":-1,"yoffset":4,"xadvance":32,"chnl":15,"x":0,"y":276,"page":0},{"id":1025,"index":941,"char":"Ё","width":23,"height":41,"xoffset":1,"yoffset":-3,"xadvance":24,"chnl":15,"x":23,"y":229,"page":0},{"id":1046,"index":218,"char":"Ж","width":41,"height":34,"xoffset":-1,"yoffset":4,"xadvance":38,"chnl":15,"x":41,"y":186,"page":0},{"id":1049,"index":954,"char":"Й","width":27,"height":41,"xoffset":2,"yoffset":-3,"xadvance":30,"chnl":15,"x":44,"y":124,"page":0},{"id":1062,"index":224,"char":"Ц","width":30,"height":41,"xoffset":2,"yoffset":4,"xadvance":31,"chnl":15,"x":72,"y":124,"page":0},{"id":1065,"index":227,"char":"Щ","width":39,"height":41,"xoffset":2,"yoffset":4,"xadvance":41,"chnl":15,"x":75,"y":44,"page":0},{"id":220,"index":664,"char":"Ü","width":26,"height":41,"xoffset":1,"yoffset":-3,"xadvance":27,"chnl":15,"x":85,"y":0,"page":0},{"id":214,"index":660,"char":"Ö","width":28,"height":41,"xoffset":0,"yoffset":-3,"xadvance":29,"chnl":15,"x":112,"y":0,"page":0},{"id":196,"index":643,"char":"Ä","width":30,"height":41,"xoffset":-1,"yoffset":-3,"xadvance":27,"chnl":15,"x":0,"y":318,"page":0},{"id":209,"index":655,"char":"Ñ","width":27,"height":41,"xoffset":1,"yoffset":-3,"xadvance":30,"chnl":15,"x":0,"y":360,"page":0},{"id":81,"index":53,"char":"Q","width":28,"height":39,"xoffset":0,"yoffset":4,"xadvance":29,"chnl":15,"x":0,"y":402,"page":0},{"id":87,"index":59,"char":"W","width":39,"height":34,"xoffset":-1,"yoffset":4,"xadvance":37,"chnl":15,"x":74,"y":87,"page":0},{"id":124,"index":96,"char":"|","width":7,"height":39,"xoffset":2,"yoffset":4,"xadvance":10,"chnl":15,"x":28,"y":360,"page":0},{"id":229,"index":671,"char":"å","width":22,"height":38,"xoffset":0,"yoffset":1,"xadvance":23,"chnl":15,"x":31,"y":318,"page":0},{"id":216,"index":131,"char":"Ø","width":28,"height":37,"xoffset":0,"yoffset":3,"xadvance":29,"chnl":15,"x":34,"y":271,"page":0},{"id":100,"index":72,"char":"d","width":23,"height":36,"xoffset":0,"yoffset":3,"xadvance":24,"chnl":15,"x":47,"y":221,"page":0},{"id":102,"index":74,"char":"f","width":17,"height":36,"xoffset":-1,"yoffset":2,"xadvance":15,"chnl":15,"x":0,"y":442,"page":0},{"id":104,"index":76,"char":"h","width":21,"height":36,"xoffset":1,"yoffset":3,"xadvance":23,"chnl":15,"x":18,"y":442,"page":0},{"id":107,"index":79,"char":"k","width":22,"height":36,"xoffset":1,"yoffset":3,"xadvance":21,"chnl":15,"x":29,"y":400,"page":0},{"id":108,"index":80,"char":"l","width":8,"height":36,"xoffset":1,"yoffset":3,"xadvance":10,"chnl":15,"x":36,"y":357,"page":0},{"id":98,"index":70,"char":"b","width":23,"height":36,"xoffset":1,"yoffset":3,"xadvance":24,"chnl":15,"x":45,"y":357,"page":0},{"id":47,"index":19,"char":"/","width":20,"height":36,"xoffset":-2,"yoffset":4,"xadvance":17,"chnl":15,"x":54,"y":309,"page":0},{"id":92,"index":64,"char":"\\\\","width":20,"height":36,"xoffset":-1,"yoffset":4,"xadvance":17,"chnl":15,"x":63,"y":258,"page":0},{"id":1073,"index":234,"char":"б","width":24,"height":36,"xoffset":0,"yoffset":2,"xadvance":23,"chnl":15,"x":71,"y":221,"page":0},{"id":1060,"index":223,"char":"Ф","width":33,"height":36,"xoffset":0,"yoffset":3,"xadvance":32,"chnl":15,"x":83,"y":166,"page":0},{"id":1064,"index":226,"char":"Ш","width":36,"height":34,"xoffset":2,"yoffset":4,"xadvance":40,"chnl":15,"x":103,"y":122,"page":0},{"id":1070,"index":232,"char":"Ю","width":36,"height":35,"xoffset":2,"yoffset":4,"xadvance":38,"chnl":15,"x":114,"y":86,"page":0},{"id":948,"index":190,"char":"δ","width":24,"height":36,"xoffset":0,"yoffset":2,"xadvance":24,"chnl":15,"x":115,"y":42,"page":0},{"id":966,"index":204,"char":"φ","width":30,"height":36,"xoffset":0,"yoffset":12,"xadvance":30,"chnl":15,"x":140,"y":42,"page":0},{"id":968,"index":205,"char":"ψ","width":30,"height":36,"xoffset":0,"yoffset":12,"xadvance":29,"chnl":15,"x":141,"y":0,"page":0},{"id":230,"index":134,"char":"æ","width":36,"height":27,"xoffset":0,"yoffset":11,"xadvance":35,"chnl":15,"x":0,"y":479,"page":0},{"id":121,"index":93,"char":"y","width":23,"height":35,"xoffset":-2,"yoffset":12,"xadvance":20,"chnl":15,"x":40,"y":437,"page":0},{"id":112,"index":84,"char":"p","width":23,"height":35,"xoffset":1,"yoffset":11,"xadvance":24,"chnl":15,"x":40,"y":473,"page":0},{"id":113,"index":85,"char":"q","width":23,"height":35,"xoffset":0,"yoffset":11,"xadvance":24,"chnl":15,"x":52,"y":394,"page":0},{"id":103,"index":75,"char":"g","width":23,"height":35,"xoffset":0,"yoffset":11,"xadvance":24,"chnl":15,"x":69,"y":346,"page":0},{"id":109,"index":81,"char":"m","width":35,"height":27,"xoffset":1,"yoffset":11,"xadvance":37,"chnl":15,"x":75,"y":295,"page":0},{"id":79,"index":51,"char":"O","width":28,"height":35,"xoffset":0,"yoffset":4,"xadvance":29,"chnl":15,"x":84,"y":258,"page":0},{"id":83,"index":55,"char":"S","width":26,"height":35,"xoffset":0,"yoffset":4,"xadvance":25,"chnl":15,"x":96,"y":203,"page":0},{"id":71,"index":43,"char":"G","width":27,"height":35,"xoffset":1,"yoffset":4,"xadvance":29,"chnl":15,"x":117,"y":157,"page":0},{"id":67,"index":39,"char":"C","width":27,"height":35,"xoffset":0,"yoffset":4,"xadvance":27,"chnl":15,"x":64,"y":430,"page":0},{"id":56,"index":28,"char":"8","width":23,"height":35,"xoffset":0,"yoffset":4,"xadvance":24,"chnl":15,"x":64,"y":466,"page":0},{"id":51,"index":23,"char":"3","width":23,"height":35,"xoffset":0,"yoffset":4,"xadvance":24,"chnl":15,"x":88,"y":466,"page":0},{"id":48,"index":20,"char":"0","width":23,"height":35,"xoffset":0,"yoffset":4,"xadvance":24,"chnl":15,"x":76,"y":382,"page":0},{"id":37,"index":9,"char":"%","width":31,"height":35,"xoffset":0,"yoffset":4,"xadvance":31,"chnl":15,"x":92,"y":418,"page":0},{"id":8364,"index":413,"char":"€","width":24,"height":35,"xoffset":0,"yoffset":4,"xadvance":24,"chnl":15,"x":93,"y":323,"page":0},{"id":38,"index":10,"char":"&","width":28,"height":35,"xoffset":0,"yoffset":4,"xadvance":26,"chnl":15,"x":112,"y":454,"page":0},{"id":1105,"index":971,"char":"ё","width":23,"height":35,"xoffset":0,"yoffset":4,"xadvance":22,"chnl":15,"x":100,"y":359,"page":0},{"id":1078,"index":238,"char":"ж","width":35,"height":26,"xoffset":-2,"yoffset":12,"xadvance":32,"chnl":15,"x":111,"y":294,"page":0},{"id":1047,"index":219,"char":"З","width":26,"height":35,"xoffset":0,"yoffset":4,"xadvance":25,"chnl":15,"x":118,"y":321,"page":0},{"id":1054,"index":957,"char":"О","width":28,"height":35,"xoffset":0,"yoffset":4,"xadvance":29,"chnl":15,"x":113,"y":239,"page":0},{"id":1088,"index":967,"char":"р","width":23,"height":35,"xoffset":1,"yoffset":11,"xadvance":24,"chnl":15,"x":123,"y":193,"page":0},{"id":1057,"index":960,"char":"С","width":27,"height":35,"xoffset":0,"yoffset":4,"xadvance":27,"chnl":15,"x":142,"y":229,"page":0},{"id":1091,"index":969,"char":"у","width":23,"height":35,"xoffset":-2,"yoffset":12,"xadvance":20,"chnl":15,"x":145,"y":122,"page":0},{"id":1097,"index":251,"char":"щ","width":35,"height":33,"xoffset":1,"yoffset":12,"xadvance":35,"chnl":15,"x":145,"y":158,"page":0},{"id":1069,"index":231,"char":"Э","width":27,"height":35,"xoffset":1,"yoffset":4,"xadvance":28,"chnl":15,"x":147,"y":192,"page":0},{"id":252,"index":691,"char":"ü","width":21,"height":35,"xoffset":1,"yoffset":4,"xadvance":23,"chnl":15,"x":151,"y":79,"page":0},{"id":246,"index":687,"char":"ö","width":24,"height":35,"xoffset":0,"yoffset":4,"xadvance":24,"chnl":15,"x":171,"y":37,"page":0},{"id":228,"index":670,"char":"ä","width":22,"height":35,"xoffset":0,"yoffset":4,"xadvance":23,"chnl":15,"x":172,"y":0,"page":0},{"id":241,"index":682,"char":"ñ","width":21,"height":35,"xoffset":1,"yoffset":3,"xadvance":23,"chnl":15,"x":195,"y":0,"page":0},{"id":961,"index":199,"char":"ρ","width":23,"height":35,"xoffset":1,"yoffset":11,"xadvance":24,"chnl":15,"x":169,"y":115,"page":0},{"id":952,"index":194,"char":"θ","width":23,"height":35,"xoffset":1,"yoffset":4,"xadvance":24,"chnl":15,"x":173,"y":73,"page":0},{"id":947,"index":189,"char":"γ","width":23,"height":35,"xoffset":-1,"yoffset":12,"xadvance":21,"chnl":15,"x":196,"y":36,"page":0},{"id":951,"index":193,"char":"η","width":22,"height":35,"xoffset":1,"yoffset":11,"xadvance":24,"chnl":15,"x":217,"y":0,"page":0},{"id":955,"index":196,"char":"λ","width":25,"height":35,"xoffset":-1,"yoffset":3,"xadvance":23,"chnl":15,"x":124,"y":357,"page":0},{"id":967,"index":935,"char":"χ","width":26,"height":35,"xoffset":0,"yoffset":12,"xadvance":21,"chnl":15,"x":145,"y":321,"page":0},{"id":956,"index":933,"char":"μ","width":21,"height":35,"xoffset":1,"yoffset":12,"xadvance":24,"chnl":15,"x":147,"y":265,"page":0},{"id":920,"index":179,"char":"Θ","width":28,"height":35,"xoffset":0,"yoffset":4,"xadvance":29,"chnl":15,"x":169,"y":265,"page":0},{"id":927,"index":919,"char":"Ο","width":28,"height":35,"xoffset":0,"yoffset":4,"xadvance":29,"chnl":15,"x":170,"y":228,"page":0},{"id":105,"index":77,"char":"i","width":8,"height":34,"xoffset":1,"yoffset":4,"xadvance":10,"chnl":15,"x":175,"y":192,"page":0},{"id":119,"index":91,"char":"w","width":34,"height":26,"xoffset":-1,"yoffset":12,"xadvance":32,"chnl":15,"x":181,"y":151,"page":0},{"id":65,"index":37,"char":"A","width":30,"height":34,"xoffset":-1,"yoffset":4,"xadvance":27,"chnl":15,"x":193,"y":109,"page":0},{"id":90,"index":62,"char":"Z","width":26,"height":34,"xoffset":0,"yoffset":4,"xadvance":25,"chnl":15,"x":197,"y":72,"page":0},{"id":69,"index":41,"char":"E","width":23,"height":34,"xoffset":1,"yoffset":4,"xadvance":24,"chnl":15,"x":220,"y":36,"page":0},{"id":82,"index":54,"char":"R","width":26,"height":34,"xoffset":1,"yoffset":4,"xadvance":26,"chnl":15,"x":240,"y":0,"page":0},{"id":84,"index":56,"char":"T","width":27,"height":34,"xoffset":-1,"yoffset":4,"xadvance":25,"chnl":15,"x":184,"y":178,"page":0},{"id":89,"index":61,"char":"Y","width":29,"height":34,"xoffset":-2,"yoffset":4,"xadvance":25,"chnl":15,"x":124,"y":393,"page":0},{"id":85,"index":57,"char":"U","width":26,"height":34,"xoffset":1,"yoffset":4,"xadvance":27,"chnl":15,"x":150,"y":357,"page":0},{"id":73,"index":45,"char":"I","width":8,"height":34,"xoffset":2,"yoffset":4,"xadvance":11,"chnl":15,"x":172,"y":301,"page":0},{"id":80,"index":52,"char":"P","width":25,"height":34,"xoffset":1,"yoffset":4,"xadvance":26,"chnl":15,"x":141,"y":428,"page":0},{"id":68,"index":40,"char":"D","width":26,"height":34,"xoffset":1,"yoffset":4,"xadvance":28,"chnl":15,"x":154,"y":392,"page":0},{"id":70,"index":42,"char":"F","width":22,"height":34,"xoffset":1,"yoffset":4,"xadvance":23,"chnl":15,"x":141,"y":463,"page":0},{"id":72,"index":44,"char":"H","width":27,"height":34,"xoffset":1,"yoffset":4,"xadvance":30,"chnl":15,"x":164,"y":463,"page":0},{"id":74,"index":46,"char":"J","width":23,"height":34,"xoffset":-1,"yoffset":4,"xadvance":23,"chnl":15,"x":167,"y":427,"page":0},{"id":75,"index":47,"char":"K","width":27,"height":34,"xoffset":1,"yoffset":4,"xadvance":26,"chnl":15,"x":177,"y":336,"page":0},{"id":76,"index":48,"char":"L","width":22,"height":34,"xoffset":1,"yoffset":4,"xadvance":23,"chnl":15,"x":181,"y":301,"page":0},{"id":77,"index":49,"char":"M","width":34,"height":34,"xoffset":1,"yoffset":4,"xadvance":37,"chnl":15,"x":198,"y":264,"page":0},{"id":88,"index":60,"char":"X","width":28,"height":34,"xoffset":-1,"yoffset":4,"xadvance":26,"chnl":15,"x":204,"y":299,"page":0},{"id":86,"index":58,"char":"V","width":30,"height":34,"xoffset":-1,"yoffset":4,"xadvance":27,"chnl":15,"x":199,"y":213,"page":0},{"id":66,"index":38,"char":"B","width":24,"height":34,"xoffset":1,"yoffset":4,"xadvance":26,"chnl":15,"x":212,"y":178,"page":0},{"id":78,"index":50,"char":"N","width":27,"height":34,"xoffset":1,"yoffset":4,"xadvance":30,"chnl":15,"x":230,"y":213,"page":0},{"id":55,"index":27,"char":"7","width":24,"height":34,"xoffset":0,"yoffset":4,"xadvance":24,"chnl":15,"x":181,"y":371,"page":0},{"id":57,"index":29,"char":"9","width":23,"height":34,"xoffset":0,"yoffset":4,"xadvance":24,"chnl":15,"x":205,"y":334,"page":0},{"id":52,"index":24,"char":"4","width":26,"height":34,"xoffset":-1,"yoffset":4,"xadvance":24,"chnl":15,"x":191,"y":406,"page":0},{"id":53,"index":25,"char":"5","width":23,"height":34,"xoffset":1,"yoffset":4,"xadvance":24,"chnl":15,"x":206,"y":369,"page":0},{"id":54,"index":26,"char":"6","width":23,"height":34,"xoffset":1,"yoffset":4,"xadvance":24,"chnl":15,"x":229,"y":334,"page":0},{"id":49,"index":21,"char":"1","width":15,"height":34,"xoffset":1,"yoffset":4,"xadvance":24,"chnl":15,"x":192,"y":441,"page":0},{"id":50,"index":22,"char":"2","width":24,"height":34,"xoffset":0,"yoffset":4,"xadvance":24,"chnl":15,"x":192,"y":476,"page":0},{"id":33,"index":5,"char":"!","width":8,"height":34,"xoffset":1,"yoffset":4,"xadvance":11,"chnl":15,"x":208,"y":441,"page":0},{"id":63,"index":35,"char":"?","width":21,"height":34,"xoffset":0,"yoffset":4,"xadvance":20,"chnl":15,"x":217,"y":441,"page":0},{"id":163,"index":101,"char":"£","width":25,"height":34,"xoffset":0,"yoffset":4,"xadvance":24,"chnl":15,"x":218,"y":404,"page":0},{"id":35,"index":7,"char":"#","width":27,"height":34,"xoffset":0,"yoffset":4,"xadvance":26,"chnl":15,"x":230,"y":369,"page":0},{"id":1040,"index":950,"char":"А","width":30,"height":34,"xoffset":-1,"yoffset":4,"xadvance":27,"chnl":15,"x":217,"y":476,"page":0},{"id":1041,"index":216,"char":"Б","width":25,"height":34,"xoffset":1,"yoffset":4,"xadvance":26,"chnl":15,"x":239,"y":439,"page":0},{"id":1042,"index":951,"char":"В","width":24,"height":34,"xoffset":1,"yoffset":4,"xadvance":26,"chnl":15,"x":244,"y":404,"page":0},{"id":1043,"index":952,"char":"Г","width":22,"height":34,"xoffset":2,"yoffset":4,"xadvance":23,"chnl":15,"x":248,"y":474,"page":0},{"id":1045,"index":953,"char":"Е","width":23,"height":34,"xoffset":1,"yoffset":4,"xadvance":24,"chnl":15,"x":265,"y":439,"page":0},{"id":1048,"index":220,"char":"И","width":27,"height":34,"xoffset":2,"yoffset":4,"xadvance":30,"chnl":15,"x":271,"y":474,"page":0},{"id":1081,"index":965,"char":"й","width":22,"height":34,"xoffset":1,"yoffset":4,"xadvance":24,"chnl":15,"x":233,"y":248,"page":0},{"id":1050,"index":947,"char":"К","width":27,"height":34,"xoffset":2,"yoffset":4,"xadvance":27,"chnl":15,"x":233,"y":283,"page":0},{"id":1051,"index":221,"char":"Л","width":29,"height":34,"xoffset":-1,"yoffset":4,"xadvance":30,"chnl":15,"x":256,"y":248,"page":0},{"id":1052,"index":955,"char":"М","width":34,"height":34,"xoffset":1,"yoffset":4,"xadvance":37,"chnl":15,"x":253,"y":318,"page":0},{"id":1053,"index":956,"char":"Н","width":27,"height":34,"xoffset":1,"yoffset":4,"xadvance":30,"chnl":15,"x":261,"y":283,"page":0},{"id":1055,"index":958,"char":"П","width":27,"height":34,"xoffset":2,"yoffset":4,"xadvance":30,"chnl":15,"x":258,"y":353,"page":0},{"id":1056,"index":959,"char":"Р","width":25,"height":34,"xoffset":1,"yoffset":4,"xadvance":26,"chnl":15,"x":269,"y":388,"page":0},{"id":1058,"index":961,"char":"Т","width":27,"height":34,"xoffset":-1,"yoffset":4,"xadvance":25,"chnl":15,"x":286,"y":353,"page":0},{"id":1059,"index":222,"char":"У","width":28,"height":34,"xoffset":0,"yoffset":4,"xadvance":26,"chnl":15,"x":288,"y":318,"page":0},{"id":1061,"index":962,"char":"Х","width":28,"height":34,"xoffset":-1,"yoffset":4,"xadvance":26,"chnl":15,"x":289,"y":423,"page":0},{"id":1063,"index":225,"char":"Ч","width":26,"height":34,"xoffset":1,"yoffset":4,"xadvance":29,"chnl":15,"x":295,"y":388,"page":0},{"id":1066,"index":228,"char":"Ъ","width":34,"height":34,"xoffset":-2,"yoffset":4,"xadvance":32,"chnl":15,"x":314,"y":353,"page":0},{"id":1067,"index":229,"char":"Ы","width":33,"height":34,"xoffset":2,"yoffset":4,"xadvance":36,"chnl":15,"x":299,"y":458,"page":0},{"id":1068,"index":230,"char":"Ь","width":25,"height":34,"xoffset":1,"yoffset":4,"xadvance":26,"chnl":15,"x":318,"y":423,"page":0},{"id":1071,"index":233,"char":"Я","width":25,"height":34,"xoffset":0,"yoffset":4,"xadvance":27,"chnl":15,"x":322,"y":388,"page":0},{"id":962,"index":200,"char":"ς","width":22,"height":34,"xoffset":0,"yoffset":11,"xadvance":23,"chnl":15,"x":333,"y":458,"page":0},{"id":969,"index":206,"char":"ω","width":34,"height":27,"xoffset":1,"yoffset":12,"xadvance":35,"chnl":15,"x":216,"y":144,"page":0},{"id":917,"index":912,"char":"Ε","width":23,"height":34,"xoffset":1,"yoffset":4,"xadvance":24,"chnl":15,"x":344,"y":423,"page":0},{"id":929,"index":920,"char":"Ρ","width":25,"height":34,"xoffset":1,"yoffset":4,"xadvance":26,"chnl":15,"x":348,"y":388,"page":0},{"id":932,"index":921,"char":"Τ","width":27,"height":34,"xoffset":-1,"yoffset":4,"xadvance":25,"chnl":15,"x":237,"y":172,"page":0},{"id":933,"index":922,"char":"Υ","width":29,"height":34,"xoffset":-2,"yoffset":4,"xadvance":25,"chnl":15,"x":258,"y":207,"page":0},{"id":921,"index":915,"char":"Ι","width":8,"height":34,"xoffset":2,"yoffset":4,"xadvance":11,"chnl":15,"x":286,"y":242,"page":0},{"id":928,"index":182,"char":"Π","width":27,"height":34,"xoffset":2,"yoffset":4,"xadvance":30,"chnl":15,"x":289,"y":277,"page":0},{"id":913,"index":910,"char":"Α","width":30,"height":34,"xoffset":-1,"yoffset":4,"xadvance":27,"chnl":15,"x":356,"y":458,"page":0},{"id":931,"index":183,"char":"Σ","width":25,"height":34,"xoffset":-1,"yoffset":4,"xadvance":24,"chnl":15,"x":368,"y":423,"page":0},{"id":916,"index":178,"char":"Δ","width":32,"height":34,"xoffset":-1,"yoffset":4,"xadvance":30,"chnl":15,"x":387,"y":458,"page":0},{"id":934,"index":184,"char":"Φ","width":31,"height":34,"xoffset":0,"yoffset":4,"xadvance":30,"chnl":15,"x":224,"y":71,"page":0},{"id":915,"index":177,"char":"Γ","width":22,"height":34,"xoffset":2,"yoffset":4,"xadvance":23,"chnl":15,"x":244,"y":35,"page":0},{"id":919,"index":914,"char":"Η","width":27,"height":34,"xoffset":1,"yoffset":4,"xadvance":30,"chnl":15,"x":224,"y":106,"page":0},{"id":926,"index":181,"char":"Ξ","width":23,"height":34,"xoffset":0,"yoffset":4,"xadvance":24,"chnl":15,"x":252,"y":106,"page":0},{"id":922,"index":916,"char":"Κ","width":27,"height":34,"xoffset":1,"yoffset":4,"xadvance":26,"chnl":15,"x":256,"y":70,"page":0},{"id":923,"index":180,"char":"Λ","width":29,"height":34,"xoffset":-1,"yoffset":4,"xadvance":28,"chnl":15,"x":265,"y":141,"page":0},{"id":918,"index":913,"char":"Ζ","width":26,"height":34,"xoffset":0,"yoffset":4,"xadvance":25,"chnl":15,"x":276,"y":105,"page":0},{"id":935,"index":923,"char":"Χ","width":28,"height":34,"xoffset":-1,"yoffset":4,"xadvance":26,"chnl":15,"x":288,"y":176,"page":0},{"id":936,"index":185,"char":"Ψ","width":29,"height":34,"xoffset":0,"yoffset":4,"xadvance":29,"chnl":15,"x":295,"y":140,"page":0},{"id":937,"index":186,"char":"Ω","width":27,"height":34,"xoffset":0,"yoffset":4,"xadvance":28,"chnl":15,"x":295,"y":211,"page":0},{"id":914,"index":911,"char":"Β","width":24,"height":34,"xoffset":1,"yoffset":4,"xadvance":26,"chnl":15,"x":317,"y":175,"page":0},{"id":925,"index":918,"char":"Ν","width":27,"height":34,"xoffset":1,"yoffset":4,"xadvance":30,"chnl":15,"x":267,"y":0,"page":0},{"id":924,"index":917,"char":"Μ","width":34,"height":34,"xoffset":1,"yoffset":4,"xadvance":37,"chnl":15,"x":267,"y":35,"page":0},{"id":1076,"index":237,"char":"д","width":27,"height":33,"xoffset":-1,"yoffset":12,"xadvance":25,"chnl":15,"x":284,"y":70,"page":0},{"id":1094,"index":248,"char":"ц","width":24,"height":33,"xoffset":1,"yoffset":12,"xadvance":25,"chnl":15,"x":295,"y":0,"page":0},{"id":1102,"index":256,"char":"ю","width":33,"height":27,"xoffset":1,"yoffset":11,"xadvance":34,"chnl":15,"x":295,"y":246,"page":0},{"id":116,"index":88,"char":"t","width":16,"height":32,"xoffset":-2,"yoffset":6,"xadvance":14,"chnl":15,"x":303,"y":104,"page":0},{"id":59,"index":31,"char":";","width":10,"height":32,"xoffset":-1,"yoffset":12,"xadvance":9,"chnl":15,"x":302,"y":34,"page":0},{"id":1096,"index":250,"char":"ш","width":32,"height":26,"xoffset":1,"yoffset":12,"xadvance":34,"chnl":15,"x":323,"y":210,"page":0},{"id":248,"index":137,"char":"ø","width":24,"height":32,"xoffset":0,"yoffset":9,"xadvance":24,"chnl":15,"x":312,"y":67,"page":0},{"id":1099,"index":253,"char":"ы","width":30,"height":26,"xoffset":1,"yoffset":12,"xadvance":33,"chnl":15,"x":313,"y":34,"page":0},{"id":1084,"index":243,"char":"м","width":29,"height":26,"xoffset":1,"yoffset":12,"xadvance":31,"chnl":15,"x":320,"y":0,"page":0},{"id":1098,"index":252,"char":"ъ","width":28,"height":26,"xoffset":-1,"yoffset":12,"xadvance":26,"chnl":15,"x":320,"y":100,"page":0},{"id":960,"index":198,"char":"π","width":28,"height":26,"xoffset":-1,"yoffset":12,"xadvance":25,"chnl":15,"x":337,"y":61,"page":0},{"id":97,"index":69,"char":"a","width":22,"height":27,"xoffset":0,"yoffset":11,"xadvance":23,"chnl":15,"x":265,"y":176,"page":0},{"id":101,"index":73,"char":"e","width":23,"height":27,"xoffset":0,"yoffset":11,"xadvance":22,"chnl":15,"x":344,"y":27,"page":0},{"id":114,"index":86,"char":"r","width":15,"height":27,"xoffset":1,"yoffset":11,"xadvance":14,"chnl":15,"x":325,"y":127,"page":0},{"id":117,"index":89,"char":"u","width":21,"height":27,"xoffset":1,"yoffset":12,"xadvance":23,"chnl":15,"x":341,"y":127,"page":0},{"id":111,"index":83,"char":"o","width":24,"height":27,"xoffset":0,"yoffset":11,"xadvance":24,"chnl":15,"x":349,"y":88,"page":0},{"id":115,"index":87,"char":"s","width":22,"height":27,"xoffset":0,"yoffset":11,"xadvance":22,"chnl":15,"x":366,"y":55,"page":0},{"id":99,"index":71,"char":"c","width":23,"height":27,"xoffset":0,"yoffset":11,"xadvance":22,"chnl":15,"x":342,"y":155,"page":0},{"id":110,"index":82,"char":"n","width":21,"height":27,"xoffset":1,"yoffset":11,"xadvance":23,"chnl":15,"x":363,"y":116,"page":0},{"id":58,"index":30,"char":":","width":9,"height":27,"xoffset":1,"yoffset":12,"xadvance":10,"chnl":15,"x":251,"y":141,"page":0},{"id":126,"index":98,"char":"~","width":27,"height":12,"xoffset":1,"yoffset":18,"xadvance":29,"chnl":15,"x":112,"y":490,"page":0},{"id":1072,"index":963,"char":"а","width":22,"height":27,"xoffset":0,"yoffset":11,"xadvance":23,"chnl":15,"x":374,"y":83,"page":0},{"id":1077,"index":964,"char":"е","width":23,"height":27,"xoffset":0,"yoffset":11,"xadvance":22,"chnl":15,"x":368,"y":0,"page":0},{"id":1079,"index":239,"char":"з","width":21,"height":27,"xoffset":0,"yoffset":11,"xadvance":21,"chnl":15,"x":389,"y":28,"page":0},{"id":1086,"index":966,"char":"о","width":24,"height":27,"xoffset":0,"yoffset":11,"xadvance":24,"chnl":15,"x":392,"y":0,"page":0},{"id":1089,"index":968,"char":"с","width":23,"height":27,"xoffset":0,"yoffset":11,"xadvance":22,"chnl":15,"x":317,"y":274,"page":0},{"id":1101,"index":255,"char":"э","width":22,"height":27,"xoffset":0,"yoffset":11,"xadvance":23,"chnl":15,"x":329,"y":237,"page":0},{"id":949,"index":191,"char":"ε","width":23,"height":27,"xoffset":0,"yoffset":11,"xadvance":23,"chnl":15,"x":317,"y":302,"page":0},{"id":964,"index":202,"char":"τ","width":23,"height":27,"xoffset":0,"yoffset":12,"xadvance":22,"chnl":15,"x":341,"y":265,"page":0},{"id":965,"index":203,"char":"υ","width":22,"height":27,"xoffset":1,"yoffset":12,"xadvance":23,"chnl":15,"x":352,"y":237,"page":0},{"id":959,"index":932,"char":"ο","width":24,"height":27,"xoffset":0,"yoffset":11,"xadvance":24,"chnl":15,"x":356,"y":183,"page":0},{"id":945,"index":187,"char":"α","width":25,"height":27,"xoffset":0,"yoffset":11,"xadvance":24,"chnl":15,"x":366,"y":144,"page":0},{"id":963,"index":201,"char":"σ","width":26,"height":27,"xoffset":0,"yoffset":12,"xadvance":24,"chnl":15,"x":385,"y":111,"page":0},{"id":122,"index":94,"char":"z","width":22,"height":26,"xoffset":0,"yoffset":12,"xadvance":21,"chnl":15,"x":389,"y":56,"page":0},{"id":120,"index":92,"char":"x","width":23,"height":26,"xoffset":-1,"yoffset":12,"xadvance":21,"chnl":15,"x":397,"y":83,"page":0},{"id":118,"index":90,"char":"v","width":23,"height":26,"xoffset":-1,"yoffset":12,"xadvance":20,"chnl":15,"x":411,"y":28,"page":0},{"id":43,"index":15,"char":"+","width":24,"height":26,"xoffset":0,"yoffset":9,"xadvance":24,"chnl":15,"x":417,"y":0,"page":0},{"id":1074,"index":235,"char":"в","width":23,"height":26,"xoffset":1,"yoffset":12,"xadvance":24,"chnl":15,"x":412,"y":55,"page":0},{"id":1075,"index":236,"char":"г","width":18,"height":26,"xoffset":1,"yoffset":12,"xadvance":18,"chnl":15,"x":368,"y":28,"page":0},{"id":1080,"index":240,"char":"и","width":22,"height":26,"xoffset":1,"yoffset":12,"xadvance":24,"chnl":15,"x":435,"y":27,"page":0},{"id":1082,"index":241,"char":"к","width":23,"height":26,"xoffset":1,"yoffset":12,"xadvance":23,"chnl":15,"x":442,"y":0,"page":0},{"id":1083,"index":242,"char":"л","width":24,"height":26,"xoffset":-1,"yoffset":12,"xadvance":24,"chnl":15,"x":466,"y":0,"page":0},{"id":1085,"index":244,"char":"н","width":22,"height":26,"xoffset":1,"yoffset":12,"xadvance":24,"chnl":15,"x":458,"y":27,"page":0},{"id":1087,"index":245,"char":"п","width":22,"height":26,"xoffset":1,"yoffset":12,"xadvance":24,"chnl":15,"x":481,"y":27,"page":0},{"id":1090,"index":246,"char":"т","width":23,"height":26,"xoffset":-1,"yoffset":12,"xadvance":20,"chnl":15,"x":341,"y":293,"page":0},{"id":1093,"index":970,"char":"х","width":23,"height":26,"xoffset":-1,"yoffset":12,"xadvance":21,"chnl":15,"x":341,"y":320,"page":0},{"id":1095,"index":249,"char":"ч","width":22,"height":26,"xoffset":0,"yoffset":12,"xadvance":23,"chnl":15,"x":349,"y":347,"page":0},{"id":1100,"index":254,"char":"ь","width":22,"height":26,"xoffset":1,"yoffset":12,"xadvance":23,"chnl":15,"x":436,"y":54,"page":0},{"id":1103,"index":257,"char":"я","width":23,"height":26,"xoffset":-1,"yoffset":12,"xadvance":23,"chnl":15,"x":459,"y":54,"page":0},{"id":953,"index":195,"char":"ι","width":12,"height":26,"xoffset":2,"yoffset":12,"xadvance":14,"chnl":15,"x":350,"y":0,"page":0},{"id":954,"index":931,"char":"κ","width":23,"height":26,"xoffset":1,"yoffset":12,"xadvance":23,"chnl":15,"x":483,"y":54,"page":0},{"id":957,"index":934,"char":"ν","width":23,"height":26,"xoffset":-1,"yoffset":12,"xadvance":20,"chnl":15,"x":436,"y":81,"page":0},{"id":8211,"index":385,"char":"–","width":25,"height":7,"xoffset":1,"yoffset":18,"xadvance":28,"chnl":15,"x":64,"y":503,"page":0},{"id":95,"index":67,"char":"_","width":23,"height":7,"xoffset":-2,"yoffset":34,"xadvance":19,"chnl":15,"x":100,"y":395,"page":0},{"id":42,"index":14,"char":"*","width":21,"height":21,"xoffset":-1,"yoffset":4,"xadvance":18,"chnl":15,"x":491,"y":0,"page":0},{"id":61,"index":33,"char":"=","width":21,"height":16,"xoffset":1,"yoffset":14,"xadvance":23,"chnl":15,"x":113,"y":275,"page":0},{"id":176,"index":113,"char":"°","width":14,"height":15,"xoffset":1,"yoffset":4,"xadvance":16,"chnl":15,"x":199,"y":248,"page":0},{"id":45,"index":17,"char":"-","width":14,"height":7,"xoffset":-1,"yoffset":20,"xadvance":12,"chnl":15,"x":54,"y":346,"page":0},{"id":44,"index":16,"char":",","width":10,"height":14,"xoffset":-1,"yoffset":30,"xadvance":8,"chnl":15,"x":184,"y":213,"page":0},{"id":34,"index":6,"char":"\\"","width":12,"height":14,"xoffset":1,"yoffset":3,"xadvance":13,"chnl":15,"x":83,"y":203,"page":0},{"id":39,"index":11,"char":"\'","width":7,"height":14,"xoffset":0,"yoffset":3,"xadvance":7,"chnl":15,"x":140,"y":498,"page":0},{"id":46,"index":18,"char":".","width":9,"height":9,"xoffset":1,"yoffset":30,"xadvance":11,"chnl":15,"x":123,"y":229,"page":0}],"info":{"face":"Roboto-Regular","size":42,"bold":0,"italic":0,"charset":["a","z","e","r","t","y","u","i","o","p","q","s","d","f","g","h","j","k","l","m","w","x","c","v","b","n","A","Z","E","R","T","Y","U","I","O","P","Q","S","D","F","G","H","J","K","L","M","W","X","C","V","B","N","/","\\\\","*","-","–","+","7","8","9","4","5","6","1","2","3","0",",",";",":","!","?",".","%","$","£","€","=","{","}","(",")","[","]","&","~","\\"","\'","#","_","|","°","@","А","а","Б","б","В","в","Г","г","Д","д","Е","е","Ё","ё","Ж","ж","З","з","И","и","Й","й","К","к","Л","л","М","м","Н","н","О","о","П","п","Р","р","С","с","Т","т","У","у","Ф","ф","Х","х","Ц","ц","Ч","ч","Ш","ш","Щ","щ","Ъ","ъ","Ы","ы","Ь","ь","Э","э","Ю","ю","Я","я","ü","Ü","ö","Ö","ä","Ä","ñ","Ñ","ς","ε","ρ","τ","υ","θ","ι","ο","π","α","σ","δ","φ","γ","η","ξ","κ","λ","ζ","χ","ψ","ω","β","ν","μ","Ε","Ρ","Τ","Υ","Θ","Ι","Ο","Π","Α","Σ","Δ","Φ","Γ","Η","Ξ","Κ","Λ","Ζ","Χ","Ψ","Ω","Β","Ν","Μ","å","Å","æ","Æ","ø","Ø"],"unicode":1,"stretchH":100,"smooth":1,"aa":1,"padding":[2,2,2,2],"spacing":[0,0]},"common":{"lineHeight":44,"base":34,"scaleW":512,"scaleH":512,"pages":1,"packed":0,"alphaChnl":0,"redChnl":0,"greenChnl":0,"blueChnl":0},"distanceField":{"fieldType":"msdf","distanceRange":4},"kernings":[{"first":97,"second":121,"amount":0},{"first":97,"second":118,"amount":0},{"first":97,"second":34,"amount":-1},{"first":97,"second":39,"amount":-1},{"first":97,"second":1090,"amount":0},{"first":97,"second":1091,"amount":0},{"first":97,"second":947,"amount":0},{"first":97,"second":957,"amount":0},{"first":122,"second":101,"amount":0},{"first":122,"second":111,"amount":0},{"first":122,"second":113,"amount":0},{"first":122,"second":100,"amount":0},{"first":122,"second":103,"amount":0},{"first":122,"second":99,"amount":0},{"first":122,"second":1077,"amount":0},{"first":122,"second":1105,"amount":0},{"first":122,"second":1086,"amount":0},{"first":122,"second":1089,"amount":0},{"first":122,"second":1092,"amount":0},{"first":122,"second":246,"amount":0},{"first":122,"second":962,"amount":0},{"first":122,"second":959,"amount":0},{"first":122,"second":945,"amount":0},{"first":122,"second":963,"amount":0},{"first":101,"second":121,"amount":0},{"first":101,"second":118,"amount":0},{"first":101,"second":34,"amount":0},{"first":101,"second":39,"amount":0},{"first":101,"second":1090,"amount":0},{"first":101,"second":1091,"amount":0},{"first":101,"second":947,"amount":0},{"first":101,"second":957,"amount":0},{"first":114,"second":97,"amount":-1},{"first":114,"second":101,"amount":0},{"first":114,"second":116,"amount":1},{"first":114,"second":121,"amount":0},{"first":114,"second":111,"amount":0},{"first":114,"second":113,"amount":0},{"first":114,"second":100,"amount":0},{"first":114,"second":102,"amount":0},{"first":114,"second":103,"amount":0},{"first":114,"second":119,"amount":0},{"first":114,"second":99,"amount":0},{"first":114,"second":118,"amount":0},{"first":114,"second":44,"amount":-3},{"first":114,"second":46,"amount":-3},{"first":114,"second":34,"amount":0},{"first":114,"second":39,"amount":0},{"first":114,"second":1072,"amount":-1},{"first":114,"second":1077,"amount":0},{"first":114,"second":1105,"amount":0},{"first":114,"second":1086,"amount":0},{"first":114,"second":1089,"amount":0},{"first":114,"second":1091,"amount":0},{"first":114,"second":1092,"amount":0},{"first":114,"second":246,"amount":0},{"first":114,"second":228,"amount":-1},{"first":114,"second":962,"amount":0},{"first":114,"second":959,"amount":0},{"first":114,"second":945,"amount":0},{"first":114,"second":963,"amount":0},{"first":114,"second":947,"amount":0},{"first":114,"second":957,"amount":0},{"first":114,"second":229,"amount":-1},{"first":116,"second":111,"amount":0},{"first":116,"second":1086,"amount":0},{"first":116,"second":246,"amount":0},{"first":116,"second":959,"amount":0},{"first":121,"second":97,"amount":0},{"first":121,"second":101,"amount":0},{"first":121,"second":111,"amount":0},{"first":121,"second":113,"amount":0},{"first":121,"second":100,"amount":0},{"first":121,"second":102,"amount":0},{"first":121,"second":103,"amount":0},{"first":121,"second":99,"amount":0},{"first":121,"second":44,"amount":-2},{"first":121,"second":46,"amount":-2},{"first":121,"second":34,"amount":0},{"first":121,"second":39,"amount":0},{"first":121,"second":1072,"amount":0},{"first":121,"second":1076,"amount":-1},{"first":121,"second":1077,"amount":0},{"first":121,"second":1105,"amount":0},{"first":121,"second":1083,"amount":-1},{"first":121,"second":1086,"amount":0},{"first":121,"second":1089,"amount":0},{"first":121,"second":1092,"amount":0},{"first":121,"second":246,"amount":0},{"first":121,"second":228,"amount":0},{"first":121,"second":962,"amount":0},{"first":121,"second":961,"amount":0},{"first":121,"second":964,"amount":0},{"first":121,"second":959,"amount":0},{"first":121,"second":960,"amount":0},{"first":121,"second":945,"amount":0},{"first":121,"second":963,"amount":0},{"first":121,"second":948,"amount":0},{"first":121,"second":229,"amount":0},{"first":111,"second":122,"amount":0},{"first":111,"second":121,"amount":0},{"first":111,"second":120,"amount":0},{"first":111,"second":118,"amount":0},{"first":111,"second":34,"amount":-3},{"first":111,"second":39,"amount":-3},{"first":111,"second":1076,"amount":-1},{"first":111,"second":1078,"amount":0},{"first":111,"second":1083,"amount":0},{"first":111,"second":1090,"amount":0},{"first":111,"second":1091,"amount":0},{"first":111,"second":1093,"amount":0},{"first":111,"second":964,"amount":0},{"first":111,"second":947,"amount":0},{"first":111,"second":957,"amount":0},{"first":112,"second":122,"amount":0},{"first":112,"second":121,"amount":0},{"first":112,"second":120,"amount":0},{"first":112,"second":118,"amount":0},{"first":112,"second":34,"amount":-1},{"first":112,"second":39,"amount":-1},{"first":112,"second":1076,"amount":0},{"first":112,"second":1078,"amount":0},{"first":112,"second":1083,"amount":0},{"first":112,"second":1090,"amount":-2},{"first":112,"second":1091,"amount":0},{"first":112,"second":1093,"amount":0},{"first":112,"second":964,"amount":0},{"first":112,"second":947,"amount":0},{"first":112,"second":957,"amount":0},{"first":102,"second":101,"amount":0},{"first":102,"second":113,"amount":0},{"first":102,"second":100,"amount":0},{"first":102,"second":103,"amount":0},{"first":102,"second":99,"amount":0},{"first":102,"second":125,"amount":0},{"first":102,"second":41,"amount":0},{"first":102,"second":93,"amount":0},{"first":102,"second":34,"amount":0},{"first":102,"second":39,"amount":0},{"first":102,"second":1077,"amount":0},{"first":102,"second":1105,"amount":0},{"first":102,"second":1089,"amount":0},{"first":102,"second":1092,"amount":0},{"first":102,"second":962,"amount":0},{"first":102,"second":945,"amount":0},{"first":102,"second":963,"amount":0},{"first":104,"second":34,"amount":-2},{"first":104,"second":39,"amount":-2},{"first":104,"second":1090,"amount":-1},{"first":107,"second":101,"amount":0},{"first":107,"second":113,"amount":0},{"first":107,"second":100,"amount":0},{"first":107,"second":103,"amount":0},{"first":107,"second":99,"amount":0},{"first":107,"second":1077,"amount":0},{"first":107,"second":1105,"amount":0},{"first":107,"second":1089,"amount":0},{"first":107,"second":1092,"amount":0},{"first":107,"second":962,"amount":0},{"first":107,"second":945,"amount":0},{"first":107,"second":963,"amount":0},{"first":109,"second":34,"amount":-2},{"first":109,"second":39,"amount":-2},{"first":109,"second":1090,"amount":-1},{"first":119,"second":44,"amount":-3},{"first":119,"second":46,"amount":-3},{"first":120,"second":101,"amount":0},{"first":120,"second":111,"amount":0},{"first":120,"second":113,"amount":0},{"first":120,"second":100,"amount":0},{"first":120,"second":103,"amount":0},{"first":120,"second":99,"amount":0},{"first":120,"second":1077,"amount":0},{"first":120,"second":1105,"amount":0},{"first":120,"second":1086,"amount":0},{"first":120,"second":1089,"amount":0},{"first":120,"second":1092,"amount":0},{"first":120,"second":246,"amount":0},{"first":120,"second":962,"amount":0},{"first":120,"second":959,"amount":0},{"first":120,"second":945,"amount":0},{"first":120,"second":963,"amount":0},{"first":99,"second":34,"amount":0},{"first":99,"second":39,"amount":0},{"first":118,"second":97,"amount":0},{"first":118,"second":101,"amount":0},{"first":118,"second":111,"amount":0},{"first":118,"second":113,"amount":0},{"first":118,"second":100,"amount":0},{"first":118,"second":102,"amount":0},{"first":118,"second":103,"amount":0},{"first":118,"second":99,"amount":0},{"first":118,"second":44,"amount":-2},{"first":118,"second":46,"amount":-2},{"first":118,"second":34,"amount":0},{"first":118,"second":39,"amount":0},{"first":118,"second":1072,"amount":0},{"first":118,"second":1076,"amount":-1},{"first":118,"second":1077,"amount":0},{"first":118,"second":1105,"amount":0},{"first":118,"second":1083,"amount":-1},{"first":118,"second":1086,"amount":0},{"first":118,"second":1089,"amount":0},{"first":118,"second":1092,"amount":0},{"first":118,"second":246,"amount":0},{"first":118,"second":228,"amount":0},{"first":118,"second":962,"amount":0},{"first":118,"second":961,"amount":0},{"first":118,"second":964,"amount":0},{"first":118,"second":959,"amount":0},{"first":118,"second":960,"amount":0},{"first":118,"second":945,"amount":0},{"first":118,"second":963,"amount":0},{"first":118,"second":948,"amount":0},{"first":118,"second":229,"amount":0},{"first":98,"second":122,"amount":0},{"first":98,"second":121,"amount":0},{"first":98,"second":120,"amount":0},{"first":98,"second":118,"amount":0},{"first":98,"second":34,"amount":-1},{"first":98,"second":39,"amount":-1},{"first":98,"second":1076,"amount":0},{"first":98,"second":1078,"amount":0},{"first":98,"second":1083,"amount":0},{"first":98,"second":1090,"amount":-2},{"first":98,"second":1091,"amount":0},{"first":98,"second":1093,"amount":0},{"first":98,"second":964,"amount":0},{"first":98,"second":947,"amount":0},{"first":98,"second":957,"amount":0},{"first":110,"second":34,"amount":-2},{"first":110,"second":39,"amount":-2},{"first":110,"second":1090,"amount":-1},{"first":65,"second":122,"amount":0},{"first":65,"second":116,"amount":0},{"first":65,"second":121,"amount":-1},{"first":65,"second":117,"amount":0},{"first":65,"second":111,"amount":0},{"first":65,"second":119,"amount":-1},{"first":65,"second":118,"amount":-1},{"first":65,"second":84,"amount":-3},{"first":65,"second":89,"amount":-2},{"first":65,"second":85,"amount":0},{"first":65,"second":79,"amount":0},{"first":65,"second":81,"amount":0},{"first":65,"second":71,"amount":0},{"first":65,"second":87,"amount":-1},{"first":65,"second":67,"amount":0},{"first":65,"second":86,"amount":-2},{"first":65,"second":63,"amount":-1},{"first":65,"second":34,"amount":-2},{"first":65,"second":39,"amount":-2},{"first":65,"second":1044,"amount":0},{"first":65,"second":1051,"amount":0},{"first":65,"second":1083,"amount":0},{"first":65,"second":1054,"amount":0},{"first":65,"second":1086,"amount":0},{"first":65,"second":1057,"amount":0},{"first":65,"second":1058,"amount":-3},{"first":65,"second":1090,"amount":-1},{"first":65,"second":1091,"amount":-1},{"first":65,"second":1063,"amount":-1},{"first":65,"second":1095,"amount":-2},{"first":65,"second":1068,"amount":-1},{"first":65,"second":252,"amount":0},{"first":65,"second":220,"amount":0},{"first":65,"second":246,"amount":0},{"first":65,"second":214,"amount":0},{"first":65,"second":964,"amount":-1},{"first":65,"second":965,"amount":0},{"first":65,"second":959,"amount":0},{"first":65,"second":947,"amount":-1},{"first":65,"second":955,"amount":0},{"first":65,"second":957,"amount":-1},{"first":65,"second":933,"amount":-2},{"first":65,"second":920,"amount":0},{"first":65,"second":927,"amount":0},{"first":65,"second":934,"amount":-1},{"first":65,"second":936,"amount":-1},{"first":65,"second":216,"amount":0},{"first":90,"second":101,"amount":0},{"first":90,"second":121,"amount":-1},{"first":90,"second":117,"amount":0},{"first":90,"second":111,"amount":0},{"first":90,"second":113,"amount":0},{"first":90,"second":100,"amount":0},{"first":90,"second":103,"amount":0},{"first":90,"second":119,"amount":-1},{"first":90,"second":99,"amount":0},{"first":90,"second":118,"amount":-1},{"first":90,"second":65,"amount":0},{"first":90,"second":79,"amount":-1},{"first":90,"second":81,"amount":-1},{"first":90,"second":71,"amount":-1},{"first":90,"second":67,"amount":-1},{"first":90,"second":1040,"amount":0},{"first":90,"second":1077,"amount":0},{"first":90,"second":1105,"amount":0},{"first":90,"second":1054,"amount":-1},{"first":90,"second":1086,"amount":0},{"first":90,"second":1057,"amount":-1},{"first":90,"second":1089,"amount":0},{"first":90,"second":1091,"amount":-1},{"first":90,"second":1092,"amount":0},{"first":90,"second":252,"amount":0},{"first":90,"second":246,"amount":0},{"first":90,"second":214,"amount":-1},{"first":90,"second":196,"amount":0},{"first":90,"second":962,"amount":0},{"first":90,"second":965,"amount":0},{"first":90,"second":959,"amount":0},{"first":90,"second":945,"amount":0},{"first":90,"second":963,"amount":0},{"first":90,"second":947,"amount":-1},{"first":90,"second":968,"amount":-1},{"first":90,"second":957,"amount":-1},{"first":90,"second":920,"amount":-1},{"first":90,"second":927,"amount":-1},{"first":90,"second":913,"amount":0},{"first":90,"second":916,"amount":0},{"first":90,"second":934,"amount":-1},{"first":90,"second":923,"amount":0},{"first":90,"second":197,"amount":0},{"first":90,"second":216,"amount":-1},{"first":69,"second":101,"amount":0},{"first":69,"second":121,"amount":-1},{"first":69,"second":117,"amount":0},{"first":69,"second":111,"amount":0},{"first":69,"second":113,"amount":0},{"first":69,"second":100,"amount":0},{"first":69,"second":102,"amount":0},{"first":69,"second":103,"amount":0},{"first":69,"second":119,"amount":0},{"first":69,"second":99,"amount":0},{"first":69,"second":118,"amount":-1},{"first":69,"second":84,"amount":0},{"first":69,"second":1077,"amount":0},{"first":69,"second":1105,"amount":0},{"first":69,"second":1086,"amount":0},{"first":69,"second":1089,"amount":0},{"first":69,"second":1058,"amount":0},{"first":69,"second":1091,"amount":-1},{"first":69,"second":1092,"amount":0},{"first":69,"second":252,"amount":0},{"first":69,"second":246,"amount":0},{"first":69,"second":962,"amount":0},{"first":69,"second":965,"amount":0},{"first":69,"second":959,"amount":0},{"first":69,"second":945,"amount":0},{"first":69,"second":963,"amount":0},{"first":69,"second":947,"amount":-1},{"first":69,"second":957,"amount":-1},{"first":82,"second":84,"amount":-2},{"first":82,"second":89,"amount":-1},{"first":82,"second":86,"amount":0},{"first":82,"second":1058,"amount":-2},{"first":82,"second":933,"amount":-1},{"first":84,"second":97,"amount":-2},{"first":84,"second":122,"amount":-1},{"first":84,"second":101,"amount":-2},{"first":84,"second":114,"amount":-2},{"first":84,"second":121,"amount":-1},{"first":84,"second":117,"amount":-2},{"first":84,"second":111,"amount":-2},{"first":84,"second":112,"amount":-2},{"first":84,"second":113,"amount":-2},{"first":84,"second":115,"amount":-2},{"first":84,"second":100,"amount":-2},{"first":84,"second":103,"amount":-2},{"first":84,"second":109,"amount":-2},{"first":84,"second":119,"amount":-1},{"first":84,"second":120,"amount":-2},{"first":84,"second":99,"amount":-2},{"first":84,"second":118,"amount":-1},{"first":84,"second":110,"amount":-2},{"first":84,"second":65,"amount":-2},{"first":84,"second":84,"amount":0},{"first":84,"second":89,"amount":0},{"first":84,"second":79,"amount":-1},{"first":84,"second":81,"amount":-1},{"first":84,"second":83,"amount":0},{"first":84,"second":71,"amount":-1},{"first":84,"second":74,"amount":-5},{"first":84,"second":87,"amount":0},{"first":84,"second":67,"amount":-1},{"first":84,"second":86,"amount":0},{"first":84,"second":45,"amount":-5},{"first":84,"second":8211,"amount":-5},{"first":84,"second":44,"amount":-4},{"first":84,"second":46,"amount":-4},{"first":84,"second":1040,"amount":-2},{"first":84,"second":1072,"amount":-2},{"first":84,"second":1073,"amount":-1},{"first":84,"second":1074,"amount":-2},{"first":84,"second":1075,"amount":-2},{"first":84,"second":1044,"amount":-2},{"first":84,"second":1076,"amount":-3},{"first":84,"second":1077,"amount":-2},{"first":84,"second":1105,"amount":-2},{"first":84,"second":1078,"amount":-2},{"first":84,"second":1079,"amount":-3},{"first":84,"second":1080,"amount":-2},{"first":84,"second":1081,"amount":-2},{"first":84,"second":1082,"amount":-2},{"first":84,"second":1051,"amount":-1},{"first":84,"second":1083,"amount":-3},{"first":84,"second":1084,"amount":-2},{"first":84,"second":1085,"amount":-2},{"first":84,"second":1054,"amount":-1},{"first":84,"second":1086,"amount":-2},{"first":84,"second":1087,"amount":-2},{"first":84,"second":1088,"amount":-2},{"first":84,"second":1057,"amount":-1},{"first":84,"second":1089,"amount":-2},{"first":84,"second":1058,"amount":0},{"first":84,"second":1090,"amount":-2},{"first":84,"second":1091,"amount":-1},{"first":84,"second":1092,"amount":-2},{"first":84,"second":1093,"amount":-2},{"first":84,"second":1094,"amount":-2},{"first":84,"second":1095,"amount":-3},{"first":84,"second":1096,"amount":-2},{"first":84,"second":1097,"amount":-2},{"first":84,"second":1099,"amount":-3},{"first":84,"second":1068,"amount":0},{"first":84,"second":1100,"amount":-2},{"first":84,"second":1101,"amount":-3},{"first":84,"second":1102,"amount":-2},{"first":84,"second":1103,"amount":-3},{"first":84,"second":252,"amount":-2},{"first":84,"second":246,"amount":-2},{"first":84,"second":214,"amount":-1},{"first":84,"second":228,"amount":-2},{"first":84,"second":196,"amount":-2},{"first":84,"second":241,"amount":-2},{"first":84,"second":962,"amount":-2},{"first":84,"second":949,"amount":-3},{"first":84,"second":961,"amount":-3},{"first":84,"second":964,"amount":-2},{"first":84,"second":965,"amount":-2},{"first":84,"second":953,"amount":-3},{"first":84,"second":959,"amount":-2},{"first":84,"second":960,"amount":-2},{"first":84,"second":945,"amount":-2},{"first":84,"second":963,"amount":-2},{"first":84,"second":948,"amount":-1},{"first":84,"second":966,"amount":-3},{"first":84,"second":947,"amount":-1},{"first":84,"second":951,"amount":-2},{"first":84,"second":968,"amount":-3},{"first":84,"second":969,"amount":-3},{"first":84,"second":957,"amount":-1},{"first":84,"second":933,"amount":0},{"first":84,"second":920,"amount":-1},{"first":84,"second":927,"amount":-1},{"first":84,"second":913,"amount":-2},{"first":84,"second":916,"amount":-2},{"first":84,"second":934,"amount":-2},{"first":84,"second":923,"amount":-2},{"first":84,"second":229,"amount":-2},{"first":84,"second":197,"amount":-2},{"first":84,"second":230,"amount":-2},{"first":84,"second":198,"amount":-4},{"first":84,"second":248,"amount":-2},{"first":84,"second":216,"amount":-1},{"first":89,"second":97,"amount":-1},{"first":89,"second":122,"amount":-1},{"first":89,"second":101,"amount":-1},{"first":89,"second":114,"amount":-1},{"first":89,"second":116,"amount":0},{"first":89,"second":121,"amount":0},{"first":89,"second":117,"amount":-1},{"first":89,"second":111,"amount":-1},{"first":89,"second":112,"amount":-1},{"first":89,"second":113,"amount":-1},{"first":89,"second":115,"amount":-1},{"first":89,"second":100,"amount":-1},{"first":89,"second":102,"amount":0},{"first":89,"second":103,"amount":-1},{"first":89,"second":109,"amount":-1},{"first":89,"second":120,"amount":0},{"first":89,"second":99,"amount":-1},{"first":89,"second":118,"amount":0},{"first":89,"second":110,"amount":-1},{"first":89,"second":65,"amount":-2},{"first":89,"second":84,"amount":0},{"first":89,"second":89,"amount":0},{"first":89,"second":85,"amount":-2},{"first":89,"second":79,"amount":-1},{"first":89,"second":81,"amount":-1},{"first":89,"second":83,"amount":0},{"first":89,"second":71,"amount":-1},{"first":89,"second":74,"amount":-2},{"first":89,"second":87,"amount":0},{"first":89,"second":88,"amount":0},{"first":89,"second":67,"amount":-1},{"first":89,"second":86,"amount":0},{"first":89,"second":42,"amount":-1},{"first":89,"second":45,"amount":-1},{"first":89,"second":8211,"amount":-1},{"first":89,"second":44,"amount":-4},{"first":89,"second":46,"amount":-4},{"first":89,"second":125,"amount":0},{"first":89,"second":41,"amount":0},{"first":89,"second":93,"amount":0},{"first":89,"second":38,"amount":-1},{"first":89,"second":1040,"amount":-2},{"first":89,"second":1072,"amount":-1},{"first":89,"second":1075,"amount":-1},{"first":89,"second":1077,"amount":-1},{"first":89,"second":1105,"amount":-1},{"first":89,"second":1046,"amount":0},{"first":89,"second":1078,"amount":0},{"first":89,"second":1080,"amount":-1},{"first":89,"second":1081,"amount":-1},{"first":89,"second":1082,"amount":-1},{"first":89,"second":1084,"amount":-1},{"first":89,"second":1085,"amount":-1},{"first":89,"second":1054,"amount":-1},{"first":89,"second":1086,"amount":-1},{"first":89,"second":1087,"amount":-1},{"first":89,"second":1088,"amount":-1},{"first":89,"second":1057,"amount":-1},{"first":89,"second":1089,"amount":-1},{"first":89,"second":1058,"amount":0},{"first":89,"second":1091,"amount":0},{"first":89,"second":1092,"amount":-1},{"first":89,"second":1061,"amount":0},{"first":89,"second":1093,"amount":0},{"first":89,"second":1094,"amount":-1},{"first":89,"second":1096,"amount":-1},{"first":89,"second":1097,"amount":-1},{"first":89,"second":1100,"amount":-1},{"first":89,"second":1102,"amount":-1},{"first":89,"second":252,"amount":-1},{"first":89,"second":220,"amount":-2},{"first":89,"second":246,"amount":-1},{"first":89,"second":214,"amount":-1},{"first":89,"second":228,"amount":-1},{"first":89,"second":196,"amount":-2},{"first":89,"second":241,"amount":-1},{"first":89,"second":962,"amount":-1},{"first":89,"second":949,"amount":-1},{"first":89,"second":961,"amount":-1},{"first":89,"second":964,"amount":0},{"first":89,"second":965,"amount":-1},{"first":89,"second":952,"amount":0},{"first":89,"second":953,"amount":-1},{"first":89,"second":959,"amount":-1},{"first":89,"second":960,"amount":0},{"first":89,"second":945,"amount":-1},{"first":89,"second":963,"amount":-1},{"first":89,"second":948,"amount":0},{"first":89,"second":966,"amount":-1},{"first":89,"second":947,"amount":0},{"first":89,"second":951,"amount":-1},{"first":89,"second":950,"amount":0},{"first":89,"second":968,"amount":-1},{"first":89,"second":969,"amount":-1},{"first":89,"second":946,"amount":0},{"first":89,"second":957,"amount":0},{"first":89,"second":933,"amount":0},{"first":89,"second":920,"amount":-1},{"first":89,"second":927,"amount":-1},{"first":89,"second":913,"amount":-2},{"first":89,"second":916,"amount":-2},{"first":89,"second":934,"amount":-1},{"first":89,"second":923,"amount":-2},{"first":89,"second":935,"amount":0},{"first":89,"second":229,"amount":-1},{"first":89,"second":197,"amount":-2},{"first":89,"second":230,"amount":-1},{"first":89,"second":198,"amount":-2},{"first":89,"second":248,"amount":-1},{"first":89,"second":216,"amount":-1},{"first":85,"second":65,"amount":0},{"first":85,"second":1040,"amount":0},{"first":85,"second":196,"amount":0},{"first":85,"second":913,"amount":0},{"first":85,"second":916,"amount":0},{"first":85,"second":923,"amount":0},{"first":85,"second":197,"amount":0},{"first":73,"second":65,"amount":0},{"first":73,"second":84,"amount":-1},{"first":73,"second":89,"amount":-1},{"first":73,"second":88,"amount":0},{"first":73,"second":1040,"amount":0},{"first":73,"second":1044,"amount":0},{"first":73,"second":1076,"amount":0},{"first":73,"second":1046,"amount":0},{"first":73,"second":1051,"amount":0},{"first":73,"second":1083,"amount":0},{"first":73,"second":1058,"amount":-1},{"first":73,"second":1061,"amount":0},{"first":73,"second":1063,"amount":-1},{"first":73,"second":1095,"amount":-1},{"first":73,"second":196,"amount":0},{"first":73,"second":933,"amount":-1},{"first":73,"second":913,"amount":0},{"first":73,"second":916,"amount":0},{"first":73,"second":923,"amount":0},{"first":73,"second":935,"amount":0},{"first":73,"second":197,"amount":0},{"first":79,"second":65,"amount":0},{"first":79,"second":90,"amount":0},{"first":79,"second":84,"amount":-1},{"first":79,"second":89,"amount":-1},{"first":79,"second":88,"amount":0},{"first":79,"second":86,"amount":0},{"first":79,"second":44,"amount":-2},{"first":79,"second":46,"amount":-2},{"first":79,"second":1040,"amount":0},{"first":79,"second":1044,"amount":-1},{"first":79,"second":1046,"amount":0},{"first":79,"second":1051,"amount":-1},{"first":79,"second":1058,"amount":-1},{"first":79,"second":1061,"amount":0},{"first":79,"second":1068,"amount":-1},{"first":79,"second":196,"amount":0},{"first":79,"second":955,"amount":0},{"first":79,"second":933,"amount":-1},{"first":79,"second":913,"amount":0},{"first":79,"second":931,"amount":0},{"first":79,"second":916,"amount":0},{"first":79,"second":926,"amount":0},{"first":79,"second":923,"amount":0},{"first":79,"second":918,"amount":0},{"first":79,"second":935,"amount":0},{"first":79,"second":197,"amount":0},{"first":79,"second":198,"amount":-1},{"first":80,"second":97,"amount":0},{"first":80,"second":101,"amount":0},{"first":80,"second":116,"amount":0},{"first":80,"second":121,"amount":0},{"first":80,"second":111,"amount":0},{"first":80,"second":113,"amount":0},{"first":80,"second":100,"amount":0},{"first":80,"second":103,"amount":0},{"first":80,"second":99,"amount":0},{"first":80,"second":118,"amount":0},{"first":80,"second":65,"amount":-3},{"first":80,"second":90,"amount":-1},{"first":80,"second":74,"amount":-4},{"first":80,"second":88,"amount":-1},{"first":80,"second":44,"amount":-7},{"first":80,"second":46,"amount":-7},{"first":80,"second":1040,"amount":-3},{"first":80,"second":1072,"amount":0},{"first":80,"second":1044,"amount":-2},{"first":80,"second":1076,"amount":-1},{"first":80,"second":1077,"amount":0},{"first":80,"second":1105,"amount":0},{"first":80,"second":1046,"amount":-1},{"first":80,"second":1051,"amount":-1},{"first":80,"second":1083,"amount":-1},{"first":80,"second":1086,"amount":0},{"first":80,"second":1089,"amount":0},{"first":80,"second":1091,"amount":0},{"first":80,"second":1092,"amount":0},{"first":80,"second":1061,"amount":-1},{"first":80,"second":246,"amount":0},{"first":80,"second":228,"amount":0},{"first":80,"second":196,"amount":-3},{"first":80,"second":962,"amount":0},{"first":80,"second":961,"amount":-1},{"first":80,"second":959,"amount":0},{"first":80,"second":945,"amount":0},{"first":80,"second":963,"amount":0},{"first":80,"second":948,"amount":0},{"first":80,"second":947,"amount":0},{"first":80,"second":955,"amount":-1},{"first":80,"second":957,"amount":0},{"first":80,"second":913,"amount":-3},{"first":80,"second":916,"amount":-3},{"first":80,"second":923,"amount":-3},{"first":80,"second":918,"amount":-1},{"first":80,"second":935,"amount":-1},{"first":80,"second":229,"amount":0},{"first":80,"second":197,"amount":-3},{"first":80,"second":198,"amount":-2},{"first":81,"second":84,"amount":-1},{"first":81,"second":89,"amount":-1},{"first":81,"second":87,"amount":0},{"first":81,"second":86,"amount":-1},{"first":81,"second":1058,"amount":-1},{"first":81,"second":933,"amount":-1},{"first":68,"second":65,"amount":0},{"first":68,"second":90,"amount":0},{"first":68,"second":84,"amount":-1},{"first":68,"second":89,"amount":-1},{"first":68,"second":88,"amount":0},{"first":68,"second":86,"amount":0},{"first":68,"second":44,"amount":-2},{"first":68,"second":46,"amount":-2},{"first":68,"second":1040,"amount":0},{"first":68,"second":1044,"amount":-1},{"first":68,"second":1046,"amount":0},{"first":68,"second":1051,"amount":-1},{"first":68,"second":1058,"amount":-1},{"first":68,"second":1061,"amount":0},{"first":68,"second":1068,"amount":-1},{"first":68,"second":196,"amount":0},{"first":68,"second":955,"amount":0},{"first":68,"second":933,"amount":-1},{"first":68,"second":913,"amount":0},{"first":68,"second":931,"amount":0},{"first":68,"second":916,"amount":0},{"first":68,"second":926,"amount":0},{"first":68,"second":923,"amount":0},{"first":68,"second":918,"amount":0},{"first":68,"second":935,"amount":0},{"first":68,"second":197,"amount":0},{"first":68,"second":198,"amount":-1},{"first":70,"second":97,"amount":-1},{"first":70,"second":101,"amount":0},{"first":70,"second":114,"amount":-1},{"first":70,"second":121,"amount":0},{"first":70,"second":117,"amount":0},{"first":70,"second":111,"amount":0},{"first":70,"second":113,"amount":0},{"first":70,"second":100,"amount":0},{"first":70,"second":103,"amount":0},{"first":70,"second":99,"amount":0},{"first":70,"second":118,"amount":0},{"first":70,"second":65,"amount":-3},{"first":70,"second":84,"amount":0},{"first":70,"second":74,"amount":-5},{"first":70,"second":44,"amount":-5},{"first":70,"second":46,"amount":-5},{"first":70,"second":1040,"amount":-3},{"first":70,"second":1072,"amount":-1},{"first":70,"second":1077,"amount":0},{"first":70,"second":1105,"amount":0},{"first":70,"second":1086,"amount":0},{"first":70,"second":1089,"amount":0},{"first":70,"second":1058,"amount":0},{"first":70,"second":1091,"amount":0},{"first":70,"second":1092,"amount":0},{"first":70,"second":252,"amount":0},{"first":70,"second":246,"amount":0},{"first":70,"second":228,"amount":-1},{"first":70,"second":196,"amount":-3},{"first":70,"second":962,"amount":0},{"first":70,"second":965,"amount":0},{"first":70,"second":959,"amount":0},{"first":70,"second":945,"amount":0},{"first":70,"second":963,"amount":0},{"first":70,"second":947,"amount":0},{"first":70,"second":957,"amount":0},{"first":70,"second":913,"amount":-3},{"first":70,"second":916,"amount":-3},{"first":70,"second":923,"amount":-3},{"first":70,"second":229,"amount":-1},{"first":70,"second":197,"amount":-3},{"first":72,"second":65,"amount":0},{"first":72,"second":84,"amount":-1},{"first":72,"second":89,"amount":-1},{"first":72,"second":88,"amount":0},{"first":72,"second":1040,"amount":0},{"first":72,"second":1044,"amount":0},{"first":72,"second":1076,"amount":0},{"first":72,"second":1046,"amount":0},{"first":72,"second":1051,"amount":0},{"first":72,"second":1083,"amount":0},{"first":72,"second":1058,"amount":-1},{"first":72,"second":1061,"amount":0},{"first":72,"second":1063,"amount":-1},{"first":72,"second":1095,"amount":-1},{"first":72,"second":196,"amount":0},{"first":72,"second":933,"amount":-1},{"first":72,"second":913,"amount":0},{"first":72,"second":916,"amount":0},{"first":72,"second":923,"amount":0},{"first":72,"second":935,"amount":0},{"first":72,"second":197,"amount":0},{"first":74,"second":65,"amount":0},{"first":74,"second":1040,"amount":0},{"first":74,"second":196,"amount":0},{"first":74,"second":913,"amount":0},{"first":74,"second":916,"amount":0},{"first":74,"second":923,"amount":0},{"first":74,"second":197,"amount":0},{"first":75,"second":101,"amount":-1},{"first":75,"second":121,"amount":-1},{"first":75,"second":117,"amount":0},{"first":75,"second":111,"amount":-1},{"first":75,"second":112,"amount":0},{"first":75,"second":113,"amount":-1},{"first":75,"second":100,"amount":-1},{"first":75,"second":103,"amount":-1},{"first":75,"second":109,"amount":0},{"first":75,"second":119,"amount":-1},{"first":75,"second":99,"amount":-1},{"first":75,"second":118,"amount":-1},{"first":75,"second":110,"amount":0},{"first":75,"second":79,"amount":-1},{"first":75,"second":81,"amount":-1},{"first":75,"second":71,"amount":-1},{"first":75,"second":67,"amount":-1},{"first":75,"second":45,"amount":-1},{"first":75,"second":8211,"amount":-1},{"first":75,"second":1073,"amount":-1},{"first":75,"second":1075,"amount":0},{"first":75,"second":1077,"amount":-1},{"first":75,"second":1105,"amount":-1},{"first":75,"second":1080,"amount":0},{"first":75,"second":1081,"amount":0},{"first":75,"second":1082,"amount":0},{"first":75,"second":1084,"amount":0},{"first":75,"second":1085,"amount":0},{"first":75,"second":1054,"amount":-1},{"first":75,"second":1086,"amount":-1},{"first":75,"second":1087,"amount":0},{"first":75,"second":1088,"amount":0},{"first":75,"second":1057,"amount":-1},{"first":75,"second":1089,"amount":-1},{"first":75,"second":1090,"amount":-1},{"first":75,"second":1091,"amount":-1},{"first":75,"second":1092,"amount":-1},{"first":75,"second":1094,"amount":0},{"first":75,"second":1095,"amount":-2},{"first":75,"second":1096,"amount":0},{"first":75,"second":1097,"amount":0},{"first":75,"second":1100,"amount":0},{"first":75,"second":1102,"amount":0},{"first":75,"second":252,"amount":0},{"first":75,"second":246,"amount":-1},{"first":75,"second":214,"amount":-1},{"first":75,"second":241,"amount":0},{"first":75,"second":962,"amount":-1},{"first":75,"second":964,"amount":-2},{"first":75,"second":965,"amount":0},{"first":75,"second":959,"amount":-1},{"first":75,"second":945,"amount":-1},{"first":75,"second":963,"amount":-1},{"first":75,"second":947,"amount":-1},{"first":75,"second":951,"amount":0},{"first":75,"second":957,"amount":-1},{"first":75,"second":920,"amount":-1},{"first":75,"second":927,"amount":-1},{"first":75,"second":934,"amount":-1},{"first":75,"second":216,"amount":-1},{"first":76,"second":121,"amount":-3},{"first":76,"second":117,"amount":-1},{"first":76,"second":119,"amount":-2},{"first":76,"second":118,"amount":-3},{"first":76,"second":65,"amount":0},{"first":76,"second":84,"amount":-6},{"first":76,"second":89,"amount":-5},{"first":76,"second":85,"amount":-1},{"first":76,"second":79,"amount":-1},{"first":76,"second":81,"amount":-1},{"first":76,"second":71,"amount":-1},{"first":76,"second":87,"amount":-3},{"first":76,"second":67,"amount":-1},{"first":76,"second":86,"amount":-4},{"first":76,"second":34,"amount":-7},{"first":76,"second":39,"amount":-7},{"first":76,"second":1040,"amount":0},{"first":76,"second":1054,"amount":-1},{"first":76,"second":1057,"amount":-1},{"first":76,"second":1058,"amount":-6},{"first":76,"second":1091,"amount":-3},{"first":76,"second":252,"amount":-1},{"first":76,"second":220,"amount":-1},{"first":76,"second":214,"amount":-1},{"first":76,"second":196,"amount":0},{"first":76,"second":965,"amount":-1},{"first":76,"second":947,"amount":-3},{"first":76,"second":957,"amount":-3},{"first":76,"second":933,"amount":-5},{"first":76,"second":920,"amount":-1},{"first":76,"second":927,"amount":-1},{"first":76,"second":913,"amount":0},{"first":76,"second":916,"amount":0},{"first":76,"second":923,"amount":0},{"first":76,"second":197,"amount":0},{"first":76,"second":216,"amount":-1},{"first":77,"second":65,"amount":0},{"first":77,"second":84,"amount":-1},{"first":77,"second":89,"amount":-1},{"first":77,"second":88,"amount":0},{"first":77,"second":1040,"amount":0},{"first":77,"second":1044,"amount":0},{"first":77,"second":1076,"amount":0},{"first":77,"second":1046,"amount":0},{"first":77,"second":1051,"amount":0},{"first":77,"second":1083,"amount":0},{"first":77,"second":1058,"amount":-1},{"first":77,"second":1061,"amount":0},{"first":77,"second":1063,"amount":-1},{"first":77,"second":1095,"amount":-1},{"first":77,"second":196,"amount":0},{"first":77,"second":933,"amount":-1},{"first":77,"second":913,"amount":0},{"first":77,"second":916,"amount":0},{"first":77,"second":923,"amount":0},{"first":77,"second":935,"amount":0},{"first":77,"second":197,"amount":0},{"first":87,"second":97,"amount":-1},{"first":87,"second":101,"amount":-1},{"first":87,"second":114,"amount":0},{"first":87,"second":117,"amount":0},{"first":87,"second":111,"amount":-1},{"first":87,"second":113,"amount":-1},{"first":87,"second":100,"amount":-1},{"first":87,"second":103,"amount":-1},{"first":87,"second":99,"amount":-1},{"first":87,"second":65,"amount":-1},{"first":87,"second":84,"amount":0},{"first":87,"second":45,"amount":-1},{"first":87,"second":8211,"amount":-1},{"first":87,"second":44,"amount":-3},{"first":87,"second":46,"amount":-3},{"first":87,"second":125,"amount":0},{"first":87,"second":41,"amount":0},{"first":87,"second":93,"amount":0},{"first":87,"second":1040,"amount":-1},{"first":87,"second":1072,"amount":-1},{"first":87,"second":1077,"amount":-1},{"first":87,"second":1105,"amount":-1},{"first":87,"second":1086,"amount":-1},{"first":87,"second":1089,"amount":-1},{"first":87,"second":1058,"amount":0},{"first":87,"second":1092,"amount":-1},{"first":87,"second":252,"amount":0},{"first":87,"second":246,"amount":-1},{"first":87,"second":228,"amount":-1},{"first":87,"second":196,"amount":-1},{"first":87,"second":962,"amount":-1},{"first":87,"second":965,"amount":0},{"first":87,"second":959,"amount":-1},{"first":87,"second":945,"amount":-1},{"first":87,"second":963,"amount":-1},{"first":87,"second":913,"amount":-1},{"first":87,"second":916,"amount":-1},{"first":87,"second":923,"amount":-1},{"first":87,"second":229,"amount":-1},{"first":87,"second":197,"amount":-1},{"first":88,"second":101,"amount":-1},{"first":88,"second":121,"amount":-1},{"first":88,"second":117,"amount":0},{"first":88,"second":111,"amount":0},{"first":88,"second":113,"amount":-1},{"first":88,"second":100,"amount":-1},{"first":88,"second":103,"amount":-1},{"first":88,"second":99,"amount":-1},{"first":88,"second":118,"amount":-1},{"first":88,"second":79,"amount":-1},{"first":88,"second":81,"amount":-1},{"first":88,"second":71,"amount":-1},{"first":88,"second":67,"amount":-1},{"first":88,"second":86,"amount":0},{"first":88,"second":45,"amount":-1},{"first":88,"second":8211,"amount":-1},{"first":88,"second":1073,"amount":0},{"first":88,"second":1044,"amount":0},{"first":88,"second":1077,"amount":-1},{"first":88,"second":1105,"amount":-1},{"first":88,"second":1051,"amount":0},{"first":88,"second":1083,"amount":0},{"first":88,"second":1054,"amount":-1},{"first":88,"second":1086,"amount":0},{"first":88,"second":1057,"amount":-1},{"first":88,"second":1089,"amount":-1},{"first":88,"second":1090,"amount":-1},{"first":88,"second":1091,"amount":-1},{"first":88,"second":1092,"amount":-1},{"first":88,"second":1095,"amount":-1},{"first":88,"second":252,"amount":0},{"first":88,"second":246,"amount":0},{"first":88,"second":214,"amount":-1},{"first":88,"second":962,"amount":-1},{"first":88,"second":964,"amount":-1},{"first":88,"second":965,"amount":0},{"first":88,"second":952,"amount":0},{"first":88,"second":959,"amount":0},{"first":88,"second":945,"amount":-1},{"first":88,"second":963,"amount":-1},{"first":88,"second":948,"amount":0},{"first":88,"second":966,"amount":-1},{"first":88,"second":947,"amount":-1},{"first":88,"second":955,"amount":0},{"first":88,"second":968,"amount":-1},{"first":88,"second":969,"amount":0},{"first":88,"second":957,"amount":-1},{"first":88,"second":920,"amount":-1},{"first":88,"second":927,"amount":-1},{"first":88,"second":934,"amount":-1},{"first":88,"second":216,"amount":-1},{"first":67,"second":84,"amount":-1},{"first":67,"second":125,"amount":0},{"first":67,"second":41,"amount":-1},{"first":67,"second":93,"amount":0},{"first":67,"second":1058,"amount":-1},{"first":86,"second":97,"amount":-1},{"first":86,"second":101,"amount":-1},{"first":86,"second":114,"amount":-1},{"first":86,"second":121,"amount":0},{"first":86,"second":117,"amount":-1},{"first":86,"second":111,"amount":-1},{"first":86,"second":113,"amount":-1},{"first":86,"second":100,"amount":-1},{"first":86,"second":103,"amount":-1},{"first":86,"second":99,"amount":-1},{"first":86,"second":118,"amount":0},{"first":86,"second":65,"amount":-2},{"first":86,"second":79,"amount":0},{"first":86,"second":81,"amount":0},{"first":86,"second":71,"amount":0},{"first":86,"second":67,"amount":0},{"first":86,"second":45,"amount":-1},{"first":86,"second":8211,"amount":-1},{"first":86,"second":44,"amount":-5},{"first":86,"second":46,"amount":-5},{"first":86,"second":125,"amount":0},{"first":86,"second":41,"amount":0},{"first":86,"second":93,"amount":0},{"first":86,"second":1040,"amount":-2},{"first":86,"second":1072,"amount":-1},{"first":86,"second":1077,"amount":-1},{"first":86,"second":1105,"amount":-1},{"first":86,"second":1054,"amount":0},{"first":86,"second":1086,"amount":-1},{"first":86,"second":1057,"amount":0},{"first":86,"second":1089,"amount":-1},{"first":86,"second":1091,"amount":0},{"first":86,"second":1092,"amount":-1},{"first":86,"second":252,"amount":-1},{"first":86,"second":246,"amount":-1},{"first":86,"second":214,"amount":0},{"first":86,"second":228,"amount":-1},{"first":86,"second":196,"amount":-2},{"first":86,"second":962,"amount":-1},{"first":86,"second":965,"amount":-1},{"first":86,"second":959,"amount":-1},{"first":86,"second":945,"amount":-1},{"first":86,"second":963,"amount":-1},{"first":86,"second":947,"amount":0},{"first":86,"second":957,"amount":0},{"first":86,"second":920,"amount":0},{"first":86,"second":927,"amount":0},{"first":86,"second":913,"amount":-2},{"first":86,"second":916,"amount":-2},{"first":86,"second":923,"amount":-2},{"first":86,"second":229,"amount":-1},{"first":86,"second":197,"amount":-2},{"first":86,"second":216,"amount":0},{"first":66,"second":84,"amount":-1},{"first":66,"second":89,"amount":-1},{"first":66,"second":86,"amount":0},{"first":66,"second":1058,"amount":-1},{"first":66,"second":1059,"amount":0},{"first":66,"second":933,"amount":-1},{"first":78,"second":65,"amount":0},{"first":78,"second":84,"amount":-1},{"first":78,"second":89,"amount":-1},{"first":78,"second":88,"amount":0},{"first":78,"second":1040,"amount":0},{"first":78,"second":1044,"amount":0},{"first":78,"second":1076,"amount":0},{"first":78,"second":1046,"amount":0},{"first":78,"second":1051,"amount":0},{"first":78,"second":1083,"amount":0},{"first":78,"second":1058,"amount":-1},{"first":78,"second":1061,"amount":0},{"first":78,"second":1063,"amount":-1},{"first":78,"second":1095,"amount":-1},{"first":78,"second":196,"amount":0},{"first":78,"second":933,"amount":-1},{"first":78,"second":913,"amount":0},{"first":78,"second":916,"amount":0},{"first":78,"second":923,"amount":0},{"first":78,"second":935,"amount":0},{"first":78,"second":197,"amount":0},{"first":47,"second":47,"amount":-5},{"first":44,"second":34,"amount":-3},{"first":44,"second":39,"amount":-3},{"first":46,"second":34,"amount":-3},{"first":46,"second":39,"amount":-3},{"first":123,"second":85,"amount":0},{"first":123,"second":74,"amount":0},{"first":123,"second":220,"amount":0},{"first":40,"second":89,"amount":0},{"first":40,"second":87,"amount":0},{"first":40,"second":86,"amount":0},{"first":40,"second":933,"amount":0},{"first":91,"second":85,"amount":0},{"first":91,"second":74,"amount":0},{"first":91,"second":220,"amount":0},{"first":34,"second":97,"amount":-1},{"first":34,"second":101,"amount":-1},{"first":34,"second":111,"amount":-1},{"first":34,"second":112,"amount":0},{"first":34,"second":113,"amount":-1},{"first":34,"second":115,"amount":-2},{"first":34,"second":100,"amount":-1},{"first":34,"second":103,"amount":-1},{"first":34,"second":109,"amount":0},{"first":34,"second":119,"amount":0},{"first":34,"second":99,"amount":-1},{"first":34,"second":110,"amount":0},{"first":34,"second":65,"amount":-2},{"first":34,"second":34,"amount":-2},{"first":34,"second":39,"amount":-2},{"first":34,"second":1040,"amount":-2},{"first":34,"second":1072,"amount":-1},{"first":34,"second":1075,"amount":0},{"first":34,"second":1077,"amount":-1},{"first":34,"second":1105,"amount":-1},{"first":34,"second":1080,"amount":0},{"first":34,"second":1081,"amount":0},{"first":34,"second":1082,"amount":0},{"first":34,"second":1084,"amount":0},{"first":34,"second":1085,"amount":0},{"first":34,"second":1086,"amount":-1},{"first":34,"second":1087,"amount":0},{"first":34,"second":1088,"amount":0},{"first":34,"second":1089,"amount":-1},{"first":34,"second":1092,"amount":-1},{"first":34,"second":1094,"amount":0},{"first":34,"second":1096,"amount":0},{"first":34,"second":1097,"amount":0},{"first":34,"second":1100,"amount":0},{"first":34,"second":1102,"amount":0},{"first":34,"second":246,"amount":-1},{"first":34,"second":228,"amount":-1},{"first":34,"second":196,"amount":-2},{"first":34,"second":241,"amount":0},{"first":34,"second":962,"amount":-1},{"first":34,"second":959,"amount":-1},{"first":34,"second":945,"amount":-1},{"first":34,"second":963,"amount":-1},{"first":34,"second":951,"amount":0},{"first":34,"second":913,"amount":-2},{"first":34,"second":916,"amount":-2},{"first":34,"second":923,"amount":-2},{"first":34,"second":229,"amount":-1},{"first":34,"second":197,"amount":-2},{"first":39,"second":97,"amount":-1},{"first":39,"second":101,"amount":-1},{"first":39,"second":111,"amount":-1},{"first":39,"second":112,"amount":0},{"first":39,"second":113,"amount":-1},{"first":39,"second":115,"amount":-2},{"first":39,"second":100,"amount":-1},{"first":39,"second":103,"amount":-1},{"first":39,"second":109,"amount":0},{"first":39,"second":119,"amount":0},{"first":39,"second":99,"amount":-1},{"first":39,"second":110,"amount":0},{"first":39,"second":65,"amount":-2},{"first":39,"second":34,"amount":-2},{"first":39,"second":39,"amount":-2},{"first":39,"second":1040,"amount":-2},{"first":39,"second":1072,"amount":-1},{"first":39,"second":1075,"amount":0},{"first":39,"second":1077,"amount":-1},{"first":39,"second":1105,"amount":-1},{"first":39,"second":1080,"amount":0},{"first":39,"second":1081,"amount":0},{"first":39,"second":1082,"amount":0},{"first":39,"second":1084,"amount":0},{"first":39,"second":1085,"amount":0},{"first":39,"second":1086,"amount":-1},{"first":39,"second":1087,"amount":0},{"first":39,"second":1088,"amount":0},{"first":39,"second":1089,"amount":-1},{"first":39,"second":1092,"amount":-1},{"first":39,"second":1094,"amount":0},{"first":39,"second":1096,"amount":0},{"first":39,"second":1097,"amount":0},{"first":39,"second":1100,"amount":0},{"first":39,"second":1102,"amount":0},{"first":39,"second":246,"amount":-1},{"first":39,"second":228,"amount":-1},{"first":39,"second":196,"amount":-2},{"first":39,"second":241,"amount":0},{"first":39,"second":962,"amount":-1},{"first":39,"second":959,"amount":-1},{"first":39,"second":945,"amount":-1},{"first":39,"second":963,"amount":-1},{"first":39,"second":951,"amount":0},{"first":39,"second":913,"amount":-2},{"first":39,"second":916,"amount":-2},{"first":39,"second":923,"amount":-2},{"first":39,"second":229,"amount":-1},{"first":39,"second":197,"amount":-2},{"first":1040,"second":122,"amount":0},{"first":1040,"second":116,"amount":0},{"first":1040,"second":121,"amount":-1},{"first":1040,"second":117,"amount":0},{"first":1040,"second":111,"amount":0},{"first":1040,"second":119,"amount":-1},{"first":1040,"second":118,"amount":-1},{"first":1040,"second":84,"amount":-3},{"first":1040,"second":89,"amount":-2},{"first":1040,"second":85,"amount":0},{"first":1040,"second":79,"amount":0},{"first":1040,"second":81,"amount":0},{"first":1040,"second":71,"amount":0},{"first":1040,"second":87,"amount":-1},{"first":1040,"second":67,"amount":0},{"first":1040,"second":86,"amount":-2},{"first":1040,"second":63,"amount":-1},{"first":1040,"second":34,"amount":-2},{"first":1040,"second":39,"amount":-2},{"first":1040,"second":1044,"amount":0},{"first":1040,"second":1051,"amount":0},{"first":1040,"second":1083,"amount":0},{"first":1040,"second":1054,"amount":0},{"first":1040,"second":1086,"amount":0},{"first":1040,"second":1057,"amount":0},{"first":1040,"second":1058,"amount":-3},{"first":1040,"second":1090,"amount":-1},{"first":1040,"second":1091,"amount":-1},{"first":1040,"second":1063,"amount":-1},{"first":1040,"second":1095,"amount":-2},{"first":1040,"second":1068,"amount":-1},{"first":1040,"second":252,"amount":0},{"first":1040,"second":220,"amount":0},{"first":1040,"second":246,"amount":0},{"first":1040,"second":214,"amount":0},{"first":1040,"second":964,"amount":-1},{"first":1040,"second":965,"amount":0},{"first":1040,"second":959,"amount":0},{"first":1040,"second":947,"amount":-1},{"first":1040,"second":955,"amount":0},{"first":1040,"second":957,"amount":-1},{"first":1040,"second":933,"amount":-2},{"first":1040,"second":920,"amount":0},{"first":1040,"second":927,"amount":0},{"first":1040,"second":934,"amount":-1},{"first":1040,"second":936,"amount":-1},{"first":1040,"second":216,"amount":0},{"first":1072,"second":121,"amount":0},{"first":1072,"second":118,"amount":0},{"first":1072,"second":34,"amount":-1},{"first":1072,"second":39,"amount":-1},{"first":1072,"second":1090,"amount":0},{"first":1072,"second":1091,"amount":0},{"first":1072,"second":947,"amount":0},{"first":1072,"second":957,"amount":0},{"first":1041,"second":120,"amount":0},{"first":1041,"second":84,"amount":-1},{"first":1041,"second":89,"amount":-1},{"first":1041,"second":88,"amount":0},{"first":1041,"second":86,"amount":-1},{"first":1041,"second":1046,"amount":0},{"first":1041,"second":1078,"amount":0},{"first":1041,"second":1058,"amount":-1},{"first":1041,"second":1090,"amount":-1},{"first":1041,"second":1059,"amount":0},{"first":1041,"second":1061,"amount":0},{"first":1041,"second":1093,"amount":0},{"first":1041,"second":1063,"amount":0},{"first":1041,"second":1068,"amount":-1},{"first":1041,"second":933,"amount":-1},{"first":1041,"second":935,"amount":0},{"first":1073,"second":112,"amount":0},{"first":1073,"second":109,"amount":0},{"first":1073,"second":120,"amount":0},{"first":1073,"second":110,"amount":0},{"first":1073,"second":1075,"amount":0},{"first":1073,"second":1076,"amount":0},{"first":1073,"second":1078,"amount":0},{"first":1073,"second":1080,"amount":0},{"first":1073,"second":1081,"amount":0},{"first":1073,"second":1082,"amount":0},{"first":1073,"second":1084,"amount":0},{"first":1073,"second":1085,"amount":0},{"first":1073,"second":1087,"amount":0},{"first":1073,"second":1088,"amount":0},{"first":1073,"second":1090,"amount":0},{"first":1073,"second":1093,"amount":0},{"first":1073,"second":1094,"amount":0},{"first":1073,"second":1096,"amount":0},{"first":1073,"second":1097,"amount":0},{"first":1073,"second":1100,"amount":0},{"first":1073,"second":1102,"amount":0},{"first":1073,"second":241,"amount":0},{"first":1073,"second":951,"amount":0},{"first":1042,"second":84,"amount":-1},{"first":1042,"second":89,"amount":-1},{"first":1042,"second":86,"amount":0},{"first":1042,"second":1058,"amount":-1},{"first":1042,"second":1059,"amount":0},{"first":1042,"second":933,"amount":-1},{"first":1074,"second":121,"amount":0},{"first":1074,"second":118,"amount":0},{"first":1074,"second":34,"amount":0},{"first":1074,"second":39,"amount":0},{"first":1074,"second":1090,"amount":0},{"first":1074,"second":1091,"amount":0},{"first":1074,"second":947,"amount":0},{"first":1074,"second":957,"amount":0},{"first":1043,"second":97,"amount":-4},{"first":1043,"second":122,"amount":-3},{"first":1043,"second":101,"amount":-4},{"first":1043,"second":114,"amount":-3},{"first":1043,"second":121,"amount":-3},{"first":1043,"second":117,"amount":-4},{"first":1043,"second":111,"amount":-4},{"first":1043,"second":112,"amount":-4},{"first":1043,"second":113,"amount":-4},{"first":1043,"second":115,"amount":-4},{"first":1043,"second":100,"amount":-4},{"first":1043,"second":103,"amount":-4},{"first":1043,"second":109,"amount":-4},{"first":1043,"second":119,"amount":-2},{"first":1043,"second":120,"amount":-3},{"first":1043,"second":99,"amount":-4},{"first":1043,"second":118,"amount":-3},{"first":1043,"second":110,"amount":-4},{"first":1043,"second":65,"amount":-4},{"first":1043,"second":84,"amount":0},{"first":1043,"second":89,"amount":0},{"first":1043,"second":79,"amount":-1},{"first":1043,"second":81,"amount":-1},{"first":1043,"second":83,"amount":-1},{"first":1043,"second":71,"amount":-1},{"first":1043,"second":87,"amount":0},{"first":1043,"second":67,"amount":-1},{"first":1043,"second":86,"amount":0},{"first":1043,"second":45,"amount":-8},{"first":1043,"second":8211,"amount":-8},{"first":1043,"second":44,"amount":-8},{"first":1043,"second":46,"amount":-8},{"first":1043,"second":1040,"amount":-4},{"first":1043,"second":1072,"amount":-4},{"first":1043,"second":1073,"amount":-1},{"first":1043,"second":1074,"amount":-4},{"first":1043,"second":1075,"amount":-4},{"first":1043,"second":1044,"amount":-4},{"first":1043,"second":1076,"amount":-5},{"first":1043,"second":1077,"amount":-4},{"first":1043,"second":1105,"amount":-4},{"first":1043,"second":1078,"amount":-3},{"first":1043,"second":1079,"amount":-5},{"first":1043,"second":1080,"amount":-4},{"first":1043,"second":1081,"amount":-4},{"first":1043,"second":1082,"amount":-4},{"first":1043,"second":1051,"amount":-2},{"first":1043,"second":1083,"amount":-5},{"first":1043,"second":1084,"amount":-4},{"first":1043,"second":1085,"amount":-4},{"first":1043,"second":1054,"amount":-1},{"first":1043,"second":1086,"amount":-4},{"first":1043,"second":1087,"amount":-4},{"first":1043,"second":1088,"amount":-4},{"first":1043,"second":1057,"amount":-1},{"first":1043,"second":1089,"amount":-4},{"first":1043,"second":1058,"amount":0},{"first":1043,"second":1090,"amount":-3},{"first":1043,"second":1091,"amount":-3},{"first":1043,"second":1092,"amount":-4},{"first":1043,"second":1093,"amount":-3},{"first":1043,"second":1094,"amount":-4},{"first":1043,"second":1095,"amount":-5},{"first":1043,"second":1096,"amount":-4},{"first":1043,"second":1097,"amount":-4},{"first":1043,"second":1099,"amount":-5},{"first":1043,"second":1068,"amount":0},{"first":1043,"second":1100,"amount":-4},{"first":1043,"second":1101,"amount":-5},{"first":1043,"second":1102,"amount":-4},{"first":1043,"second":1103,"amount":-5},{"first":1043,"second":252,"amount":-4},{"first":1043,"second":246,"amount":-4},{"first":1043,"second":214,"amount":-1},{"first":1043,"second":228,"amount":-4},{"first":1043,"second":196,"amount":-4},{"first":1043,"second":241,"amount":-4},{"first":1043,"second":962,"amount":-4},{"first":1043,"second":949,"amount":-5},{"first":1043,"second":961,"amount":-6},{"first":1043,"second":964,"amount":-4},{"first":1043,"second":965,"amount":-4},{"first":1043,"second":953,"amount":-6},{"first":1043,"second":959,"amount":-4},{"first":1043,"second":960,"amount":-5},{"first":1043,"second":945,"amount":-4},{"first":1043,"second":963,"amount":-4},{"first":1043,"second":948,"amount":-2},{"first":1043,"second":966,"amount":-6},{"first":1043,"second":947,"amount":-3},{"first":1043,"second":951,"amount":-4},{"first":1043,"second":968,"amount":-5},{"first":1043,"second":969,"amount":-6},{"first":1043,"second":957,"amount":-3},{"first":1043,"second":933,"amount":0},{"first":1043,"second":920,"amount":-1},{"first":1043,"second":927,"amount":-1},{"first":1043,"second":913,"amount":-4},{"first":1043,"second":916,"amount":-4},{"first":1043,"second":934,"amount":-3},{"first":1043,"second":923,"amount":-4},{"first":1043,"second":229,"amount":-4},{"first":1043,"second":197,"amount":-4},{"first":1043,"second":230,"amount":-4},{"first":1043,"second":198,"amount":-7},{"first":1043,"second":248,"amount":-4},{"first":1043,"second":216,"amount":-1},{"first":1075,"second":101,"amount":0},{"first":1075,"second":111,"amount":0},{"first":1075,"second":113,"amount":0},{"first":1075,"second":100,"amount":0},{"first":1075,"second":103,"amount":0},{"first":1075,"second":99,"amount":0},{"first":1075,"second":1076,"amount":-1},{"first":1075,"second":1077,"amount":0},{"first":1075,"second":1105,"amount":0},{"first":1075,"second":1083,"amount":-1},{"first":1075,"second":1086,"amount":0},{"first":1075,"second":1089,"amount":0},{"first":1075,"second":1092,"amount":0},{"first":1075,"second":246,"amount":0},{"first":1075,"second":962,"amount":0},{"first":1075,"second":959,"amount":0},{"first":1075,"second":945,"amount":0},{"first":1075,"second":963,"amount":0},{"first":1044,"second":65,"amount":0},{"first":1044,"second":84,"amount":-1},{"first":1044,"second":89,"amount":-1},{"first":1044,"second":79,"amount":0},{"first":1044,"second":81,"amount":0},{"first":1044,"second":71,"amount":0},{"first":1044,"second":67,"amount":0},{"first":1044,"second":86,"amount":-1},{"first":1044,"second":1040,"amount":0},{"first":1044,"second":1044,"amount":0},{"first":1044,"second":1076,"amount":0},{"first":1044,"second":1051,"amount":0},{"first":1044,"second":1083,"amount":0},{"first":1044,"second":1054,"amount":0},{"first":1044,"second":1057,"amount":0},{"first":1044,"second":1058,"amount":-1},{"first":1044,"second":1063,"amount":-1},{"first":1044,"second":1095,"amount":-1},{"first":1044,"second":1068,"amount":-1},{"first":1044,"second":214,"amount":0},{"first":1044,"second":196,"amount":0},{"first":1044,"second":933,"amount":-1},{"first":1044,"second":920,"amount":0},{"first":1044,"second":927,"amount":0},{"first":1044,"second":913,"amount":0},{"first":1044,"second":916,"amount":0},{"first":1044,"second":923,"amount":0},{"first":1044,"second":197,"amount":0},{"first":1044,"second":216,"amount":0},{"first":1076,"second":1076,"amount":0},{"first":1076,"second":1090,"amount":0},{"first":1076,"second":1095,"amount":0},{"first":1076,"second":1098,"amount":-1},{"first":1045,"second":101,"amount":0},{"first":1045,"second":121,"amount":-1},{"first":1045,"second":117,"amount":0},{"first":1045,"second":111,"amount":0},{"first":1045,"second":113,"amount":0},{"first":1045,"second":100,"amount":0},{"first":1045,"second":102,"amount":0},{"first":1045,"second":103,"amount":0},{"first":1045,"second":119,"amount":0},{"first":1045,"second":99,"amount":0},{"first":1045,"second":118,"amount":-1},{"first":1045,"second":84,"amount":0},{"first":1045,"second":1077,"amount":0},{"first":1045,"second":1105,"amount":0},{"first":1045,"second":1086,"amount":0},{"first":1045,"second":1089,"amount":0},{"first":1045,"second":1058,"amount":0},{"first":1045,"second":1091,"amount":-1},{"first":1045,"second":1092,"amount":0},{"first":1045,"second":252,"amount":0},{"first":1045,"second":246,"amount":0},{"first":1045,"second":962,"amount":0},{"first":1045,"second":965,"amount":0},{"first":1045,"second":959,"amount":0},{"first":1045,"second":945,"amount":0},{"first":1045,"second":963,"amount":0},{"first":1045,"second":947,"amount":-1},{"first":1045,"second":957,"amount":-1},{"first":1077,"second":121,"amount":0},{"first":1077,"second":118,"amount":0},{"first":1077,"second":34,"amount":0},{"first":1077,"second":39,"amount":0},{"first":1077,"second":1090,"amount":0},{"first":1077,"second":1091,"amount":0},{"first":1077,"second":947,"amount":0},{"first":1077,"second":957,"amount":0},{"first":1025,"second":101,"amount":0},{"first":1025,"second":121,"amount":-1},{"first":1025,"second":117,"amount":0},{"first":1025,"second":111,"amount":0},{"first":1025,"second":113,"amount":0},{"first":1025,"second":100,"amount":0},{"first":1025,"second":102,"amount":0},{"first":1025,"second":103,"amount":0},{"first":1025,"second":119,"amount":0},{"first":1025,"second":99,"amount":0},{"first":1025,"second":118,"amount":-1},{"first":1025,"second":84,"amount":0},{"first":1025,"second":1077,"amount":0},{"first":1025,"second":1105,"amount":0},{"first":1025,"second":1086,"amount":0},{"first":1025,"second":1089,"amount":0},{"first":1025,"second":1058,"amount":0},{"first":1025,"second":1091,"amount":-1},{"first":1025,"second":1092,"amount":0},{"first":1025,"second":252,"amount":0},{"first":1025,"second":246,"amount":0},{"first":1025,"second":962,"amount":0},{"first":1025,"second":965,"amount":0},{"first":1025,"second":959,"amount":0},{"first":1025,"second":945,"amount":0},{"first":1025,"second":963,"amount":0},{"first":1025,"second":947,"amount":-1},{"first":1025,"second":957,"amount":-1},{"first":1105,"second":121,"amount":0},{"first":1105,"second":118,"amount":0},{"first":1105,"second":34,"amount":0},{"first":1105,"second":39,"amount":0},{"first":1105,"second":1090,"amount":0},{"first":1105,"second":1091,"amount":0},{"first":1105,"second":947,"amount":0},{"first":1105,"second":957,"amount":0},{"first":1046,"second":101,"amount":-1},{"first":1046,"second":121,"amount":-1},{"first":1046,"second":117,"amount":0},{"first":1046,"second":111,"amount":0},{"first":1046,"second":113,"amount":-1},{"first":1046,"second":100,"amount":-1},{"first":1046,"second":103,"amount":-1},{"first":1046,"second":99,"amount":-1},{"first":1046,"second":118,"amount":-1},{"first":1046,"second":79,"amount":-1},{"first":1046,"second":81,"amount":-1},{"first":1046,"second":71,"amount":-1},{"first":1046,"second":67,"amount":-1},{"first":1046,"second":86,"amount":0},{"first":1046,"second":45,"amount":-1},{"first":1046,"second":8211,"amount":-1},{"first":1046,"second":1073,"amount":0},{"first":1046,"second":1044,"amount":0},{"first":1046,"second":1077,"amount":-1},{"first":1046,"second":1105,"amount":-1},{"first":1046,"second":1051,"amount":0},{"first":1046,"second":1083,"amount":0},{"first":1046,"second":1054,"amount":-1},{"first":1046,"second":1086,"amount":0},{"first":1046,"second":1057,"amount":-1},{"first":1046,"second":1089,"amount":-1},{"first":1046,"second":1090,"amount":-1},{"first":1046,"second":1091,"amount":-1},{"first":1046,"second":1092,"amount":-1},{"first":1046,"second":1095,"amount":-1},{"first":1046,"second":252,"amount":0},{"first":1046,"second":246,"amount":0},{"first":1046,"second":214,"amount":-1},{"first":1046,"second":962,"amount":-1},{"first":1046,"second":964,"amount":-1},{"first":1046,"second":965,"amount":0},{"first":1046,"second":952,"amount":0},{"first":1046,"second":959,"amount":0},{"first":1046,"second":945,"amount":-1},{"first":1046,"second":963,"amount":-1},{"first":1046,"second":948,"amount":0},{"first":1046,"second":966,"amount":-1},{"first":1046,"second":947,"amount":-1},{"first":1046,"second":955,"amount":0},{"first":1046,"second":968,"amount":-1},{"first":1046,"second":969,"amount":0},{"first":1046,"second":957,"amount":-1},{"first":1046,"second":920,"amount":-1},{"first":1046,"second":927,"amount":-1},{"first":1046,"second":934,"amount":-1},{"first":1046,"second":216,"amount":-1},{"first":1078,"second":101,"amount":0},{"first":1078,"second":111,"amount":0},{"first":1078,"second":113,"amount":0},{"first":1078,"second":100,"amount":0},{"first":1078,"second":103,"amount":0},{"first":1078,"second":99,"amount":0},{"first":1078,"second":1077,"amount":0},{"first":1078,"second":1105,"amount":0},{"first":1078,"second":1086,"amount":0},{"first":1078,"second":1089,"amount":0},{"first":1078,"second":1092,"amount":0},{"first":1078,"second":246,"amount":0},{"first":1078,"second":962,"amount":0},{"first":1078,"second":959,"amount":0},{"first":1078,"second":945,"amount":0},{"first":1078,"second":963,"amount":0},{"first":1047,"second":84,"amount":0},{"first":1047,"second":89,"amount":0},{"first":1047,"second":88,"amount":0},{"first":1047,"second":86,"amount":0},{"first":1047,"second":55,"amount":0},{"first":1047,"second":1046,"amount":0},{"first":1047,"second":1051,"amount":0},{"first":1047,"second":1058,"amount":0},{"first":1047,"second":1059,"amount":0},{"first":1047,"second":1061,"amount":0},{"first":1047,"second":1068,"amount":0},{"first":1047,"second":933,"amount":0},{"first":1047,"second":935,"amount":0},{"first":1079,"second":34,"amount":0},{"first":1079,"second":39,"amount":0},{"first":1048,"second":65,"amount":0},{"first":1048,"second":84,"amount":-1},{"first":1048,"second":89,"amount":-1},{"first":1048,"second":88,"amount":0},{"first":1048,"second":1040,"amount":0},{"first":1048,"second":1044,"amount":0},{"first":1048,"second":1076,"amount":0},{"first":1048,"second":1046,"amount":0},{"first":1048,"second":1051,"amount":0},{"first":1048,"second":1083,"amount":0},{"first":1048,"second":1058,"amount":-1},{"first":1048,"second":1061,"amount":0},{"first":1048,"second":1063,"amount":-1},{"first":1048,"second":1095,"amount":-1},{"first":1048,"second":196,"amount":0},{"first":1048,"second":933,"amount":-1},{"first":1048,"second":913,"amount":0},{"first":1048,"second":916,"amount":0},{"first":1048,"second":923,"amount":0},{"first":1048,"second":935,"amount":0},{"first":1048,"second":197,"amount":0},{"first":1050,"second":101,"amount":-1},{"first":1050,"second":121,"amount":-1},{"first":1050,"second":117,"amount":0},{"first":1050,"second":111,"amount":-1},{"first":1050,"second":112,"amount":0},{"first":1050,"second":113,"amount":-1},{"first":1050,"second":100,"amount":-1},{"first":1050,"second":103,"amount":-1},{"first":1050,"second":109,"amount":0},{"first":1050,"second":119,"amount":-1},{"first":1050,"second":99,"amount":-1},{"first":1050,"second":118,"amount":-1},{"first":1050,"second":110,"amount":0},{"first":1050,"second":79,"amount":-1},{"first":1050,"second":81,"amount":-1},{"first":1050,"second":71,"amount":-1},{"first":1050,"second":67,"amount":-1},{"first":1050,"second":45,"amount":-1},{"first":1050,"second":8211,"amount":-1},{"first":1050,"second":1073,"amount":-1},{"first":1050,"second":1075,"amount":0},{"first":1050,"second":1077,"amount":-1},{"first":1050,"second":1105,"amount":-1},{"first":1050,"second":1080,"amount":0},{"first":1050,"second":1081,"amount":0},{"first":1050,"second":1082,"amount":0},{"first":1050,"second":1084,"amount":0},{"first":1050,"second":1085,"amount":0},{"first":1050,"second":1054,"amount":-1},{"first":1050,"second":1086,"amount":-1},{"first":1050,"second":1087,"amount":0},{"first":1050,"second":1088,"amount":0},{"first":1050,"second":1057,"amount":-1},{"first":1050,"second":1089,"amount":-1},{"first":1050,"second":1090,"amount":-1},{"first":1050,"second":1091,"amount":-1},{"first":1050,"second":1092,"amount":-1},{"first":1050,"second":1094,"amount":0},{"first":1050,"second":1095,"amount":-2},{"first":1050,"second":1096,"amount":0},{"first":1050,"second":1097,"amount":0},{"first":1050,"second":1100,"amount":0},{"first":1050,"second":1102,"amount":0},{"first":1050,"second":252,"amount":0},{"first":1050,"second":246,"amount":-1},{"first":1050,"second":214,"amount":-1},{"first":1050,"second":241,"amount":0},{"first":1050,"second":962,"amount":-1},{"first":1050,"second":964,"amount":-2},{"first":1050,"second":965,"amount":0},{"first":1050,"second":959,"amount":-1},{"first":1050,"second":945,"amount":-1},{"first":1050,"second":963,"amount":-1},{"first":1050,"second":947,"amount":-1},{"first":1050,"second":951,"amount":0},{"first":1050,"second":957,"amount":-1},{"first":1050,"second":920,"amount":-1},{"first":1050,"second":927,"amount":-1},{"first":1050,"second":934,"amount":-1},{"first":1050,"second":216,"amount":-1},{"first":1082,"second":101,"amount":0},{"first":1082,"second":111,"amount":0},{"first":1082,"second":113,"amount":0},{"first":1082,"second":100,"amount":0},{"first":1082,"second":103,"amount":0},{"first":1082,"second":99,"amount":0},{"first":1082,"second":1077,"amount":0},{"first":1082,"second":1105,"amount":0},{"first":1082,"second":1086,"amount":0},{"first":1082,"second":1089,"amount":0},{"first":1082,"second":1092,"amount":0},{"first":1082,"second":246,"amount":0},{"first":1082,"second":962,"amount":0},{"first":1082,"second":959,"amount":0},{"first":1082,"second":945,"amount":0},{"first":1082,"second":963,"amount":0},{"first":1051,"second":65,"amount":0},{"first":1051,"second":84,"amount":-1},{"first":1051,"second":89,"amount":-1},{"first":1051,"second":88,"amount":0},{"first":1051,"second":1040,"amount":0},{"first":1051,"second":1044,"amount":0},{"first":1051,"second":1076,"amount":0},{"first":1051,"second":1046,"amount":0},{"first":1051,"second":1051,"amount":0},{"first":1051,"second":1083,"amount":0},{"first":1051,"second":1058,"amount":-1},{"first":1051,"second":1061,"amount":0},{"first":1051,"second":1063,"amount":-1},{"first":1051,"second":1095,"amount":-1},{"first":1051,"second":196,"amount":0},{"first":1051,"second":933,"amount":-1},{"first":1051,"second":913,"amount":0},{"first":1051,"second":916,"amount":0},{"first":1051,"second":923,"amount":0},{"first":1051,"second":935,"amount":0},{"first":1051,"second":197,"amount":0},{"first":1052,"second":65,"amount":0},{"first":1052,"second":84,"amount":-1},{"first":1052,"second":89,"amount":-1},{"first":1052,"second":88,"amount":0},{"first":1052,"second":1040,"amount":0},{"first":1052,"second":1044,"amount":0},{"first":1052,"second":1076,"amount":0},{"first":1052,"second":1046,"amount":0},{"first":1052,"second":1051,"amount":0},{"first":1052,"second":1083,"amount":0},{"first":1052,"second":1058,"amount":-1},{"first":1052,"second":1061,"amount":0},{"first":1052,"second":1063,"amount":-1},{"first":1052,"second":1095,"amount":-1},{"first":1052,"second":196,"amount":0},{"first":1052,"second":933,"amount":-1},{"first":1052,"second":913,"amount":0},{"first":1052,"second":916,"amount":0},{"first":1052,"second":923,"amount":0},{"first":1052,"second":935,"amount":0},{"first":1052,"second":197,"amount":0},{"first":1053,"second":65,"amount":0},{"first":1053,"second":84,"amount":-1},{"first":1053,"second":89,"amount":-1},{"first":1053,"second":88,"amount":0},{"first":1053,"second":1040,"amount":0},{"first":1053,"second":1044,"amount":0},{"first":1053,"second":1076,"amount":0},{"first":1053,"second":1046,"amount":0},{"first":1053,"second":1051,"amount":0},{"first":1053,"second":1083,"amount":0},{"first":1053,"second":1058,"amount":-1},{"first":1053,"second":1061,"amount":0},{"first":1053,"second":1063,"amount":-1},{"first":1053,"second":1095,"amount":-1},{"first":1053,"second":196,"amount":0},{"first":1053,"second":933,"amount":-1},{"first":1053,"second":913,"amount":0},{"first":1053,"second":916,"amount":0},{"first":1053,"second":923,"amount":0},{"first":1053,"second":935,"amount":0},{"first":1053,"second":197,"amount":0},{"first":1054,"second":65,"amount":0},{"first":1054,"second":90,"amount":0},{"first":1054,"second":84,"amount":-1},{"first":1054,"second":89,"amount":-1},{"first":1054,"second":88,"amount":0},{"first":1054,"second":86,"amount":0},{"first":1054,"second":44,"amount":-2},{"first":1054,"second":46,"amount":-2},{"first":1054,"second":1040,"amount":0},{"first":1054,"second":1044,"amount":-1},{"first":1054,"second":1046,"amount":0},{"first":1054,"second":1051,"amount":-1},{"first":1054,"second":1058,"amount":-1},{"first":1054,"second":1061,"amount":0},{"first":1054,"second":1068,"amount":-1},{"first":1054,"second":196,"amount":0},{"first":1054,"second":955,"amount":0},{"first":1054,"second":933,"amount":-1},{"first":1054,"second":913,"amount":0},{"first":1054,"second":931,"amount":0},{"first":1054,"second":916,"amount":0},{"first":1054,"second":926,"amount":0},{"first":1054,"second":923,"amount":0},{"first":1054,"second":918,"amount":0},{"first":1054,"second":935,"amount":0},{"first":1054,"second":197,"amount":0},{"first":1054,"second":198,"amount":-1},{"first":1086,"second":122,"amount":0},{"first":1086,"second":121,"amount":0},{"first":1086,"second":120,"amount":0},{"first":1086,"second":118,"amount":0},{"first":1086,"second":34,"amount":-3},{"first":1086,"second":39,"amount":-3},{"first":1086,"second":1076,"amount":-1},{"first":1086,"second":1078,"amount":0},{"first":1086,"second":1083,"amount":0},{"first":1086,"second":1090,"amount":0},{"first":1086,"second":1091,"amount":0},{"first":1086,"second":1093,"amount":0},{"first":1086,"second":964,"amount":0},{"first":1086,"second":947,"amount":0},{"first":1086,"second":957,"amount":0},{"first":1056,"second":97,"amount":0},{"first":1056,"second":101,"amount":0},{"first":1056,"second":116,"amount":0},{"first":1056,"second":121,"amount":0},{"first":1056,"second":111,"amount":0},{"first":1056,"second":113,"amount":0},{"first":1056,"second":100,"amount":0},{"first":1056,"second":103,"amount":0},{"first":1056,"second":99,"amount":0},{"first":1056,"second":118,"amount":0},{"first":1056,"second":65,"amount":-3},{"first":1056,"second":90,"amount":-1},{"first":1056,"second":74,"amount":-4},{"first":1056,"second":88,"amount":-1},{"first":1056,"second":44,"amount":-7},{"first":1056,"second":46,"amount":-7},{"first":1056,"second":1040,"amount":-3},{"first":1056,"second":1072,"amount":0},{"first":1056,"second":1044,"amount":-2},{"first":1056,"second":1076,"amount":-1},{"first":1056,"second":1077,"amount":0},{"first":1056,"second":1105,"amount":0},{"first":1056,"second":1046,"amount":-1},{"first":1056,"second":1051,"amount":-1},{"first":1056,"second":1083,"amount":-1},{"first":1056,"second":1086,"amount":0},{"first":1056,"second":1089,"amount":0},{"first":1056,"second":1091,"amount":0},{"first":1056,"second":1092,"amount":0},{"first":1056,"second":1061,"amount":-1},{"first":1056,"second":246,"amount":0},{"first":1056,"second":228,"amount":0},{"first":1056,"second":196,"amount":-3},{"first":1056,"second":962,"amount":0},{"first":1056,"second":961,"amount":-1},{"first":1056,"second":959,"amount":0},{"first":1056,"second":945,"amount":0},{"first":1056,"second":963,"amount":0},{"first":1056,"second":948,"amount":0},{"first":1056,"second":947,"amount":0},{"first":1056,"second":955,"amount":-1},{"first":1056,"second":957,"amount":0},{"first":1056,"second":913,"amount":-3},{"first":1056,"second":916,"amount":-3},{"first":1056,"second":923,"amount":-3},{"first":1056,"second":918,"amount":-1},{"first":1056,"second":935,"amount":-1},{"first":1056,"second":229,"amount":0},{"first":1056,"second":197,"amount":-3},{"first":1056,"second":198,"amount":-2},{"first":1088,"second":122,"amount":0},{"first":1088,"second":121,"amount":0},{"first":1088,"second":120,"amount":0},{"first":1088,"second":118,"amount":0},{"first":1088,"second":34,"amount":-1},{"first":1088,"second":39,"amount":-1},{"first":1088,"second":1076,"amount":0},{"first":1088,"second":1078,"amount":0},{"first":1088,"second":1083,"amount":0},{"first":1088,"second":1090,"amount":-2},{"first":1088,"second":1091,"amount":0},{"first":1088,"second":1093,"amount":0},{"first":1088,"second":964,"amount":0},{"first":1088,"second":947,"amount":0},{"first":1088,"second":957,"amount":0},{"first":1057,"second":84,"amount":-1},{"first":1057,"second":125,"amount":0},{"first":1057,"second":41,"amount":-1},{"first":1057,"second":93,"amount":0},{"first":1057,"second":1058,"amount":-1},{"first":1089,"second":34,"amount":0},{"first":1089,"second":39,"amount":0},{"first":1058,"second":97,"amount":-2},{"first":1058,"second":122,"amount":-1},{"first":1058,"second":101,"amount":-2},{"first":1058,"second":114,"amount":-2},{"first":1058,"second":121,"amount":-1},{"first":1058,"second":117,"amount":-2},{"first":1058,"second":111,"amount":-2},{"first":1058,"second":112,"amount":-2},{"first":1058,"second":113,"amount":-2},{"first":1058,"second":115,"amount":-2},{"first":1058,"second":100,"amount":-2},{"first":1058,"second":103,"amount":-2},{"first":1058,"second":109,"amount":-2},{"first":1058,"second":119,"amount":-1},{"first":1058,"second":120,"amount":-2},{"first":1058,"second":99,"amount":-2},{"first":1058,"second":118,"amount":-1},{"first":1058,"second":110,"amount":-2},{"first":1058,"second":65,"amount":-2},{"first":1058,"second":84,"amount":0},{"first":1058,"second":89,"amount":0},{"first":1058,"second":79,"amount":-1},{"first":1058,"second":81,"amount":-1},{"first":1058,"second":83,"amount":0},{"first":1058,"second":71,"amount":-1},{"first":1058,"second":74,"amount":-5},{"first":1058,"second":87,"amount":0},{"first":1058,"second":67,"amount":-1},{"first":1058,"second":86,"amount":0},{"first":1058,"second":45,"amount":-5},{"first":1058,"second":8211,"amount":-5},{"first":1058,"second":44,"amount":-4},{"first":1058,"second":46,"amount":-4},{"first":1058,"second":1040,"amount":-2},{"first":1058,"second":1072,"amount":-2},{"first":1058,"second":1073,"amount":-1},{"first":1058,"second":1074,"amount":-2},{"first":1058,"second":1075,"amount":-2},{"first":1058,"second":1044,"amount":-2},{"first":1058,"second":1076,"amount":-3},{"first":1058,"second":1077,"amount":-2},{"first":1058,"second":1105,"amount":-2},{"first":1058,"second":1078,"amount":-2},{"first":1058,"second":1079,"amount":-3},{"first":1058,"second":1080,"amount":-2},{"first":1058,"second":1081,"amount":-2},{"first":1058,"second":1082,"amount":-2},{"first":1058,"second":1051,"amount":-1},{"first":1058,"second":1083,"amount":-3},{"first":1058,"second":1084,"amount":-2},{"first":1058,"second":1085,"amount":-2},{"first":1058,"second":1054,"amount":-1},{"first":1058,"second":1086,"amount":-2},{"first":1058,"second":1087,"amount":-2},{"first":1058,"second":1088,"amount":-2},{"first":1058,"second":1057,"amount":-1},{"first":1058,"second":1089,"amount":-2},{"first":1058,"second":1058,"amount":0},{"first":1058,"second":1090,"amount":-2},{"first":1058,"second":1091,"amount":-1},{"first":1058,"second":1092,"amount":-2},{"first":1058,"second":1093,"amount":-2},{"first":1058,"second":1094,"amount":-2},{"first":1058,"second":1095,"amount":-3},{"first":1058,"second":1096,"amount":-2},{"first":1058,"second":1097,"amount":-2},{"first":1058,"second":1099,"amount":-3},{"first":1058,"second":1068,"amount":0},{"first":1058,"second":1100,"amount":-2},{"first":1058,"second":1101,"amount":-3},{"first":1058,"second":1102,"amount":-2},{"first":1058,"second":1103,"amount":-3},{"first":1058,"second":252,"amount":-2},{"first":1058,"second":246,"amount":-2},{"first":1058,"second":214,"amount":-1},{"first":1058,"second":228,"amount":-2},{"first":1058,"second":196,"amount":-2},{"first":1058,"second":241,"amount":-2},{"first":1058,"second":962,"amount":-2},{"first":1058,"second":949,"amount":-3},{"first":1058,"second":961,"amount":-3},{"first":1058,"second":964,"amount":-2},{"first":1058,"second":965,"amount":-2},{"first":1058,"second":953,"amount":-3},{"first":1058,"second":959,"amount":-2},{"first":1058,"second":960,"amount":-2},{"first":1058,"second":945,"amount":-2},{"first":1058,"second":963,"amount":-2},{"first":1058,"second":948,"amount":-1},{"first":1058,"second":966,"amount":-3},{"first":1058,"second":947,"amount":-1},{"first":1058,"second":951,"amount":-2},{"first":1058,"second":968,"amount":-3},{"first":1058,"second":969,"amount":-3},{"first":1058,"second":957,"amount":-1},{"first":1058,"second":933,"amount":0},{"first":1058,"second":920,"amount":-1},{"first":1058,"second":927,"amount":-1},{"first":1058,"second":913,"amount":-2},{"first":1058,"second":916,"amount":-2},{"first":1058,"second":934,"amount":-2},{"first":1058,"second":923,"amount":-2},{"first":1058,"second":229,"amount":-2},{"first":1058,"second":197,"amount":-2},{"first":1058,"second":230,"amount":-2},{"first":1058,"second":198,"amount":-4},{"first":1058,"second":248,"amount":-2},{"first":1058,"second":216,"amount":-1},{"first":1090,"second":97,"amount":0},{"first":1090,"second":101,"amount":-2},{"first":1090,"second":121,"amount":0},{"first":1090,"second":111,"amount":-1},{"first":1090,"second":113,"amount":-2},{"first":1090,"second":100,"amount":-2},{"first":1090,"second":102,"amount":0},{"first":1090,"second":103,"amount":-2},{"first":1090,"second":99,"amount":-2},{"first":1090,"second":118,"amount":0},{"first":1090,"second":34,"amount":0},{"first":1090,"second":39,"amount":0},{"first":1090,"second":1072,"amount":0},{"first":1090,"second":1076,"amount":-2},{"first":1090,"second":1077,"amount":-2},{"first":1090,"second":1105,"amount":-2},{"first":1090,"second":1083,"amount":-2},{"first":1090,"second":1086,"amount":-1},{"first":1090,"second":1089,"amount":-2},{"first":1090,"second":1091,"amount":0},{"first":1090,"second":1092,"amount":-2},{"first":1090,"second":246,"amount":-1},{"first":1090,"second":228,"amount":0},{"first":1090,"second":962,"amount":-1},{"first":1090,"second":961,"amount":-2},{"first":1090,"second":959,"amount":-1},{"first":1090,"second":945,"amount":-2},{"first":1090,"second":963,"amount":-2},{"first":1090,"second":948,"amount":-2},{"first":1090,"second":966,"amount":-1},{"first":1090,"second":947,"amount":0},{"first":1090,"second":957,"amount":0},{"first":1090,"second":229,"amount":0},{"first":1059,"second":97,"amount":-2},{"first":1059,"second":101,"amount":-1},{"first":1059,"second":111,"amount":-1},{"first":1059,"second":112,"amount":-2},{"first":1059,"second":113,"amount":-1},{"first":1059,"second":115,"amount":-1},{"first":1059,"second":100,"amount":-1},{"first":1059,"second":103,"amount":-1},{"first":1059,"second":109,"amount":-2},{"first":1059,"second":99,"amount":-1},{"first":1059,"second":110,"amount":-2},{"first":1059,"second":65,"amount":-2},{"first":1059,"second":84,"amount":0},{"first":1059,"second":89,"amount":0},{"first":1059,"second":79,"amount":0},{"first":1059,"second":81,"amount":0},{"first":1059,"second":71,"amount":0},{"first":1059,"second":67,"amount":0},{"first":1059,"second":45,"amount":-2},{"first":1059,"second":8211,"amount":-2},{"first":1059,"second":44,"amount":-8},{"first":1059,"second":46,"amount":-8},{"first":1059,"second":1040,"amount":-2},{"first":1059,"second":1072,"amount":-2},{"first":1059,"second":1074,"amount":-1},{"first":1059,"second":1075,"amount":-2},{"first":1059,"second":1044,"amount":-2},{"first":1059,"second":1076,"amount":-2},{"first":1059,"second":1077,"amount":-1},{"first":1059,"second":1105,"amount":-1},{"first":1059,"second":1079,"amount":-1},{"first":1059,"second":1080,"amount":-2},{"first":1059,"second":1081,"amount":-2},{"first":1059,"second":1082,"amount":-2},{"first":1059,"second":1051,"amount":-1},{"first":1059,"second":1083,"amount":-1},{"first":1059,"second":1084,"amount":-2},{"first":1059,"second":1085,"amount":-2},{"first":1059,"second":1054,"amount":0},{"first":1059,"second":1086,"amount":-1},{"first":1059,"second":1087,"amount":-2},{"first":1059,"second":1088,"amount":-2},{"first":1059,"second":1057,"amount":0},{"first":1059,"second":1089,"amount":-1},{"first":1059,"second":1058,"amount":0},{"first":1059,"second":1092,"amount":-1},{"first":1059,"second":1094,"amount":-2},{"first":1059,"second":1095,"amount":0},{"first":1059,"second":1096,"amount":-2},{"first":1059,"second":1097,"amount":-2},{"first":1059,"second":1099,"amount":-1},{"first":1059,"second":1068,"amount":0},{"first":1059,"second":1100,"amount":-2},{"first":1059,"second":1102,"amount":-2},{"first":1059,"second":1103,"amount":-1},{"first":1059,"second":246,"amount":-1},{"first":1059,"second":214,"amount":0},{"first":1059,"second":228,"amount":-2},{"first":1059,"second":196,"amount":-2},{"first":1059,"second":241,"amount":-2},{"first":1059,"second":962,"amount":-1},{"first":1059,"second":959,"amount":-1},{"first":1059,"second":945,"amount":-1},{"first":1059,"second":963,"amount":-1},{"first":1059,"second":951,"amount":-2},{"first":1059,"second":933,"amount":0},{"first":1059,"second":920,"amount":0},{"first":1059,"second":927,"amount":0},{"first":1059,"second":913,"amount":-2},{"first":1059,"second":916,"amount":-2},{"first":1059,"second":923,"amount":-2},{"first":1059,"second":229,"amount":-2},{"first":1059,"second":197,"amount":-2},{"first":1059,"second":216,"amount":0},{"first":1091,"second":97,"amount":0},{"first":1091,"second":101,"amount":0},{"first":1091,"second":111,"amount":0},{"first":1091,"second":113,"amount":0},{"first":1091,"second":100,"amount":0},{"first":1091,"second":102,"amount":0},{"first":1091,"second":103,"amount":0},{"first":1091,"second":99,"amount":0},{"first":1091,"second":44,"amount":-2},{"first":1091,"second":46,"amount":-2},{"first":1091,"second":34,"amount":0},{"first":1091,"second":39,"amount":0},{"first":1091,"second":1072,"amount":0},{"first":1091,"second":1076,"amount":-1},{"first":1091,"second":1077,"amount":0},{"first":1091,"second":1105,"amount":0},{"first":1091,"second":1083,"amount":-1},{"first":1091,"second":1086,"amount":0},{"first":1091,"second":1089,"amount":0},{"first":1091,"second":1092,"amount":0},{"first":1091,"second":246,"amount":0},{"first":1091,"second":228,"amount":0},{"first":1091,"second":962,"amount":0},{"first":1091,"second":961,"amount":0},{"first":1091,"second":964,"amount":0},{"first":1091,"second":959,"amount":0},{"first":1091,"second":960,"amount":0},{"first":1091,"second":945,"amount":0},{"first":1091,"second":963,"amount":0},{"first":1091,"second":948,"amount":0},{"first":1091,"second":229,"amount":0},{"first":1092,"second":122,"amount":0},{"first":1092,"second":121,"amount":0},{"first":1092,"second":120,"amount":0},{"first":1092,"second":118,"amount":0},{"first":1092,"second":34,"amount":-1},{"first":1092,"second":39,"amount":-1},{"first":1092,"second":1076,"amount":0},{"first":1092,"second":1078,"amount":0},{"first":1092,"second":1083,"amount":0},{"first":1092,"second":1090,"amount":-2},{"first":1092,"second":1091,"amount":0},{"first":1092,"second":1093,"amount":0},{"first":1092,"second":964,"amount":0},{"first":1092,"second":947,"amount":0},{"first":1092,"second":957,"amount":0},{"first":1061,"second":101,"amount":-1},{"first":1061,"second":121,"amount":-1},{"first":1061,"second":117,"amount":0},{"first":1061,"second":111,"amount":0},{"first":1061,"second":113,"amount":-1},{"first":1061,"second":100,"amount":-1},{"first":1061,"second":103,"amount":-1},{"first":1061,"second":99,"amount":-1},{"first":1061,"second":118,"amount":-1},{"first":1061,"second":79,"amount":-1},{"first":1061,"second":81,"amount":-1},{"first":1061,"second":71,"amount":-1},{"first":1061,"second":67,"amount":-1},{"first":1061,"second":86,"amount":0},{"first":1061,"second":45,"amount":-1},{"first":1061,"second":8211,"amount":-1},{"first":1061,"second":1073,"amount":0},{"first":1061,"second":1044,"amount":0},{"first":1061,"second":1077,"amount":-1},{"first":1061,"second":1105,"amount":-1},{"first":1061,"second":1051,"amount":0},{"first":1061,"second":1083,"amount":0},{"first":1061,"second":1054,"amount":-1},{"first":1061,"second":1086,"amount":0},{"first":1061,"second":1057,"amount":-1},{"first":1061,"second":1089,"amount":-1},{"first":1061,"second":1090,"amount":-1},{"first":1061,"second":1091,"amount":-1},{"first":1061,"second":1092,"amount":-1},{"first":1061,"second":1095,"amount":-1},{"first":1061,"second":252,"amount":0},{"first":1061,"second":246,"amount":0},{"first":1061,"second":214,"amount":-1},{"first":1061,"second":962,"amount":-1},{"first":1061,"second":964,"amount":-1},{"first":1061,"second":965,"amount":0},{"first":1061,"second":952,"amount":0},{"first":1061,"second":959,"amount":0},{"first":1061,"second":945,"amount":-1},{"first":1061,"second":963,"amount":-1},{"first":1061,"second":948,"amount":0},{"first":1061,"second":966,"amount":-1},{"first":1061,"second":947,"amount":-1},{"first":1061,"second":955,"amount":0},{"first":1061,"second":968,"amount":-1},{"first":1061,"second":969,"amount":0},{"first":1061,"second":957,"amount":-1},{"first":1061,"second":920,"amount":-1},{"first":1061,"second":927,"amount":-1},{"first":1061,"second":934,"amount":-1},{"first":1061,"second":216,"amount":-1},{"first":1093,"second":101,"amount":0},{"first":1093,"second":111,"amount":0},{"first":1093,"second":113,"amount":0},{"first":1093,"second":100,"amount":0},{"first":1093,"second":103,"amount":0},{"first":1093,"second":99,"amount":0},{"first":1093,"second":1077,"amount":0},{"first":1093,"second":1105,"amount":0},{"first":1093,"second":1086,"amount":0},{"first":1093,"second":1089,"amount":0},{"first":1093,"second":1092,"amount":0},{"first":1093,"second":246,"amount":0},{"first":1093,"second":962,"amount":0},{"first":1093,"second":959,"amount":0},{"first":1093,"second":945,"amount":0},{"first":1093,"second":963,"amount":0},{"first":1062,"second":65,"amount":0},{"first":1062,"second":84,"amount":-1},{"first":1062,"second":89,"amount":-1},{"first":1062,"second":88,"amount":0},{"first":1062,"second":1040,"amount":0},{"first":1062,"second":1044,"amount":0},{"first":1062,"second":1076,"amount":0},{"first":1062,"second":1046,"amount":0},{"first":1062,"second":1051,"amount":0},{"first":1062,"second":1083,"amount":0},{"first":1062,"second":1058,"amount":-1},{"first":1062,"second":1061,"amount":0},{"first":1062,"second":1063,"amount":-1},{"first":1062,"second":1095,"amount":-1},{"first":1062,"second":196,"amount":0},{"first":1062,"second":933,"amount":-1},{"first":1062,"second":913,"amount":0},{"first":1062,"second":916,"amount":0},{"first":1062,"second":923,"amount":0},{"first":1062,"second":935,"amount":0},{"first":1062,"second":197,"amount":0},{"first":1094,"second":1076,"amount":0},{"first":1094,"second":1083,"amount":0},{"first":1094,"second":1090,"amount":0},{"first":1094,"second":1095,"amount":0},{"first":1094,"second":1103,"amount":0},{"first":1063,"second":65,"amount":0},{"first":1063,"second":84,"amount":-1},{"first":1063,"second":89,"amount":-1},{"first":1063,"second":88,"amount":0},{"first":1063,"second":1040,"amount":0},{"first":1063,"second":1044,"amount":0},{"first":1063,"second":1076,"amount":0},{"first":1063,"second":1046,"amount":0},{"first":1063,"second":1051,"amount":0},{"first":1063,"second":1083,"amount":0},{"first":1063,"second":1058,"amount":-1},{"first":1063,"second":1061,"amount":0},{"first":1063,"second":1063,"amount":-1},{"first":1063,"second":1095,"amount":-1},{"first":1063,"second":196,"amount":0},{"first":1063,"second":933,"amount":-1},{"first":1063,"second":913,"amount":0},{"first":1063,"second":916,"amount":0},{"first":1063,"second":923,"amount":0},{"first":1063,"second":935,"amount":0},{"first":1063,"second":197,"amount":0},{"first":1064,"second":65,"amount":0},{"first":1064,"second":84,"amount":-1},{"first":1064,"second":89,"amount":-1},{"first":1064,"second":88,"amount":0},{"first":1064,"second":1040,"amount":0},{"first":1064,"second":1044,"amount":0},{"first":1064,"second":1076,"amount":0},{"first":1064,"second":1046,"amount":0},{"first":1064,"second":1051,"amount":0},{"first":1064,"second":1083,"amount":0},{"first":1064,"second":1058,"amount":-1},{"first":1064,"second":1061,"amount":0},{"first":1064,"second":1063,"amount":-1},{"first":1064,"second":1095,"amount":-1},{"first":1064,"second":196,"amount":0},{"first":1064,"second":933,"amount":-1},{"first":1064,"second":913,"amount":0},{"first":1064,"second":916,"amount":0},{"first":1064,"second":923,"amount":0},{"first":1064,"second":935,"amount":0},{"first":1064,"second":197,"amount":0},{"first":1065,"second":65,"amount":0},{"first":1065,"second":84,"amount":-1},{"first":1065,"second":89,"amount":-1},{"first":1065,"second":88,"amount":0},{"first":1065,"second":86,"amount":-1},{"first":1065,"second":1040,"amount":0},{"first":1065,"second":1044,"amount":0},{"first":1065,"second":1076,"amount":0},{"first":1065,"second":1046,"amount":0},{"first":1065,"second":1051,"amount":0},{"first":1065,"second":1083,"amount":0},{"first":1065,"second":1058,"amount":-1},{"first":1065,"second":1090,"amount":-1},{"first":1065,"second":1059,"amount":0},{"first":1065,"second":1061,"amount":0},{"first":1065,"second":1063,"amount":-1},{"first":1065,"second":1095,"amount":0},{"first":1065,"second":1068,"amount":-1},{"first":1065,"second":1069,"amount":0},{"first":1065,"second":196,"amount":0},{"first":1065,"second":933,"amount":-1},{"first":1065,"second":913,"amount":0},{"first":1065,"second":916,"amount":0},{"first":1065,"second":923,"amount":0},{"first":1065,"second":935,"amount":0},{"first":1065,"second":197,"amount":0},{"first":1097,"second":101,"amount":0},{"first":1097,"second":113,"amount":0},{"first":1097,"second":100,"amount":0},{"first":1097,"second":103,"amount":0},{"first":1097,"second":99,"amount":0},{"first":1097,"second":1076,"amount":1},{"first":1097,"second":1077,"amount":0},{"first":1097,"second":1105,"amount":0},{"first":1097,"second":1083,"amount":0},{"first":1097,"second":1089,"amount":0},{"first":1097,"second":1090,"amount":-1},{"first":1097,"second":1092,"amount":0},{"first":1097,"second":1095,"amount":0},{"first":1097,"second":962,"amount":0},{"first":1097,"second":945,"amount":0},{"first":1097,"second":963,"amount":0},{"first":1066,"second":120,"amount":-1},{"first":1066,"second":84,"amount":-5},{"first":1066,"second":89,"amount":-2},{"first":1066,"second":88,"amount":0},{"first":1066,"second":86,"amount":-1},{"first":1066,"second":34,"amount":-1},{"first":1066,"second":39,"amount":-1},{"first":1066,"second":1046,"amount":0},{"first":1066,"second":1078,"amount":-1},{"first":1066,"second":1051,"amount":0},{"first":1066,"second":1058,"amount":-5},{"first":1066,"second":1090,"amount":-1},{"first":1066,"second":1059,"amount":0},{"first":1066,"second":1061,"amount":0},{"first":1066,"second":1093,"amount":-1},{"first":1066,"second":1063,"amount":-1},{"first":1066,"second":1068,"amount":-1},{"first":1066,"second":933,"amount":-2},{"first":1066,"second":935,"amount":0},{"first":1098,"second":121,"amount":-1},{"first":1098,"second":120,"amount":0},{"first":1098,"second":118,"amount":-1},{"first":1098,"second":34,"amount":-3},{"first":1098,"second":39,"amount":-3},{"first":1098,"second":1078,"amount":0},{"first":1098,"second":1090,"amount":-1},{"first":1098,"second":1091,"amount":-1},{"first":1098,"second":1093,"amount":0},{"first":1098,"second":1095,"amount":-1},{"first":1098,"second":947,"amount":-1},{"first":1098,"second":957,"amount":-1},{"first":1067,"second":65,"amount":0},{"first":1067,"second":84,"amount":-1},{"first":1067,"second":89,"amount":-1},{"first":1067,"second":88,"amount":0},{"first":1067,"second":1040,"amount":0},{"first":1067,"second":1044,"amount":0},{"first":1067,"second":1076,"amount":0},{"first":1067,"second":1046,"amount":0},{"first":1067,"second":1051,"amount":0},{"first":1067,"second":1083,"amount":0},{"first":1067,"second":1058,"amount":-1},{"first":1067,"second":1061,"amount":0},{"first":1067,"second":1063,"amount":-1},{"first":1067,"second":1095,"amount":-1},{"first":1067,"second":196,"amount":0},{"first":1067,"second":933,"amount":-1},{"first":1067,"second":913,"amount":0},{"first":1067,"second":916,"amount":0},{"first":1067,"second":923,"amount":0},{"first":1067,"second":935,"amount":0},{"first":1067,"second":197,"amount":0},{"first":1068,"second":120,"amount":-1},{"first":1068,"second":84,"amount":-5},{"first":1068,"second":89,"amount":-2},{"first":1068,"second":88,"amount":0},{"first":1068,"second":86,"amount":-1},{"first":1068,"second":34,"amount":-1},{"first":1068,"second":39,"amount":-1},{"first":1068,"second":1046,"amount":0},{"first":1068,"second":1078,"amount":-1},{"first":1068,"second":1051,"amount":0},{"first":1068,"second":1058,"amount":-5},{"first":1068,"second":1090,"amount":-1},{"first":1068,"second":1059,"amount":0},{"first":1068,"second":1061,"amount":0},{"first":1068,"second":1093,"amount":-1},{"first":1068,"second":1063,"amount":-1},{"first":1068,"second":1068,"amount":-1},{"first":1068,"second":933,"amount":-2},{"first":1068,"second":935,"amount":0},{"first":1100,"second":121,"amount":-1},{"first":1100,"second":120,"amount":0},{"first":1100,"second":118,"amount":-1},{"first":1100,"second":34,"amount":-3},{"first":1100,"second":39,"amount":-3},{"first":1100,"second":1078,"amount":0},{"first":1100,"second":1090,"amount":-1},{"first":1100,"second":1091,"amount":-1},{"first":1100,"second":1093,"amount":0},{"first":1100,"second":1095,"amount":-1},{"first":1100,"second":947,"amount":-1},{"first":1100,"second":957,"amount":-1},{"first":1069,"second":84,"amount":-1},{"first":1069,"second":89,"amount":-1},{"first":1069,"second":88,"amount":-1},{"first":1069,"second":1044,"amount":-1},{"first":1069,"second":1046,"amount":-1},{"first":1069,"second":1051,"amount":-1},{"first":1069,"second":1083,"amount":0},{"first":1069,"second":1058,"amount":-1},{"first":1069,"second":1059,"amount":0},{"first":1069,"second":1061,"amount":-1},{"first":1069,"second":933,"amount":-1},{"first":1069,"second":935,"amount":-1},{"first":1101,"second":122,"amount":0},{"first":1101,"second":121,"amount":0},{"first":1101,"second":120,"amount":0},{"first":1101,"second":118,"amount":0},{"first":1101,"second":34,"amount":-1},{"first":1101,"second":39,"amount":-1},{"first":1101,"second":1076,"amount":0},{"first":1101,"second":1078,"amount":0},{"first":1101,"second":1083,"amount":0},{"first":1101,"second":1090,"amount":-2},{"first":1101,"second":1091,"amount":0},{"first":1101,"second":1093,"amount":0},{"first":1101,"second":964,"amount":0},{"first":1101,"second":947,"amount":0},{"first":1101,"second":957,"amount":0},{"first":1070,"second":84,"amount":-1},{"first":1070,"second":88,"amount":-1},{"first":1070,"second":1044,"amount":-1},{"first":1070,"second":1076,"amount":-1},{"first":1070,"second":1046,"amount":-1},{"first":1070,"second":1051,"amount":-1},{"first":1070,"second":1083,"amount":0},{"first":1070,"second":1058,"amount":-1},{"first":1070,"second":1059,"amount":0},{"first":1070,"second":1061,"amount":-1},{"first":1070,"second":935,"amount":-1},{"first":1102,"second":121,"amount":0},{"first":1102,"second":120,"amount":0},{"first":1102,"second":118,"amount":0},{"first":1102,"second":1076,"amount":0},{"first":1102,"second":1078,"amount":0},{"first":1102,"second":1083,"amount":0},{"first":1102,"second":1091,"amount":0},{"first":1102,"second":1093,"amount":0},{"first":1102,"second":947,"amount":0},{"first":1102,"second":957,"amount":0},{"first":1071,"second":84,"amount":0},{"first":1071,"second":89,"amount":0},{"first":1071,"second":1058,"amount":0},{"first":1071,"second":933,"amount":0},{"first":220,"second":65,"amount":0},{"first":220,"second":1040,"amount":0},{"first":220,"second":196,"amount":0},{"first":220,"second":913,"amount":0},{"first":220,"second":916,"amount":0},{"first":220,"second":923,"amount":0},{"first":220,"second":197,"amount":0},{"first":246,"second":122,"amount":0},{"first":246,"second":121,"amount":0},{"first":246,"second":120,"amount":0},{"first":246,"second":118,"amount":0},{"first":246,"second":34,"amount":-3},{"first":246,"second":39,"amount":-3},{"first":246,"second":1076,"amount":-1},{"first":246,"second":1078,"amount":0},{"first":246,"second":1083,"amount":0},{"first":246,"second":1090,"amount":0},{"first":246,"second":1091,"amount":0},{"first":246,"second":1093,"amount":0},{"first":246,"second":964,"amount":0},{"first":246,"second":947,"amount":0},{"first":246,"second":957,"amount":0},{"first":214,"second":65,"amount":0},{"first":214,"second":90,"amount":0},{"first":214,"second":84,"amount":-1},{"first":214,"second":89,"amount":-1},{"first":214,"second":88,"amount":0},{"first":214,"second":86,"amount":0},{"first":214,"second":44,"amount":-2},{"first":214,"second":46,"amount":-2},{"first":214,"second":1040,"amount":0},{"first":214,"second":1044,"amount":-1},{"first":214,"second":1046,"amount":0},{"first":214,"second":1051,"amount":-1},{"first":214,"second":1058,"amount":-1},{"first":214,"second":1061,"amount":0},{"first":214,"second":1068,"amount":-1},{"first":214,"second":196,"amount":0},{"first":214,"second":955,"amount":0},{"first":214,"second":933,"amount":-1},{"first":214,"second":913,"amount":0},{"first":214,"second":931,"amount":0},{"first":214,"second":916,"amount":0},{"first":214,"second":926,"amount":0},{"first":214,"second":923,"amount":0},{"first":214,"second":918,"amount":0},{"first":214,"second":935,"amount":0},{"first":214,"second":197,"amount":0},{"first":214,"second":198,"amount":-1},{"first":228,"second":121,"amount":0},{"first":228,"second":118,"amount":0},{"first":228,"second":34,"amount":-1},{"first":228,"second":39,"amount":-1},{"first":228,"second":1090,"amount":0},{"first":228,"second":1091,"amount":0},{"first":228,"second":947,"amount":0},{"first":228,"second":957,"amount":0},{"first":196,"second":122,"amount":0},{"first":196,"second":116,"amount":0},{"first":196,"second":121,"amount":-1},{"first":196,"second":117,"amount":0},{"first":196,"second":111,"amount":0},{"first":196,"second":119,"amount":-1},{"first":196,"second":118,"amount":-1},{"first":196,"second":84,"amount":-3},{"first":196,"second":89,"amount":-2},{"first":196,"second":85,"amount":0},{"first":196,"second":79,"amount":0},{"first":196,"second":81,"amount":0},{"first":196,"second":71,"amount":0},{"first":196,"second":87,"amount":-1},{"first":196,"second":67,"amount":0},{"first":196,"second":86,"amount":-2},{"first":196,"second":63,"amount":-1},{"first":196,"second":34,"amount":-2},{"first":196,"second":39,"amount":-2},{"first":196,"second":1044,"amount":0},{"first":196,"second":1051,"amount":0},{"first":196,"second":1083,"amount":0},{"first":196,"second":1054,"amount":0},{"first":196,"second":1086,"amount":0},{"first":196,"second":1057,"amount":0},{"first":196,"second":1058,"amount":-3},{"first":196,"second":1090,"amount":-1},{"first":196,"second":1091,"amount":-1},{"first":196,"second":1063,"amount":-1},{"first":196,"second":1095,"amount":-2},{"first":196,"second":1068,"amount":-1},{"first":196,"second":252,"amount":0},{"first":196,"second":220,"amount":0},{"first":196,"second":246,"amount":0},{"first":196,"second":214,"amount":0},{"first":196,"second":964,"amount":-1},{"first":196,"second":965,"amount":0},{"first":196,"second":959,"amount":0},{"first":196,"second":947,"amount":-1},{"first":196,"second":955,"amount":0},{"first":196,"second":957,"amount":-1},{"first":196,"second":933,"amount":-2},{"first":196,"second":920,"amount":0},{"first":196,"second":927,"amount":0},{"first":196,"second":934,"amount":-1},{"first":196,"second":936,"amount":-1},{"first":196,"second":216,"amount":0},{"first":241,"second":34,"amount":-2},{"first":241,"second":39,"amount":-2},{"first":241,"second":1090,"amount":-1},{"first":209,"second":65,"amount":0},{"first":209,"second":84,"amount":-1},{"first":209,"second":89,"amount":-1},{"first":209,"second":88,"amount":0},{"first":209,"second":1040,"amount":0},{"first":209,"second":1044,"amount":0},{"first":209,"second":1076,"amount":0},{"first":209,"second":1046,"amount":0},{"first":209,"second":1051,"amount":0},{"first":209,"second":1083,"amount":0},{"first":209,"second":1058,"amount":-1},{"first":209,"second":1061,"amount":0},{"first":209,"second":1063,"amount":-1},{"first":209,"second":1095,"amount":-1},{"first":209,"second":196,"amount":0},{"first":209,"second":933,"amount":-1},{"first":209,"second":913,"amount":0},{"first":209,"second":916,"amount":0},{"first":209,"second":923,"amount":0},{"first":209,"second":935,"amount":0},{"first":209,"second":197,"amount":0},{"first":962,"second":1090,"amount":-1},{"first":961,"second":122,"amount":0},{"first":961,"second":121,"amount":0},{"first":961,"second":120,"amount":0},{"first":961,"second":118,"amount":0},{"first":961,"second":34,"amount":-1},{"first":961,"second":39,"amount":-1},{"first":961,"second":1076,"amount":0},{"first":961,"second":1078,"amount":0},{"first":961,"second":1083,"amount":0},{"first":961,"second":1090,"amount":-2},{"first":961,"second":1091,"amount":0},{"first":961,"second":1093,"amount":0},{"first":961,"second":964,"amount":0},{"first":961,"second":947,"amount":0},{"first":961,"second":957,"amount":0},{"first":964,"second":101,"amount":0},{"first":964,"second":121,"amount":0},{"first":964,"second":111,"amount":0},{"first":964,"second":113,"amount":0},{"first":964,"second":100,"amount":0},{"first":964,"second":102,"amount":0},{"first":964,"second":103,"amount":0},{"first":964,"second":99,"amount":0},{"first":964,"second":118,"amount":0},{"first":964,"second":34,"amount":0},{"first":964,"second":39,"amount":0},{"first":964,"second":1077,"amount":0},{"first":964,"second":1105,"amount":0},{"first":964,"second":1086,"amount":0},{"first":964,"second":1089,"amount":0},{"first":964,"second":1091,"amount":0},{"first":964,"second":1092,"amount":0},{"first":964,"second":246,"amount":0},{"first":964,"second":962,"amount":0},{"first":964,"second":964,"amount":0},{"first":964,"second":959,"amount":0},{"first":964,"second":960,"amount":0},{"first":964,"second":945,"amount":0},{"first":964,"second":963,"amount":0},{"first":964,"second":948,"amount":0},{"first":964,"second":947,"amount":0},{"first":964,"second":957,"amount":0},{"first":965,"second":1090,"amount":-1},{"first":953,"second":101,"amount":0},{"first":953,"second":121,"amount":-1},{"first":953,"second":117,"amount":0},{"first":953,"second":113,"amount":0},{"first":953,"second":100,"amount":0},{"first":953,"second":103,"amount":0},{"first":953,"second":99,"amount":0},{"first":953,"second":118,"amount":-1},{"first":953,"second":34,"amount":-1},{"first":953,"second":39,"amount":-1},{"first":953,"second":1077,"amount":0},{"first":953,"second":1105,"amount":0},{"first":953,"second":1089,"amount":0},{"first":953,"second":1091,"amount":-1},{"first":953,"second":1092,"amount":0},{"first":953,"second":252,"amount":0},{"first":953,"second":962,"amount":0},{"first":953,"second":964,"amount":-1},{"first":953,"second":965,"amount":0},{"first":953,"second":952,"amount":0},{"first":953,"second":960,"amount":0},{"first":953,"second":945,"amount":0},{"first":953,"second":963,"amount":0},{"first":953,"second":966,"amount":-1},{"first":953,"second":947,"amount":-1},{"first":953,"second":955,"amount":0},{"first":953,"second":957,"amount":-1},{"first":959,"second":122,"amount":0},{"first":959,"second":121,"amount":0},{"first":959,"second":120,"amount":0},{"first":959,"second":118,"amount":0},{"first":959,"second":34,"amount":-3},{"first":959,"second":39,"amount":-3},{"first":959,"second":1076,"amount":-1},{"first":959,"second":1078,"amount":0},{"first":959,"second":1083,"amount":0},{"first":959,"second":1090,"amount":0},{"first":959,"second":1091,"amount":0},{"first":959,"second":1093,"amount":0},{"first":959,"second":964,"amount":0},{"first":959,"second":947,"amount":0},{"first":959,"second":957,"amount":0},{"first":945,"second":955,"amount":0},{"first":963,"second":964,"amount":0},{"first":948,"second":1090,"amount":-1},{"first":948,"second":964,"amount":0},{"first":966,"second":122,"amount":0},{"first":966,"second":120,"amount":0},{"first":966,"second":1078,"amount":0},{"first":966,"second":1090,"amount":-2},{"first":966,"second":1093,"amount":0},{"first":947,"second":97,"amount":0},{"first":947,"second":101,"amount":0},{"first":947,"second":111,"amount":0},{"first":947,"second":113,"amount":0},{"first":947,"second":100,"amount":0},{"first":947,"second":102,"amount":0},{"first":947,"second":103,"amount":0},{"first":947,"second":99,"amount":0},{"first":947,"second":44,"amount":-2},{"first":947,"second":46,"amount":-2},{"first":947,"second":34,"amount":0},{"first":947,"second":39,"amount":0},{"first":947,"second":1072,"amount":0},{"first":947,"second":1076,"amount":-1},{"first":947,"second":1077,"amount":0},{"first":947,"second":1105,"amount":0},{"first":947,"second":1083,"amount":-1},{"first":947,"second":1086,"amount":0},{"first":947,"second":1089,"amount":0},{"first":947,"second":1092,"amount":0},{"first":947,"second":246,"amount":0},{"first":947,"second":228,"amount":0},{"first":947,"second":962,"amount":0},{"first":947,"second":961,"amount":0},{"first":947,"second":964,"amount":0},{"first":947,"second":959,"amount":0},{"first":947,"second":960,"amount":0},{"first":947,"second":945,"amount":0},{"first":947,"second":963,"amount":0},{"first":947,"second":948,"amount":0},{"first":947,"second":229,"amount":0},{"first":951,"second":34,"amount":-2},{"first":951,"second":39,"amount":-2},{"first":951,"second":1090,"amount":-1},{"first":958,"second":101,"amount":-1},{"first":958,"second":113,"amount":-1},{"first":958,"second":100,"amount":-1},{"first":958,"second":103,"amount":-1},{"first":958,"second":99,"amount":-1},{"first":958,"second":1077,"amount":-1},{"first":958,"second":1105,"amount":-1},{"first":958,"second":1089,"amount":-1},{"first":958,"second":1092,"amount":-1},{"first":958,"second":962,"amount":-1},{"first":958,"second":945,"amount":-1},{"first":958,"second":963,"amount":-1},{"first":958,"second":955,"amount":0},{"first":955,"second":121,"amount":-1},{"first":955,"second":117,"amount":0},{"first":955,"second":102,"amount":0},{"first":955,"second":118,"amount":-1},{"first":955,"second":34,"amount":-2},{"first":955,"second":39,"amount":-2},{"first":955,"second":1091,"amount":-1},{"first":955,"second":252,"amount":0},{"first":955,"second":964,"amount":-5},{"first":955,"second":965,"amount":0},{"first":955,"second":952,"amount":0},{"first":955,"second":960,"amount":0},{"first":955,"second":947,"amount":-1},{"first":955,"second":955,"amount":0},{"first":955,"second":957,"amount":-1},{"first":950,"second":101,"amount":-1},{"first":950,"second":121,"amount":-1},{"first":950,"second":117,"amount":-1},{"first":950,"second":111,"amount":-1},{"first":950,"second":112,"amount":0},{"first":950,"second":113,"amount":-1},{"first":950,"second":100,"amount":-1},{"first":950,"second":103,"amount":-1},{"first":950,"second":109,"amount":0},{"first":950,"second":99,"amount":-1},{"first":950,"second":118,"amount":-1},{"first":950,"second":110,"amount":0},{"first":950,"second":1075,"amount":0},{"first":950,"second":1077,"amount":-1},{"first":950,"second":1105,"amount":-1},{"first":950,"second":1080,"amount":0},{"first":950,"second":1081,"amount":0},{"first":950,"second":1082,"amount":0},{"first":950,"second":1084,"amount":0},{"first":950,"second":1085,"amount":0},{"first":950,"second":1086,"amount":-1},{"first":950,"second":1087,"amount":0},{"first":950,"second":1088,"amount":0},{"first":950,"second":1089,"amount":-1},{"first":950,"second":1091,"amount":-1},{"first":950,"second":1092,"amount":-1},{"first":950,"second":1094,"amount":0},{"first":950,"second":1096,"amount":0},{"first":950,"second":1097,"amount":0},{"first":950,"second":1100,"amount":0},{"first":950,"second":1102,"amount":0},{"first":950,"second":252,"amount":-1},{"first":950,"second":246,"amount":-1},{"first":950,"second":241,"amount":0},{"first":950,"second":962,"amount":-1},{"first":950,"second":949,"amount":-1},{"first":950,"second":964,"amount":-1},{"first":950,"second":965,"amount":-1},{"first":950,"second":952,"amount":0},{"first":950,"second":953,"amount":0},{"first":950,"second":959,"amount":-1},{"first":950,"second":960,"amount":-1},{"first":950,"second":945,"amount":-1},{"first":950,"second":963,"amount":-1},{"first":950,"second":948,"amount":0},{"first":950,"second":966,"amount":-1},{"first":950,"second":947,"amount":-1},{"first":950,"second":951,"amount":0},{"first":950,"second":958,"amount":0},{"first":950,"second":968,"amount":-1},{"first":950,"second":969,"amount":-1},{"first":950,"second":957,"amount":-1},{"first":968,"second":122,"amount":0},{"first":968,"second":120,"amount":0},{"first":968,"second":1078,"amount":0},{"first":968,"second":1093,"amount":0},{"first":969,"second":122,"amount":0},{"first":969,"second":121,"amount":0},{"first":969,"second":120,"amount":0},{"first":969,"second":118,"amount":0},{"first":969,"second":1078,"amount":0},{"first":969,"second":1091,"amount":0},{"first":969,"second":1093,"amount":0},{"first":969,"second":947,"amount":0},{"first":969,"second":957,"amount":0},{"first":957,"second":97,"amount":0},{"first":957,"second":101,"amount":0},{"first":957,"second":111,"amount":0},{"first":957,"second":113,"amount":0},{"first":957,"second":100,"amount":0},{"first":957,"second":102,"amount":0},{"first":957,"second":103,"amount":0},{"first":957,"second":99,"amount":0},{"first":957,"second":44,"amount":-2},{"first":957,"second":46,"amount":-2},{"first":957,"second":34,"amount":0},{"first":957,"second":39,"amount":0},{"first":957,"second":1072,"amount":0},{"first":957,"second":1076,"amount":-1},{"first":957,"second":1077,"amount":0},{"first":957,"second":1105,"amount":0},{"first":957,"second":1083,"amount":-1},{"first":957,"second":1086,"amount":0},{"first":957,"second":1089,"amount":0},{"first":957,"second":1092,"amount":0},{"first":957,"second":246,"amount":0},{"first":957,"second":228,"amount":0},{"first":957,"second":962,"amount":0},{"first":957,"second":961,"amount":0},{"first":957,"second":964,"amount":0},{"first":957,"second":959,"amount":0},{"first":957,"second":960,"amount":0},{"first":957,"second":945,"amount":0},{"first":957,"second":963,"amount":0},{"first":957,"second":948,"amount":0},{"first":957,"second":229,"amount":0},{"first":917,"second":101,"amount":0},{"first":917,"second":121,"amount":-1},{"first":917,"second":117,"amount":0},{"first":917,"second":111,"amount":0},{"first":917,"second":113,"amount":0},{"first":917,"second":100,"amount":0},{"first":917,"second":102,"amount":0},{"first":917,"second":103,"amount":0},{"first":917,"second":119,"amount":0},{"first":917,"second":99,"amount":0},{"first":917,"second":118,"amount":-1},{"first":917,"second":84,"amount":0},{"first":917,"second":1077,"amount":0},{"first":917,"second":1105,"amount":0},{"first":917,"second":1086,"amount":0},{"first":917,"second":1089,"amount":0},{"first":917,"second":1058,"amount":0},{"first":917,"second":1091,"amount":-1},{"first":917,"second":1092,"amount":0},{"first":917,"second":252,"amount":0},{"first":917,"second":246,"amount":0},{"first":917,"second":962,"amount":0},{"first":917,"second":965,"amount":0},{"first":917,"second":959,"amount":0},{"first":917,"second":945,"amount":0},{"first":917,"second":963,"amount":0},{"first":917,"second":947,"amount":-1},{"first":917,"second":957,"amount":-1},{"first":929,"second":97,"amount":0},{"first":929,"second":101,"amount":0},{"first":929,"second":116,"amount":0},{"first":929,"second":121,"amount":0},{"first":929,"second":111,"amount":0},{"first":929,"second":113,"amount":0},{"first":929,"second":100,"amount":0},{"first":929,"second":103,"amount":0},{"first":929,"second":99,"amount":0},{"first":929,"second":118,"amount":0},{"first":929,"second":65,"amount":-3},{"first":929,"second":90,"amount":-1},{"first":929,"second":74,"amount":-4},{"first":929,"second":88,"amount":-1},{"first":929,"second":44,"amount":-7},{"first":929,"second":46,"amount":-7},{"first":929,"second":1040,"amount":-3},{"first":929,"second":1072,"amount":0},{"first":929,"second":1044,"amount":-2},{"first":929,"second":1076,"amount":-1},{"first":929,"second":1077,"amount":0},{"first":929,"second":1105,"amount":0},{"first":929,"second":1046,"amount":-1},{"first":929,"second":1051,"amount":-1},{"first":929,"second":1083,"amount":-1},{"first":929,"second":1086,"amount":0},{"first":929,"second":1089,"amount":0},{"first":929,"second":1091,"amount":0},{"first":929,"second":1092,"amount":0},{"first":929,"second":1061,"amount":-1},{"first":929,"second":246,"amount":0},{"first":929,"second":228,"amount":0},{"first":929,"second":196,"amount":-3},{"first":929,"second":962,"amount":0},{"first":929,"second":961,"amount":-1},{"first":929,"second":959,"amount":0},{"first":929,"second":945,"amount":0},{"first":929,"second":963,"amount":0},{"first":929,"second":948,"amount":0},{"first":929,"second":947,"amount":0},{"first":929,"second":955,"amount":-1},{"first":929,"second":957,"amount":0},{"first":929,"second":913,"amount":-3},{"first":929,"second":916,"amount":-3},{"first":929,"second":923,"amount":-3},{"first":929,"second":918,"amount":-1},{"first":929,"second":935,"amount":-1},{"first":929,"second":229,"amount":0},{"first":929,"second":197,"amount":-3},{"first":929,"second":198,"amount":-2},{"first":932,"second":97,"amount":-2},{"first":932,"second":122,"amount":-1},{"first":932,"second":101,"amount":-2},{"first":932,"second":114,"amount":-2},{"first":932,"second":121,"amount":-1},{"first":932,"second":117,"amount":-2},{"first":932,"second":111,"amount":-2},{"first":932,"second":112,"amount":-2},{"first":932,"second":113,"amount":-2},{"first":932,"second":115,"amount":-2},{"first":932,"second":100,"amount":-2},{"first":932,"second":103,"amount":-2},{"first":932,"second":109,"amount":-2},{"first":932,"second":119,"amount":-1},{"first":932,"second":120,"amount":-2},{"first":932,"second":99,"amount":-2},{"first":932,"second":118,"amount":-1},{"first":932,"second":110,"amount":-2},{"first":932,"second":65,"amount":-2},{"first":932,"second":84,"amount":0},{"first":932,"second":89,"amount":0},{"first":932,"second":79,"amount":-1},{"first":932,"second":81,"amount":-1},{"first":932,"second":83,"amount":0},{"first":932,"second":71,"amount":-1},{"first":932,"second":74,"amount":-5},{"first":932,"second":87,"amount":0},{"first":932,"second":67,"amount":-1},{"first":932,"second":86,"amount":0},{"first":932,"second":45,"amount":-5},{"first":932,"second":8211,"amount":-5},{"first":932,"second":44,"amount":-4},{"first":932,"second":46,"amount":-4},{"first":932,"second":1040,"amount":-2},{"first":932,"second":1072,"amount":-2},{"first":932,"second":1073,"amount":-1},{"first":932,"second":1074,"amount":-2},{"first":932,"second":1075,"amount":-2},{"first":932,"second":1044,"amount":-2},{"first":932,"second":1076,"amount":-3},{"first":932,"second":1077,"amount":-2},{"first":932,"second":1105,"amount":-2},{"first":932,"second":1078,"amount":-2},{"first":932,"second":1079,"amount":-3},{"first":932,"second":1080,"amount":-2},{"first":932,"second":1081,"amount":-2},{"first":932,"second":1082,"amount":-2},{"first":932,"second":1051,"amount":-1},{"first":932,"second":1083,"amount":-3},{"first":932,"second":1084,"amount":-2},{"first":932,"second":1085,"amount":-2},{"first":932,"second":1054,"amount":-1},{"first":932,"second":1086,"amount":-2},{"first":932,"second":1087,"amount":-2},{"first":932,"second":1088,"amount":-2},{"first":932,"second":1057,"amount":-1},{"first":932,"second":1089,"amount":-2},{"first":932,"second":1058,"amount":0},{"first":932,"second":1090,"amount":-2},{"first":932,"second":1091,"amount":-1},{"first":932,"second":1092,"amount":-2},{"first":932,"second":1093,"amount":-2},{"first":932,"second":1094,"amount":-2},{"first":932,"second":1095,"amount":-3},{"first":932,"second":1096,"amount":-2},{"first":932,"second":1097,"amount":-2},{"first":932,"second":1099,"amount":-3},{"first":932,"second":1068,"amount":0},{"first":932,"second":1100,"amount":-2},{"first":932,"second":1101,"amount":-3},{"first":932,"second":1102,"amount":-2},{"first":932,"second":1103,"amount":-3},{"first":932,"second":252,"amount":-2},{"first":932,"second":246,"amount":-2},{"first":932,"second":214,"amount":-1},{"first":932,"second":228,"amount":-2},{"first":932,"second":196,"amount":-2},{"first":932,"second":241,"amount":-2},{"first":932,"second":962,"amount":-2},{"first":932,"second":949,"amount":-3},{"first":932,"second":961,"amount":-3},{"first":932,"second":964,"amount":-2},{"first":932,"second":965,"amount":-2},{"first":932,"second":953,"amount":-3},{"first":932,"second":959,"amount":-2},{"first":932,"second":960,"amount":-2},{"first":932,"second":945,"amount":-2},{"first":932,"second":963,"amount":-2},{"first":932,"second":948,"amount":-1},{"first":932,"second":966,"amount":-3},{"first":932,"second":947,"amount":-1},{"first":932,"second":951,"amount":-2},{"first":932,"second":968,"amount":-3},{"first":932,"second":969,"amount":-3},{"first":932,"second":957,"amount":-1},{"first":932,"second":933,"amount":0},{"first":932,"second":920,"amount":-1},{"first":932,"second":927,"amount":-1},{"first":932,"second":913,"amount":-2},{"first":932,"second":916,"amount":-2},{"first":932,"second":934,"amount":-2},{"first":932,"second":923,"amount":-2},{"first":932,"second":229,"amount":-2},{"first":932,"second":197,"amount":-2},{"first":932,"second":230,"amount":-2},{"first":932,"second":198,"amount":-4},{"first":932,"second":248,"amount":-2},{"first":932,"second":216,"amount":-1},{"first":933,"second":97,"amount":-1},{"first":933,"second":122,"amount":-1},{"first":933,"second":101,"amount":-1},{"first":933,"second":114,"amount":-1},{"first":933,"second":116,"amount":0},{"first":933,"second":121,"amount":0},{"first":933,"second":117,"amount":-1},{"first":933,"second":111,"amount":-1},{"first":933,"second":112,"amount":-1},{"first":933,"second":113,"amount":-1},{"first":933,"second":115,"amount":-1},{"first":933,"second":100,"amount":-1},{"first":933,"second":102,"amount":0},{"first":933,"second":103,"amount":-1},{"first":933,"second":109,"amount":-1},{"first":933,"second":120,"amount":0},{"first":933,"second":99,"amount":-1},{"first":933,"second":118,"amount":0},{"first":933,"second":110,"amount":-1},{"first":933,"second":65,"amount":-2},{"first":933,"second":84,"amount":0},{"first":933,"second":89,"amount":0},{"first":933,"second":85,"amount":-2},{"first":933,"second":79,"amount":-1},{"first":933,"second":81,"amount":-1},{"first":933,"second":83,"amount":0},{"first":933,"second":71,"amount":-1},{"first":933,"second":74,"amount":-2},{"first":933,"second":87,"amount":0},{"first":933,"second":88,"amount":0},{"first":933,"second":67,"amount":-1},{"first":933,"second":86,"amount":0},{"first":933,"second":42,"amount":-1},{"first":933,"second":45,"amount":-1},{"first":933,"second":8211,"amount":-1},{"first":933,"second":44,"amount":-4},{"first":933,"second":46,"amount":-4},{"first":933,"second":125,"amount":0},{"first":933,"second":41,"amount":0},{"first":933,"second":93,"amount":0},{"first":933,"second":38,"amount":-1},{"first":933,"second":1040,"amount":-2},{"first":933,"second":1072,"amount":-1},{"first":933,"second":1075,"amount":-1},{"first":933,"second":1077,"amount":-1},{"first":933,"second":1105,"amount":-1},{"first":933,"second":1046,"amount":0},{"first":933,"second":1078,"amount":0},{"first":933,"second":1080,"amount":-1},{"first":933,"second":1081,"amount":-1},{"first":933,"second":1082,"amount":-1},{"first":933,"second":1084,"amount":-1},{"first":933,"second":1085,"amount":-1},{"first":933,"second":1054,"amount":-1},{"first":933,"second":1086,"amount":-1},{"first":933,"second":1087,"amount":-1},{"first":933,"second":1088,"amount":-1},{"first":933,"second":1057,"amount":-1},{"first":933,"second":1089,"amount":-1},{"first":933,"second":1058,"amount":0},{"first":933,"second":1091,"amount":0},{"first":933,"second":1092,"amount":-1},{"first":933,"second":1061,"amount":0},{"first":933,"second":1093,"amount":0},{"first":933,"second":1094,"amount":-1},{"first":933,"second":1096,"amount":-1},{"first":933,"second":1097,"amount":-1},{"first":933,"second":1100,"amount":-1},{"first":933,"second":1102,"amount":-1},{"first":933,"second":252,"amount":-1},{"first":933,"second":220,"amount":-2},{"first":933,"second":246,"amount":-1},{"first":933,"second":214,"amount":-1},{"first":933,"second":228,"amount":-1},{"first":933,"second":196,"amount":-2},{"first":933,"second":241,"amount":-1},{"first":933,"second":962,"amount":-1},{"first":933,"second":949,"amount":-1},{"first":933,"second":961,"amount":-1},{"first":933,"second":964,"amount":0},{"first":933,"second":965,"amount":-1},{"first":933,"second":952,"amount":0},{"first":933,"second":953,"amount":-1},{"first":933,"second":959,"amount":-1},{"first":933,"second":960,"amount":0},{"first":933,"second":945,"amount":-1},{"first":933,"second":963,"amount":-1},{"first":933,"second":948,"amount":0},{"first":933,"second":966,"amount":-1},{"first":933,"second":947,"amount":0},{"first":933,"second":951,"amount":-1},{"first":933,"second":950,"amount":0},{"first":933,"second":968,"amount":-1},{"first":933,"second":969,"amount":-1},{"first":933,"second":946,"amount":0},{"first":933,"second":957,"amount":0},{"first":933,"second":933,"amount":0},{"first":933,"second":920,"amount":-1},{"first":933,"second":927,"amount":-1},{"first":933,"second":913,"amount":-2},{"first":933,"second":916,"amount":-2},{"first":933,"second":934,"amount":-1},{"first":933,"second":923,"amount":-2},{"first":933,"second":935,"amount":0},{"first":933,"second":229,"amount":-1},{"first":933,"second":197,"amount":-2},{"first":933,"second":230,"amount":-1},{"first":933,"second":198,"amount":-2},{"first":933,"second":248,"amount":-1},{"first":933,"second":216,"amount":-1},{"first":920,"second":65,"amount":0},{"first":920,"second":90,"amount":0},{"first":920,"second":84,"amount":-1},{"first":920,"second":89,"amount":-1},{"first":920,"second":88,"amount":0},{"first":920,"second":86,"amount":0},{"first":920,"second":44,"amount":-2},{"first":920,"second":46,"amount":-2},{"first":920,"second":1040,"amount":0},{"first":920,"second":1044,"amount":-1},{"first":920,"second":1046,"amount":0},{"first":920,"second":1051,"amount":-1},{"first":920,"second":1058,"amount":-1},{"first":920,"second":1061,"amount":0},{"first":920,"second":1068,"amount":-1},{"first":920,"second":196,"amount":0},{"first":920,"second":955,"amount":0},{"first":920,"second":933,"amount":-1},{"first":920,"second":913,"amount":0},{"first":920,"second":931,"amount":0},{"first":920,"second":916,"amount":0},{"first":920,"second":926,"amount":0},{"first":920,"second":923,"amount":0},{"first":920,"second":918,"amount":0},{"first":920,"second":935,"amount":0},{"first":920,"second":197,"amount":0},{"first":920,"second":198,"amount":-1},{"first":921,"second":65,"amount":0},{"first":921,"second":84,"amount":-1},{"first":921,"second":89,"amount":-1},{"first":921,"second":88,"amount":0},{"first":921,"second":1040,"amount":0},{"first":921,"second":1044,"amount":0},{"first":921,"second":1076,"amount":0},{"first":921,"second":1046,"amount":0},{"first":921,"second":1051,"amount":0},{"first":921,"second":1083,"amount":0},{"first":921,"second":1058,"amount":-1},{"first":921,"second":1061,"amount":0},{"first":921,"second":1063,"amount":-1},{"first":921,"second":1095,"amount":-1},{"first":921,"second":196,"amount":0},{"first":921,"second":933,"amount":-1},{"first":921,"second":913,"amount":0},{"first":921,"second":916,"amount":0},{"first":921,"second":923,"amount":0},{"first":921,"second":935,"amount":0},{"first":921,"second":197,"amount":0},{"first":927,"second":65,"amount":0},{"first":927,"second":90,"amount":0},{"first":927,"second":84,"amount":-1},{"first":927,"second":89,"amount":-1},{"first":927,"second":88,"amount":0},{"first":927,"second":86,"amount":0},{"first":927,"second":44,"amount":-2},{"first":927,"second":46,"amount":-2},{"first":927,"second":1040,"amount":0},{"first":927,"second":1044,"amount":-1},{"first":927,"second":1046,"amount":0},{"first":927,"second":1051,"amount":-1},{"first":927,"second":1058,"amount":-1},{"first":927,"second":1061,"amount":0},{"first":927,"second":1068,"amount":-1},{"first":927,"second":196,"amount":0},{"first":927,"second":955,"amount":0},{"first":927,"second":933,"amount":-1},{"first":927,"second":913,"amount":0},{"first":927,"second":931,"amount":0},{"first":927,"second":916,"amount":0},{"first":927,"second":926,"amount":0},{"first":927,"second":923,"amount":0},{"first":927,"second":918,"amount":0},{"first":927,"second":935,"amount":0},{"first":927,"second":197,"amount":0},{"first":927,"second":198,"amount":-1},{"first":913,"second":122,"amount":0},{"first":913,"second":116,"amount":0},{"first":913,"second":121,"amount":-1},{"first":913,"second":117,"amount":0},{"first":913,"second":111,"amount":0},{"first":913,"second":119,"amount":-1},{"first":913,"second":118,"amount":-1},{"first":913,"second":84,"amount":-3},{"first":913,"second":89,"amount":-2},{"first":913,"second":85,"amount":0},{"first":913,"second":79,"amount":0},{"first":913,"second":81,"amount":0},{"first":913,"second":71,"amount":0},{"first":913,"second":87,"amount":-1},{"first":913,"second":67,"amount":0},{"first":913,"second":86,"amount":-2},{"first":913,"second":63,"amount":-1},{"first":913,"second":34,"amount":-2},{"first":913,"second":39,"amount":-2},{"first":913,"second":1044,"amount":0},{"first":913,"second":1051,"amount":0},{"first":913,"second":1083,"amount":0},{"first":913,"second":1054,"amount":0},{"first":913,"second":1086,"amount":0},{"first":913,"second":1057,"amount":0},{"first":913,"second":1058,"amount":-3},{"first":913,"second":1090,"amount":-1},{"first":913,"second":1091,"amount":-1},{"first":913,"second":1063,"amount":-1},{"first":913,"second":1095,"amount":-2},{"first":913,"second":1068,"amount":-1},{"first":913,"second":252,"amount":0},{"first":913,"second":220,"amount":0},{"first":913,"second":246,"amount":0},{"first":913,"second":214,"amount":0},{"first":913,"second":964,"amount":-1},{"first":913,"second":965,"amount":0},{"first":913,"second":959,"amount":0},{"first":913,"second":947,"amount":-1},{"first":913,"second":955,"amount":0},{"first":913,"second":957,"amount":-1},{"first":913,"second":933,"amount":-2},{"first":913,"second":920,"amount":0},{"first":913,"second":927,"amount":0},{"first":913,"second":934,"amount":-1},{"first":913,"second":936,"amount":-1},{"first":913,"second":216,"amount":0},{"first":931,"second":79,"amount":-1},{"first":931,"second":81,"amount":-1},{"first":931,"second":71,"amount":-1},{"first":931,"second":67,"amount":-1},{"first":931,"second":1054,"amount":-1},{"first":931,"second":1057,"amount":-1},{"first":931,"second":214,"amount":-1},{"first":931,"second":955,"amount":0},{"first":931,"second":920,"amount":-1},{"first":931,"second":927,"amount":-1},{"first":931,"second":934,"amount":-1},{"first":931,"second":216,"amount":-1},{"first":916,"second":122,"amount":0},{"first":916,"second":116,"amount":0},{"first":916,"second":121,"amount":-1},{"first":916,"second":117,"amount":0},{"first":916,"second":111,"amount":0},{"first":916,"second":119,"amount":-1},{"first":916,"second":118,"amount":-1},{"first":916,"second":84,"amount":-3},{"first":916,"second":89,"amount":-2},{"first":916,"second":85,"amount":0},{"first":916,"second":79,"amount":0},{"first":916,"second":81,"amount":0},{"first":916,"second":71,"amount":0},{"first":916,"second":87,"amount":-1},{"first":916,"second":67,"amount":0},{"first":916,"second":86,"amount":-2},{"first":916,"second":63,"amount":-1},{"first":916,"second":34,"amount":-2},{"first":916,"second":39,"amount":-2},{"first":916,"second":1044,"amount":0},{"first":916,"second":1051,"amount":0},{"first":916,"second":1083,"amount":0},{"first":916,"second":1054,"amount":0},{"first":916,"second":1086,"amount":0},{"first":916,"second":1057,"amount":0},{"first":916,"second":1058,"amount":-3},{"first":916,"second":1090,"amount":-1},{"first":916,"second":1091,"amount":-1},{"first":916,"second":1063,"amount":-1},{"first":916,"second":1095,"amount":-2},{"first":916,"second":1068,"amount":-1},{"first":916,"second":252,"amount":0},{"first":916,"second":220,"amount":0},{"first":916,"second":246,"amount":0},{"first":916,"second":214,"amount":0},{"first":916,"second":964,"amount":-1},{"first":916,"second":965,"amount":0},{"first":916,"second":959,"amount":0},{"first":916,"second":947,"amount":-1},{"first":916,"second":955,"amount":0},{"first":916,"second":957,"amount":-1},{"first":916,"second":933,"amount":-2},{"first":916,"second":920,"amount":0},{"first":916,"second":927,"amount":0},{"first":916,"second":934,"amount":-1},{"first":916,"second":936,"amount":-1},{"first":916,"second":216,"amount":0},{"first":934,"second":65,"amount":-1},{"first":934,"second":89,"amount":-1},{"first":934,"second":88,"amount":-1},{"first":934,"second":1040,"amount":-1},{"first":934,"second":1046,"amount":-1},{"first":934,"second":1061,"amount":-1},{"first":934,"second":196,"amount":-1},{"first":934,"second":955,"amount":-1},{"first":934,"second":933,"amount":-1},{"first":934,"second":913,"amount":-1},{"first":934,"second":916,"amount":-1},{"first":934,"second":923,"amount":-1},{"first":934,"second":935,"amount":-1},{"first":934,"second":197,"amount":-1},{"first":915,"second":97,"amount":-4},{"first":915,"second":122,"amount":-3},{"first":915,"second":101,"amount":-4},{"first":915,"second":114,"amount":-3},{"first":915,"second":121,"amount":-3},{"first":915,"second":117,"amount":-4},{"first":915,"second":111,"amount":-4},{"first":915,"second":112,"amount":-4},{"first":915,"second":113,"amount":-4},{"first":915,"second":115,"amount":-4},{"first":915,"second":100,"amount":-4},{"first":915,"second":103,"amount":-4},{"first":915,"second":109,"amount":-4},{"first":915,"second":119,"amount":-2},{"first":915,"second":120,"amount":-3},{"first":915,"second":99,"amount":-4},{"first":915,"second":118,"amount":-3},{"first":915,"second":110,"amount":-4},{"first":915,"second":65,"amount":-4},{"first":915,"second":84,"amount":0},{"first":915,"second":89,"amount":0},{"first":915,"second":79,"amount":-1},{"first":915,"second":81,"amount":-1},{"first":915,"second":83,"amount":-1},{"first":915,"second":71,"amount":-1},{"first":915,"second":87,"amount":0},{"first":915,"second":67,"amount":-1},{"first":915,"second":86,"amount":0},{"first":915,"second":45,"amount":-8},{"first":915,"second":8211,"amount":-8},{"first":915,"second":44,"amount":-8},{"first":915,"second":46,"amount":-8},{"first":915,"second":1040,"amount":-4},{"first":915,"second":1072,"amount":-4},{"first":915,"second":1073,"amount":-1},{"first":915,"second":1074,"amount":-4},{"first":915,"second":1075,"amount":-4},{"first":915,"second":1044,"amount":-4},{"first":915,"second":1076,"amount":-5},{"first":915,"second":1077,"amount":-4},{"first":915,"second":1105,"amount":-4},{"first":915,"second":1078,"amount":-3},{"first":915,"second":1079,"amount":-5},{"first":915,"second":1080,"amount":-4},{"first":915,"second":1081,"amount":-4},{"first":915,"second":1082,"amount":-4},{"first":915,"second":1051,"amount":-2},{"first":915,"second":1083,"amount":-5},{"first":915,"second":1084,"amount":-4},{"first":915,"second":1085,"amount":-4},{"first":915,"second":1054,"amount":-1},{"first":915,"second":1086,"amount":-4},{"first":915,"second":1087,"amount":-4},{"first":915,"second":1088,"amount":-4},{"first":915,"second":1057,"amount":-1},{"first":915,"second":1089,"amount":-4},{"first":915,"second":1058,"amount":0},{"first":915,"second":1090,"amount":-3},{"first":915,"second":1091,"amount":-3},{"first":915,"second":1092,"amount":-4},{"first":915,"second":1093,"amount":-3},{"first":915,"second":1094,"amount":-4},{"first":915,"second":1095,"amount":-5},{"first":915,"second":1096,"amount":-4},{"first":915,"second":1097,"amount":-4},{"first":915,"second":1099,"amount":-5},{"first":915,"second":1068,"amount":0},{"first":915,"second":1100,"amount":-4},{"first":915,"second":1101,"amount":-5},{"first":915,"second":1102,"amount":-4},{"first":915,"second":1103,"amount":-5},{"first":915,"second":252,"amount":-4},{"first":915,"second":246,"amount":-4},{"first":915,"second":214,"amount":-1},{"first":915,"second":228,"amount":-4},{"first":915,"second":196,"amount":-4},{"first":915,"second":241,"amount":-4},{"first":915,"second":962,"amount":-4},{"first":915,"second":949,"amount":-5},{"first":915,"second":961,"amount":-6},{"first":915,"second":964,"amount":-4},{"first":915,"second":965,"amount":-4},{"first":915,"second":953,"amount":-6},{"first":915,"second":959,"amount":-4},{"first":915,"second":960,"amount":-5},{"first":915,"second":945,"amount":-4},{"first":915,"second":963,"amount":-4},{"first":915,"second":948,"amount":-2},{"first":915,"second":966,"amount":-6},{"first":915,"second":947,"amount":-3},{"first":915,"second":951,"amount":-4},{"first":915,"second":968,"amount":-5},{"first":915,"second":969,"amount":-6},{"first":915,"second":957,"amount":-3},{"first":915,"second":933,"amount":0},{"first":915,"second":920,"amount":-1},{"first":915,"second":927,"amount":-1},{"first":915,"second":913,"amount":-4},{"first":915,"second":916,"amount":-4},{"first":915,"second":934,"amount":-3},{"first":915,"second":923,"amount":-4},{"first":915,"second":229,"amount":-4},{"first":915,"second":197,"amount":-4},{"first":915,"second":230,"amount":-4},{"first":915,"second":198,"amount":-7},{"first":915,"second":248,"amount":-4},{"first":915,"second":216,"amount":-1},{"first":919,"second":65,"amount":0},{"first":919,"second":84,"amount":-1},{"first":919,"second":89,"amount":-1},{"first":919,"second":88,"amount":0},{"first":919,"second":1040,"amount":0},{"first":919,"second":1044,"amount":0},{"first":919,"second":1076,"amount":0},{"first":919,"second":1046,"amount":0},{"first":919,"second":1051,"amount":0},{"first":919,"second":1083,"amount":0},{"first":919,"second":1058,"amount":-1},{"first":919,"second":1061,"amount":0},{"first":919,"second":1063,"amount":-1},{"first":919,"second":1095,"amount":-1},{"first":919,"second":196,"amount":0},{"first":919,"second":933,"amount":-1},{"first":919,"second":913,"amount":0},{"first":919,"second":916,"amount":0},{"first":919,"second":923,"amount":0},{"first":919,"second":935,"amount":0},{"first":919,"second":197,"amount":0},{"first":926,"second":79,"amount":0},{"first":926,"second":81,"amount":0},{"first":926,"second":71,"amount":0},{"first":926,"second":67,"amount":0},{"first":926,"second":1054,"amount":0},{"first":926,"second":1057,"amount":0},{"first":926,"second":214,"amount":0},{"first":926,"second":955,"amount":0},{"first":926,"second":920,"amount":0},{"first":926,"second":927,"amount":0},{"first":926,"second":216,"amount":0},{"first":922,"second":101,"amount":-1},{"first":922,"second":121,"amount":-1},{"first":922,"second":117,"amount":0},{"first":922,"second":111,"amount":-1},{"first":922,"second":112,"amount":0},{"first":922,"second":113,"amount":-1},{"first":922,"second":100,"amount":-1},{"first":922,"second":103,"amount":-1},{"first":922,"second":109,"amount":0},{"first":922,"second":119,"amount":-1},{"first":922,"second":99,"amount":-1},{"first":922,"second":118,"amount":-1},{"first":922,"second":110,"amount":0},{"first":922,"second":79,"amount":-1},{"first":922,"second":81,"amount":-1},{"first":922,"second":71,"amount":-1},{"first":922,"second":67,"amount":-1},{"first":922,"second":45,"amount":-1},{"first":922,"second":8211,"amount":-1},{"first":922,"second":1073,"amount":-1},{"first":922,"second":1075,"amount":0},{"first":922,"second":1077,"amount":-1},{"first":922,"second":1105,"amount":-1},{"first":922,"second":1080,"amount":0},{"first":922,"second":1081,"amount":0},{"first":922,"second":1082,"amount":0},{"first":922,"second":1084,"amount":0},{"first":922,"second":1085,"amount":0},{"first":922,"second":1054,"amount":-1},{"first":922,"second":1086,"amount":-1},{"first":922,"second":1087,"amount":0},{"first":922,"second":1088,"amount":0},{"first":922,"second":1057,"amount":-1},{"first":922,"second":1089,"amount":-1},{"first":922,"second":1090,"amount":-1},{"first":922,"second":1091,"amount":-1},{"first":922,"second":1092,"amount":-1},{"first":922,"second":1094,"amount":0},{"first":922,"second":1095,"amount":-2},{"first":922,"second":1096,"amount":0},{"first":922,"second":1097,"amount":0},{"first":922,"second":1100,"amount":0},{"first":922,"second":1102,"amount":0},{"first":922,"second":252,"amount":0},{"first":922,"second":246,"amount":-1},{"first":922,"second":214,"amount":-1},{"first":922,"second":241,"amount":0},{"first":922,"second":962,"amount":-1},{"first":922,"second":964,"amount":-2},{"first":922,"second":965,"amount":0},{"first":922,"second":959,"amount":-1},{"first":922,"second":945,"amount":-1},{"first":922,"second":963,"amount":-1},{"first":922,"second":947,"amount":-1},{"first":922,"second":951,"amount":0},{"first":922,"second":957,"amount":-1},{"first":922,"second":920,"amount":-1},{"first":922,"second":927,"amount":-1},{"first":922,"second":934,"amount":-1},{"first":922,"second":216,"amount":-1},{"first":923,"second":122,"amount":0},{"first":923,"second":116,"amount":0},{"first":923,"second":121,"amount":-1},{"first":923,"second":117,"amount":0},{"first":923,"second":111,"amount":0},{"first":923,"second":119,"amount":-1},{"first":923,"second":118,"amount":-1},{"first":923,"second":84,"amount":-3},{"first":923,"second":89,"amount":-2},{"first":923,"second":85,"amount":0},{"first":923,"second":79,"amount":0},{"first":923,"second":81,"amount":0},{"first":923,"second":71,"amount":0},{"first":923,"second":87,"amount":-1},{"first":923,"second":67,"amount":0},{"first":923,"second":86,"amount":-2},{"first":923,"second":63,"amount":-1},{"first":923,"second":34,"amount":-2},{"first":923,"second":39,"amount":-2},{"first":923,"second":1044,"amount":0},{"first":923,"second":1051,"amount":0},{"first":923,"second":1083,"amount":0},{"first":923,"second":1054,"amount":0},{"first":923,"second":1086,"amount":0},{"first":923,"second":1057,"amount":0},{"first":923,"second":1058,"amount":-3},{"first":923,"second":1090,"amount":-1},{"first":923,"second":1091,"amount":-1},{"first":923,"second":1063,"amount":-1},{"first":923,"second":1095,"amount":-2},{"first":923,"second":1068,"amount":-1},{"first":923,"second":252,"amount":0},{"first":923,"second":220,"amount":0},{"first":923,"second":246,"amount":0},{"first":923,"second":214,"amount":0},{"first":923,"second":964,"amount":-1},{"first":923,"second":965,"amount":0},{"first":923,"second":959,"amount":0},{"first":923,"second":947,"amount":-1},{"first":923,"second":955,"amount":0},{"first":923,"second":957,"amount":-1},{"first":923,"second":933,"amount":-2},{"first":923,"second":920,"amount":0},{"first":923,"second":927,"amount":0},{"first":923,"second":934,"amount":-1},{"first":923,"second":936,"amount":-1},{"first":923,"second":216,"amount":0},{"first":918,"second":101,"amount":0},{"first":918,"second":121,"amount":-1},{"first":918,"second":117,"amount":0},{"first":918,"second":111,"amount":0},{"first":918,"second":113,"amount":0},{"first":918,"second":100,"amount":0},{"first":918,"second":103,"amount":0},{"first":918,"second":119,"amount":-1},{"first":918,"second":99,"amount":0},{"first":918,"second":118,"amount":-1},{"first":918,"second":65,"amount":0},{"first":918,"second":79,"amount":-1},{"first":918,"second":81,"amount":-1},{"first":918,"second":71,"amount":-1},{"first":918,"second":67,"amount":-1},{"first":918,"second":1040,"amount":0},{"first":918,"second":1077,"amount":0},{"first":918,"second":1105,"amount":0},{"first":918,"second":1054,"amount":-1},{"first":918,"second":1086,"amount":0},{"first":918,"second":1057,"amount":-1},{"first":918,"second":1089,"amount":0},{"first":918,"second":1091,"amount":-1},{"first":918,"second":1092,"amount":0},{"first":918,"second":252,"amount":0},{"first":918,"second":246,"amount":0},{"first":918,"second":214,"amount":-1},{"first":918,"second":196,"amount":0},{"first":918,"second":962,"amount":0},{"first":918,"second":965,"amount":0},{"first":918,"second":959,"amount":0},{"first":918,"second":945,"amount":0},{"first":918,"second":963,"amount":0},{"first":918,"second":947,"amount":-1},{"first":918,"second":968,"amount":-1},{"first":918,"second":957,"amount":-1},{"first":918,"second":920,"amount":-1},{"first":918,"second":927,"amount":-1},{"first":918,"second":913,"amount":0},{"first":918,"second":916,"amount":0},{"first":918,"second":934,"amount":-1},{"first":918,"second":923,"amount":0},{"first":918,"second":197,"amount":0},{"first":918,"second":216,"amount":-1},{"first":935,"second":101,"amount":-1},{"first":935,"second":121,"amount":-1},{"first":935,"second":117,"amount":0},{"first":935,"second":111,"amount":0},{"first":935,"second":113,"amount":-1},{"first":935,"second":100,"amount":-1},{"first":935,"second":103,"amount":-1},{"first":935,"second":99,"amount":-1},{"first":935,"second":118,"amount":-1},{"first":935,"second":79,"amount":-1},{"first":935,"second":81,"amount":-1},{"first":935,"second":71,"amount":-1},{"first":935,"second":67,"amount":-1},{"first":935,"second":86,"amount":0},{"first":935,"second":45,"amount":-1},{"first":935,"second":8211,"amount":-1},{"first":935,"second":1073,"amount":0},{"first":935,"second":1044,"amount":0},{"first":935,"second":1077,"amount":-1},{"first":935,"second":1105,"amount":-1},{"first":935,"second":1051,"amount":0},{"first":935,"second":1083,"amount":0},{"first":935,"second":1054,"amount":-1},{"first":935,"second":1086,"amount":0},{"first":935,"second":1057,"amount":-1},{"first":935,"second":1089,"amount":-1},{"first":935,"second":1090,"amount":-1},{"first":935,"second":1091,"amount":-1},{"first":935,"second":1092,"amount":-1},{"first":935,"second":1095,"amount":-1},{"first":935,"second":252,"amount":0},{"first":935,"second":246,"amount":0},{"first":935,"second":214,"amount":-1},{"first":935,"second":962,"amount":-1},{"first":935,"second":964,"amount":-1},{"first":935,"second":965,"amount":0},{"first":935,"second":952,"amount":0},{"first":935,"second":959,"amount":0},{"first":935,"second":945,"amount":-1},{"first":935,"second":963,"amount":-1},{"first":935,"second":948,"amount":0},{"first":935,"second":966,"amount":-1},{"first":935,"second":947,"amount":-1},{"first":935,"second":955,"amount":0},{"first":935,"second":968,"amount":-1},{"first":935,"second":969,"amount":0},{"first":935,"second":957,"amount":-1},{"first":935,"second":920,"amount":-1},{"first":935,"second":927,"amount":-1},{"first":935,"second":934,"amount":-1},{"first":935,"second":216,"amount":-1},{"first":936,"second":65,"amount":-1},{"first":936,"second":44,"amount":-5},{"first":936,"second":46,"amount":-5},{"first":936,"second":1040,"amount":-1},{"first":936,"second":196,"amount":-1},{"first":936,"second":961,"amount":0},{"first":936,"second":913,"amount":-1},{"first":936,"second":916,"amount":-1},{"first":936,"second":923,"amount":-1},{"first":936,"second":197,"amount":-1},{"first":914,"second":84,"amount":-1},{"first":914,"second":89,"amount":-1},{"first":914,"second":86,"amount":0},{"first":914,"second":1058,"amount":-1},{"first":914,"second":1059,"amount":0},{"first":914,"second":933,"amount":-1},{"first":925,"second":65,"amount":0},{"first":925,"second":84,"amount":-1},{"first":925,"second":89,"amount":-1},{"first":925,"second":88,"amount":0},{"first":925,"second":1040,"amount":0},{"first":925,"second":1044,"amount":0},{"first":925,"second":1076,"amount":0},{"first":925,"second":1046,"amount":0},{"first":925,"second":1051,"amount":0},{"first":925,"second":1083,"amount":0},{"first":925,"second":1058,"amount":-1},{"first":925,"second":1061,"amount":0},{"first":925,"second":1063,"amount":-1},{"first":925,"second":1095,"amount":-1},{"first":925,"second":196,"amount":0},{"first":925,"second":933,"amount":-1},{"first":925,"second":913,"amount":0},{"first":925,"second":916,"amount":0},{"first":925,"second":923,"amount":0},{"first":925,"second":935,"amount":0},{"first":925,"second":197,"amount":0},{"first":924,"second":65,"amount":0},{"first":924,"second":84,"amount":-1},{"first":924,"second":89,"amount":-1},{"first":924,"second":88,"amount":0},{"first":924,"second":1040,"amount":0},{"first":924,"second":1044,"amount":0},{"first":924,"second":1076,"amount":0},{"first":924,"second":1046,"amount":0},{"first":924,"second":1051,"amount":0},{"first":924,"second":1083,"amount":0},{"first":924,"second":1058,"amount":-1},{"first":924,"second":1061,"amount":0},{"first":924,"second":1063,"amount":-1},{"first":924,"second":1095,"amount":-1},{"first":924,"second":196,"amount":0},{"first":924,"second":933,"amount":-1},{"first":924,"second":913,"amount":0},{"first":924,"second":916,"amount":0},{"first":924,"second":923,"amount":0},{"first":924,"second":935,"amount":0},{"first":924,"second":197,"amount":0},{"first":229,"second":121,"amount":0},{"first":229,"second":118,"amount":0},{"first":229,"second":34,"amount":-1},{"first":229,"second":39,"amount":-1},{"first":229,"second":1090,"amount":0},{"first":229,"second":1091,"amount":0},{"first":229,"second":947,"amount":0},{"first":229,"second":957,"amount":0},{"first":197,"second":122,"amount":0},{"first":197,"second":116,"amount":0},{"first":197,"second":121,"amount":-1},{"first":197,"second":117,"amount":0},{"first":197,"second":111,"amount":0},{"first":197,"second":119,"amount":-1},{"first":197,"second":118,"amount":-1},{"first":197,"second":84,"amount":-3},{"first":197,"second":89,"amount":-2},{"first":197,"second":85,"amount":0},{"first":197,"second":79,"amount":0},{"first":197,"second":81,"amount":0},{"first":197,"second":71,"amount":0},{"first":197,"second":87,"amount":-1},{"first":197,"second":67,"amount":0},{"first":197,"second":86,"amount":-2},{"first":197,"second":63,"amount":-1},{"first":197,"second":34,"amount":-2},{"first":197,"second":39,"amount":-2},{"first":197,"second":1044,"amount":0},{"first":197,"second":1051,"amount":0},{"first":197,"second":1083,"amount":0},{"first":197,"second":1054,"amount":0},{"first":197,"second":1086,"amount":0},{"first":197,"second":1057,"amount":0},{"first":197,"second":1058,"amount":-3},{"first":197,"second":1090,"amount":-1},{"first":197,"second":1091,"amount":-1},{"first":197,"second":1063,"amount":-1},{"first":197,"second":1095,"amount":-2},{"first":197,"second":1068,"amount":-1},{"first":197,"second":252,"amount":0},{"first":197,"second":220,"amount":0},{"first":197,"second":246,"amount":0},{"first":197,"second":214,"amount":0},{"first":197,"second":964,"amount":-1},{"first":197,"second":965,"amount":0},{"first":197,"second":959,"amount":0},{"first":197,"second":947,"amount":-1},{"first":197,"second":955,"amount":0},{"first":197,"second":957,"amount":-1},{"first":197,"second":933,"amount":-2},{"first":197,"second":920,"amount":0},{"first":197,"second":927,"amount":0},{"first":197,"second":934,"amount":-1},{"first":197,"second":936,"amount":-1},{"first":197,"second":216,"amount":0}]}'
        );
        var sl = n(96);
        class il {
          constructor() {
            (this.experience = new th()),
              (this.scene = this.experience.scene),
              (this.resources = this.experience.resources),
              (this.time = this.experience.time),
              (this.debug = this.experience.debug),
              (this.position = new ft(0, 0, 5)),
              this.makeTextPanel();
          }
          makeTextPanel() {
            (this.container = new Qd({
              width: 4,
              height: 2,
              padding: 0.05,
              justifyContent: "center",
              textAlign: "center",
              fontFamily: nl,
              fontTexture: sl,
            })),
              this.container.position.copy(this.position),
              (this.container.rotation.y = Math.PI),
              this.scene.add(this.container),
              this.container.add(new tl({ content: "HAL", fontSize: 1 }));
          }
          update() {
            this.experience.world.player &&
              this.container.position.copy(
                this.experience.world.player.position
              ),
              (this.container.position.y = 6),
              this.container.set({
                borderWidth: 0.05 - 0.06 * Math.sin(Date.now() / 500),
                borderColor: new Oe(
                  0.5 + 0.5 * Math.sin(Date.now() / 500),
                  0.5,
                  1
                ),
                borderOpacity: 1,
              }),
              el();
          }
        }
        class rl {
          constructor() {
            (this.experience = new th()),
              (this.scene = this.experience.scene),
              (this.resources = this.experience.resources),
              (this.time = this.experience.time),
              (this.debug = this.experience.debug),
              (this.position = new ft(110, 0, 140)),
              (this.resource = this.resources.items.halModel),
              this.debug.active &&
                ((this.statesFolder = this.debug.ui.addFolder("states")),
                (this.emotesFolder = this.debug.ui.addFolder("emotes"))),
              this.setModel(),
              this.setAnimation();
          }
          setModel() {
            (this.model = this.resource.scene),
              this.scene.add(this.model),
              (this.namePanel = new il()),
              this.model.traverse((t) => {
                t instanceof pn && (t.castShadow = !0);
              });
          }
          setAnimation() {
            const t = [
                "Idle",
                "Walking",
                "Running",
                "Dance",
                "Death",
                "Sitting",
                "Standing",
              ],
              e = ["Jump", "Yes", "No", "Wave", "Punch", "ThumbsUp"];
            (this.animation = {}),
              (this.animation.mixer = new Sc(this.model)),
              (this.animation.actions = {});
            for (let n = 0; n < this.resource.animations.length; n++) {
              const s = this.resource.animations[n],
                i = this.animation.mixer.clipAction(s);
              (this.animation.actions[s.name] = i),
                (e.indexOf(s.name) >= 0 || t.indexOf(s.name) >= 4) &&
                  ((i.clampWhenFinished = !0), (i.loop = 2200));
            }
            if (
              (console.log(this.animation.actions),
              (this.characterControls = new uu(this, this.animation, "Idle")),
              this.debug.active)
            ) {
              const t = {
                playIdle: () => {
                  this.animation.play("Idle");
                },
                playWalking: () => {
                  this.animation.play("Walking");
                },
                playThumbsUp: () => {
                  this.animation.play("thumbsup");
                },
                playSitting: () => {
                  this.animation.play("sitting");
                },
                playPunching: () => {
                  this.animation.play("punching");
                },
                playRunning: () => {
                  this.animation.play("running");
                },
                playDead: () => {
                  this.animation.play("dead");
                },
                playDancing: () => {
                  this.animation.play("dancing");
                },
                playJumping: () => {
                  this.animation.play("jumping");
                },
                playNo: () => {
                  this.animation.play("no");
                },
              };
              this.statesFolder.add(t, "playIdle"),
                this.statesFolder.add(t, "playWalking"),
                this.statesFolder.add(t, "playSitting"),
                this.statesFolder.add(t, "playPunching"),
                this.statesFolder.add(t, "playRunning"),
                this.statesFolder.add(t, "playDead"),
                this.statesFolder.add(t, "playDancing"),
                this.statesFolder.add(t, "playJumping"),
                this.statesFolder.add(t, "playNo"),
                this.statesFolder.add(t, "playThumbsUp");
            }
          }
          update() {
            this.animation.mixer.update(0.001 * this.time.delta),
              this.model.position.copy(this.position),
              this.characterControls && this.characterControls.update(),
              this.namePanel && this.namePanel.update();
          }
        }
        class ol {
          constructor(t, e, n) {
            (this.cast = n),
              (this.experience = new th()),
              (this.scene = this.experience.scene),
              (this.resources = this.experience.resources),
              (this.time = this.experience.time),
              (this.debug = this.experience.debug),
              (this.position = new ft(0, 0, e)),
              (this.resource = this.resources.items[t]),
              this.setModel(),
              this.update();
          }
          setModel() {
            (this.model = this.resource.scene),
              this.model.scale.set(5, 5, 5),
              this.model.position.copy(this.position),
              this.scene.add(this.model),
              this.model.traverse((t) => {
                t instanceof pn && (t.castShadow = this.cast);
              });
          }
          update() {}
        }
        class al {
          constructor() {
            (this.experience = new th()),
              (this.resources = this.experience.resources),
              (this.position = new ft(144, 22, 150));
          }
          create(t) {
            let e = new Oe(268435455),
              n = new ThreeMeshUI.Block({
                width: 50,
                height: 30,
                padding: 0.05,
                fontColor: new Oe(2236962),
                backgroundColor: e,
                justifyContent: "center",
                textAlign: "center",
                fontFamily: nl,
                fontTexture: sl,
                backgroundOpacity: 1,
              });
            const s = new ThreeMeshUI.Block({
              height: 4.2,
              width: 31.5,
              margin: 0.525,
              justifyContent: "center",
              fontSize: 1.89,
              fontColor: e,
            });
            s.add(new ThreeMeshUI.Text({ content: t.toUpperCase() })),
              n.add(s),
              n.position.copy(this.position),
              (n.rotation.y = -Math.PI / 2);
            const i = new ThreeMeshUI.Block({
                height: 19.95,
                width: 21,
                backgroundColor: e,
                margin: 0.525,
                padding: 0.525,
                textAlign: "left",
                justifyContent: "end",
              }),
              r = new ThreeMeshUI.Block({ margin: 0.525, backgroundColor: e }),
              o = new ThreeMeshUI.Block({
                height: 0.28 * 21,
                width: 10.5,
                margin: 0.525,
                padding: 0.42,
                fontSize: 0.84,
                justifyContent: "start",
                backgroundOpacity: 0,
                textAlign: "left",
              }).add(
                new ThreeMeshUI.Text({
                  content: "Skills:",
                  fontColor: new Oe(9627244),
                  fontSize: 1.68,
                  backgroundColor: new Oe(9627244),
                }),
                new ThreeMeshUI.Text({
                  content:
                    "spova" === t
                      ? "\nFigma, Wordpress, Threejs"
                      : "\nFigma, React Native, React, Firebase",
                })
              ),
              a = new ThreeMeshUI.Block({
                height: 11.13,
                width: 10.5,
                margin: 0.21,
                padding: 0.42,
                fontSize: 0.034 * 21,
                alignItems: "start",
                textAlign: "left",
                backgroundOpacity: 0,
              }).add(
                new ThreeMeshUI.Text({
                  content: {
                    malume:
                      "A cross platform react native liftclub app built in react native. This is a ride sharing app built with the South African minibus taxi industry in mind. React was used for the web landing page and admin dashboard and firebase was used for the backend. This was done in collaboration with Franck Tamla whom I met during our MTN App of the year entry and win.",
                    keen: "A cross platform react native liftclub app built in react native. This is a travel app built to service tourism providers. Built in partnership with CURIOCITY a South African hotel and travel company. I did the wireframe and interactive prototype in figma, and built the Android and iOS app using react native, with firebase as a backend.",
                    spova:
                      "An online fashion e-commerce solution built in partnership with South African music artist OKMALUMKOOLKAT. This platform was built using wordpress as a cms with graphics delivered using Three js.",
                  }[t],
                })
              );
            r.add(a, o);
            const c = new ThreeMeshUI.Block({
              contentDirection: "row",
              padding: 0.42,
              margin: 0.525,
              backgroundOpacity: 0,
            });
            c.add(i, r), n.add(c);
            const u = new ThreeMeshUI.Block({
              height: 0.07 * 21,
              width: 7.77,
              textAlign: "center",
              justifyContent: "center",
            });
            return (
              u.add(
                new ThreeMeshUI.Text({
                  content: "Click to open",
                  fontColor: e,
                  fontSize: 0.84,
                })
              ),
              (this.selectedAttributes = {
                offset: 0.02,
                backgroundColor: new Oe(7829367),
                fontColor: new Oe(2236962),
              }),
              (this.hoveredStateAttributes = {
                state: "hovered",
                attributes: {
                  offset: 0.035,
                  backgroundColor: new Oe(10066329),
                  backgroundOpacity: 0.4,
                  fontColor: new Oe(16777215),
                },
              }),
              (this.idleStateAttributes = {
                state: "idle",
                attributes: {
                  offset: 0.035,
                  backgroundColor: new Oe(0),
                  backgroundOpacity: 1,
                  fontColor: new Oe(16777215),
                },
              }),
              u.setupState({
                state: "selected",
                attributes: this.experience.world.cinema.selectedAttributes,
                onSet: () => {
                  window.open(
                    "https://play.google.com/store/apps/details?id=com.dothething.malumeapp&gl=NO"
                  );
                },
              }),
              u.setupState(this.idleStateAttributes),
              u.setupState(this.hoveredStateAttributes),
              this.experience.objsToTest.push(u),
              r.add(u),
              i.set({ backgroundTexture: this.resources.items[t] }),
              n
            );
          }
        }
        class cl {
          constructor() {
            (this.experience = new th()),
              (this.scene = this.experience.scene),
              (this.resources = this.experience.resources),
              (this.time = this.experience.time),
              (this.debug = this.experience.debug),
              (this.meshes = []),
              (this.currentMesh = 0),
              this.makeCinemaScreen("malume"),
              this.makeCinemaScreen("spova"),
              this.makeCinemaScreen("keen"),
              this.makeButtons(),
              this.showMesh(0),
              console.log(this.meshes);
          }
          makeCinemaScreen(t) {
            let e = new al().create(t);
            this.meshes.push(e), this.scene.add(e);
          }
          showMesh(t) {
            this.meshes.forEach((e, n) => {
              e.visible = n === t;
            });
          }
          makeButtons() {
            (this.panel = new Qd({
              justifyContent: "center",
              contentDirection: "row-reverse",
              fontFamily: nl,
              fontTexture: sl,
              fontSize: 0.07 * 20,
              padding: 0.4,
              borderRadius: 2.2,
            })),
              this.panel.position.set(125, 2, 150),
              (this.panel.rotation.y = -Math.PI / 2),
              this.scene.add(this.panel);
            const t = {
              width: 8,
              height: 3,
              justifyContent: "center",
              offset: 1,
              margin: 0.4,
              borderRadius: 1.5,
            };
            (this.hoveredStateAttributes = {
              state: "hovered",
              attributes: {
                offset: 0.035,
                backgroundColor: new Oe(10066329),
                backgroundOpacity: 1,
                fontColor: new Oe(16777215),
              },
            }),
              (this.idleStateAttributes = {
                state: "idle",
                attributes: {
                  offset: 0.035,
                  backgroundColor: new Oe(6710886),
                  backgroundOpacity: 0.3,
                  fontColor: new Oe(16777215),
                },
              });
            const e = new Qd(t),
              n = new Qd(t);
            e.add(new tl({ content: "next" })),
              n.add(new tl({ content: "previous" })),
              (this.selectedAttributes = {
                offset: 0.02,
                backgroundColor: new Oe(7829367),
                fontColor: new Oe(2236962),
              }),
              e.setupState({
                state: "selected",
                attributes: this.selectedAttributes,
                onSet: () => {
                  (this.currentMesh = (this.currentMesh + 1) % 3),
                    this.showMesh(this.currentMesh);
                },
              }),
              e.setupState(this.hoveredStateAttributes),
              e.setupState(this.idleStateAttributes),
              n.setupState({
                state: "selected",
                attributes: this.selectedAttributes,
                onSet: () => {
                  (this.currentMesh -= 1),
                    this.currentMesh < 0 && (this.currentMesh = 2),
                    this.showMesh(this.currentMesh);
                },
              }),
              n.setupState(this.hoveredStateAttributes),
              n.setupState(this.idleStateAttributes),
              this.panel.add(e, n),
              this.experience.objsToTest.push(e, n);
          }
          updateButtons() {
            let t;
            null !== this.experience.mouse.x &&
              null !== this.experience.mouse.y &&
              (this.experience.raycaster.setFromCamera(
                this.experience.mouse,
                this.experience.camera.instance
              ),
              (t = this.experience.raycast())),
              console.log("1"),
              t &&
                t.object.isUI &&
                (console.log("2"),
                this.experience.selectState
                  ? t.object.setState("selected")
                  : t.object.setState("hovered")),
              this.experience.objsToTest.forEach((e) => {
                (t && e === t.object) || !e.isUI || e.setState("idle");
              });
          }
          update() {
            this.updateButtons(), el();
          }
        }
        class ul {
          constructor() {
            (this.experience = new th()),
              (this.scene = this.experience.scene),
              (this.resources = this.experience.resources),
              this.resources.on("ready", () => {
                (this.player = new rl()),
                  (this.letters = new ol("letters", 160, !0)),
                  (this.skyDome = new ol("skydome", 0, !1)),
                  (this.trees = new ol("trees", 0, !1)),
                  (this.cinema = new ol("cinema", 0, !1)),
                  (this.cinemaScreen = new cl()),
                  (this.environment = new cu()),
                  (this.cameraPos = new pe()),
                  (this.cameraTempPos = new ft()),
                  this.player.model.add(this.cameraPos),
                  this.cameraPos.position.set(0, 3, -16);
              });
          }
          update() {
            this.player && this.player.update(),
              this.cinemaScreen && this.cinemaScreen.update(),
              this.cameraPos &&
                this.cameraTempPos.setFromMatrixPosition(
                  this.cameraPos.matrixWorld
                );
          }
        }
        class dl extends Ba {
          constructor(t) {
            super(t),
              (this.dracoLoader = null),
              (this.ktx2Loader = null),
              (this.meshoptDecoder = null),
              (this.pluginCallbacks = []),
              this.register(function (t) {
                return new pl(t);
              }),
              this.register(function (t) {
                return new _l(t);
              }),
              this.register(function (t) {
                return new bl(t);
              }),
              this.register(function (t) {
                return new gl(t);
              }),
              this.register(function (t) {
                return new xl(t);
              }),
              this.register(function (t) {
                return new vl(t);
              }),
              this.register(function (t) {
                return new yl(t);
              }),
              this.register(function (t) {
                return new wl(t);
              }),
              this.register(function (t) {
                return new fl(t);
              }),
              this.register(function (t) {
                return new Ml(t);
              });
          }
          load(t, e, n, s) {
            const i = this;
            let r;
            (r =
              "" !== this.resourcePath
                ? this.resourcePath
                : "" !== this.path
                ? this.path
                : cc.extractUrlBase(t)),
              this.manager.itemStart(t);
            const o = function (e) {
                s ? s(e) : console.error(e),
                  i.manager.itemError(t),
                  i.manager.itemEnd(t);
              },
              a = new Ga(this.manager);
            a.setPath(this.path),
              a.setResponseType("arraybuffer"),
              a.setRequestHeader(this.requestHeader),
              a.setWithCredentials(this.withCredentials),
              a.load(
                t,
                function (n) {
                  try {
                    i.parse(
                      n,
                      r,
                      function (n) {
                        e(n), i.manager.itemEnd(t);
                      },
                      o
                    );
                  } catch (t) {
                    o(t);
                  }
                },
                n,
                o
              );
          }
          setDRACOLoader(t) {
            return (this.dracoLoader = t), this;
          }
          setDDSLoader() {
            throw new Error(
              'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
            );
          }
          setKTX2Loader(t) {
            return (this.ktx2Loader = t), this;
          }
          setMeshoptDecoder(t) {
            return (this.meshoptDecoder = t), this;
          }
          register(t) {
            return (
              -1 === this.pluginCallbacks.indexOf(t) &&
                this.pluginCallbacks.push(t),
              this
            );
          }
          unregister(t) {
            return (
              -1 !== this.pluginCallbacks.indexOf(t) &&
                this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1),
              this
            );
          }
          parse(t, e, n, s) {
            let i;
            const r = {},
              o = {};
            if ("string" == typeof t) i = t;
            else if (cc.decodeText(new Uint8Array(t, 0, 4)) === Sl) {
              try {
                r[hl.KHR_BINARY_GLTF] = new Tl(t);
              } catch (t) {
                return void (s && s(t));
              }
              i = r[hl.KHR_BINARY_GLTF].content;
            } else i = cc.decodeText(new Uint8Array(t));
            const a = JSON.parse(i);
            if (void 0 === a.asset || a.asset.version[0] < 2)
              return void (
                s &&
                s(
                  new Error(
                    "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
                  )
                )
              );
            const c = new ql(a, {
              path: e || this.resourcePath || "",
              crossOrigin: this.crossOrigin,
              requestHeader: this.requestHeader,
              manager: this.manager,
              ktx2Loader: this.ktx2Loader,
              meshoptDecoder: this.meshoptDecoder,
            });
            c.fileLoader.setRequestHeader(this.requestHeader);
            for (let t = 0; t < this.pluginCallbacks.length; t++) {
              const e = this.pluginCallbacks[t](c);
              (o[e.name] = e), (r[e.name] = !0);
            }
            if (a.extensionsUsed)
              for (let t = 0; t < a.extensionsUsed.length; ++t) {
                const e = a.extensionsUsed[t],
                  n = a.extensionsRequired || [];
                switch (e) {
                  case hl.KHR_MATERIALS_UNLIT:
                    r[e] = new ml();
                    break;
                  case hl.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                    r[e] = new Ll();
                    break;
                  case hl.KHR_DRACO_MESH_COMPRESSION:
                    r[e] = new El(a, this.dracoLoader);
                    break;
                  case hl.KHR_TEXTURE_TRANSFORM:
                    r[e] = new Cl();
                    break;
                  case hl.KHR_MESH_QUANTIZATION:
                    r[e] = new Rl();
                    break;
                  default:
                    n.indexOf(e) >= 0 &&
                      void 0 === o[e] &&
                      console.warn(
                        'THREE.GLTFLoader: Unknown extension "' + e + '".'
                      );
                }
              }
            c.setExtensions(r), c.setPlugins(o), c.parse(n, s);
          }
        }
        function ll() {
          let t = {};
          return {
            get: function (e) {
              return t[e];
            },
            add: function (e, n) {
              t[e] = n;
            },
            remove: function (e) {
              delete t[e];
            },
            removeAll: function () {
              t = {};
            },
          };
        }
        const hl = {
          KHR_BINARY_GLTF: "KHR_binary_glTF",
          KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
          KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
          KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
          KHR_MATERIALS_IOR: "KHR_materials_ior",
          KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
            "KHR_materials_pbrSpecularGlossiness",
          KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
          KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
          KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
          KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
          KHR_MATERIALS_VOLUME: "KHR_materials_volume",
          KHR_TEXTURE_BASISU: "KHR_texture_basisu",
          KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
          KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
          EXT_TEXTURE_WEBP: "EXT_texture_webp",
          EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
        };
        class fl {
          constructor(t) {
            (this.parser = t),
              (this.name = hl.KHR_LIGHTS_PUNCTUAL),
              (this.cache = { refs: {}, uses: {} });
          }
          _markDefs() {
            const t = this.parser,
              e = this.parser.json.nodes || [];
            for (let n = 0, s = e.length; n < s; n++) {
              const s = e[n];
              s.extensions &&
                s.extensions[this.name] &&
                void 0 !== s.extensions[this.name].light &&
                t._addNodeRef(this.cache, s.extensions[this.name].light);
            }
          }
          _loadLight(t) {
            const e = this.parser,
              n = "light:" + t;
            let s = e.cache.get(n);
            if (s) return s;
            const i = e.json,
              r = (((i.extensions && i.extensions[this.name]) || {}).lights ||
                [])[t];
            let o;
            const a = new Oe(16777215);
            void 0 !== r.color && a.fromArray(r.color);
            const c = void 0 !== r.range ? r.range : 0;
            switch (r.type) {
              case "directional":
                (o = new rc(a)),
                  o.target.position.set(0, 0, -1),
                  o.add(o.target);
                break;
              case "point":
                (o = new sc(a)), (o.distance = c);
                break;
              case "spot":
                (o = new Ka(a)),
                  (o.distance = c),
                  (r.spot = r.spot || {}),
                  (r.spot.innerConeAngle =
                    void 0 !== r.spot.innerConeAngle
                      ? r.spot.innerConeAngle
                      : 0),
                  (r.spot.outerConeAngle =
                    void 0 !== r.spot.outerConeAngle
                      ? r.spot.outerConeAngle
                      : Math.PI / 4),
                  (o.angle = r.spot.outerConeAngle),
                  (o.penumbra =
                    1 - r.spot.innerConeAngle / r.spot.outerConeAngle),
                  o.target.position.set(0, 0, -1),
                  o.add(o.target);
                break;
              default:
                throw new Error(
                  "THREE.GLTFLoader: Unexpected light type: " + r.type
                );
            }
            return (
              o.position.set(0, 0, 0),
              (o.decay = 2),
              void 0 !== r.intensity && (o.intensity = r.intensity),
              (o.name = e.createUniqueName(r.name || "light_" + t)),
              (s = Promise.resolve(o)),
              e.cache.add(n, s),
              s
            );
          }
          createNodeAttachment(t) {
            const e = this,
              n = this.parser,
              s = n.json.nodes[t],
              i = ((s.extensions && s.extensions[this.name]) || {}).light;
            return void 0 === i
              ? null
              : this._loadLight(i).then(function (t) {
                  return n._getNodeRef(e.cache, i, t);
                });
          }
        }
        class ml {
          constructor() {
            this.name = hl.KHR_MATERIALS_UNLIT;
          }
          getMaterialType() {
            return ke;
          }
          extendParams(t, e, n) {
            const s = [];
            (t.color = new Oe(1, 1, 1)), (t.opacity = 1);
            const i = e.pbrMetallicRoughness;
            if (i) {
              if (Array.isArray(i.baseColorFactor)) {
                const e = i.baseColorFactor;
                t.color.fromArray(e), (t.opacity = e[3]);
              }
              void 0 !== i.baseColorTexture &&
                s.push(n.assignTexture(t, "map", i.baseColorTexture));
            }
            return Promise.all(s);
          }
        }
        class pl {
          constructor(t) {
            (this.parser = t), (this.name = hl.KHR_MATERIALS_CLEARCOAT);
          }
          getMaterialType(t) {
            const e = this.parser.json.materials[t];
            return e.extensions && e.extensions[this.name] ? ba : null;
          }
          extendMaterialParams(t, e) {
            const n = this.parser,
              s = n.json.materials[t];
            if (!s.extensions || !s.extensions[this.name])
              return Promise.resolve();
            const i = [],
              r = s.extensions[this.name];
            if (
              (void 0 !== r.clearcoatFactor &&
                (e.clearcoat = r.clearcoatFactor),
              void 0 !== r.clearcoatTexture &&
                i.push(n.assignTexture(e, "clearcoatMap", r.clearcoatTexture)),
              void 0 !== r.clearcoatRoughnessFactor &&
                (e.clearcoatRoughness = r.clearcoatRoughnessFactor),
              void 0 !== r.clearcoatRoughnessTexture &&
                i.push(
                  n.assignTexture(
                    e,
                    "clearcoatRoughnessMap",
                    r.clearcoatRoughnessTexture
                  )
                ),
              void 0 !== r.clearcoatNormalTexture &&
                (i.push(
                  n.assignTexture(
                    e,
                    "clearcoatNormalMap",
                    r.clearcoatNormalTexture
                  )
                ),
                void 0 !== r.clearcoatNormalTexture.scale))
            ) {
              const t = r.clearcoatNormalTexture.scale;
              e.clearcoatNormalScale = new Q(t, t);
            }
            return Promise.all(i);
          }
        }
        class gl {
          constructor(t) {
            (this.parser = t), (this.name = hl.KHR_MATERIALS_SHEEN);
          }
          getMaterialType(t) {
            const e = this.parser.json.materials[t];
            return e.extensions && e.extensions[this.name] ? ba : null;
          }
          extendMaterialParams(t, e) {
            const n = this.parser,
              s = n.json.materials[t];
            if (!s.extensions || !s.extensions[this.name])
              return Promise.resolve();
            const i = [];
            (e.sheenColor = new Oe(0, 0, 0)),
              (e.sheenRoughness = 0),
              (e.sheen = 1);
            const r = s.extensions[this.name];
            return (
              void 0 !== r.sheenColorFactor &&
                e.sheenColor.fromArray(r.sheenColorFactor),
              void 0 !== r.sheenRoughnessFactor &&
                (e.sheenRoughness = r.sheenRoughnessFactor),
              void 0 !== r.sheenColorTexture &&
                i.push(
                  n.assignTexture(e, "sheenColorMap", r.sheenColorTexture)
                ),
              void 0 !== r.sheenRoughnessTexture &&
                i.push(
                  n.assignTexture(
                    e,
                    "sheenRoughnessMap",
                    r.sheenRoughnessTexture
                  )
                ),
              Promise.all(i)
            );
          }
        }
        class xl {
          constructor(t) {
            (this.parser = t), (this.name = hl.KHR_MATERIALS_TRANSMISSION);
          }
          getMaterialType(t) {
            const e = this.parser.json.materials[t];
            return e.extensions && e.extensions[this.name] ? ba : null;
          }
          extendMaterialParams(t, e) {
            const n = this.parser,
              s = n.json.materials[t];
            if (!s.extensions || !s.extensions[this.name])
              return Promise.resolve();
            const i = [],
              r = s.extensions[this.name];
            return (
              void 0 !== r.transmissionFactor &&
                (e.transmission = r.transmissionFactor),
              void 0 !== r.transmissionTexture &&
                i.push(
                  n.assignTexture(e, "transmissionMap", r.transmissionTexture)
                ),
              Promise.all(i)
            );
          }
        }
        class vl {
          constructor(t) {
            (this.parser = t), (this.name = hl.KHR_MATERIALS_VOLUME);
          }
          getMaterialType(t) {
            const e = this.parser.json.materials[t];
            return e.extensions && e.extensions[this.name] ? ba : null;
          }
          extendMaterialParams(t, e) {
            const n = this.parser,
              s = n.json.materials[t];
            if (!s.extensions || !s.extensions[this.name])
              return Promise.resolve();
            const i = [],
              r = s.extensions[this.name];
            (e.thickness =
              void 0 !== r.thicknessFactor ? r.thicknessFactor : 0),
              void 0 !== r.thicknessTexture &&
                i.push(n.assignTexture(e, "thicknessMap", r.thicknessTexture)),
              (e.attenuationDistance = r.attenuationDistance || 0);
            const o = r.attenuationColor || [1, 1, 1];
            return (
              (e.attenuationColor = new Oe(o[0], o[1], o[2])), Promise.all(i)
            );
          }
        }
        class yl {
          constructor(t) {
            (this.parser = t), (this.name = hl.KHR_MATERIALS_IOR);
          }
          getMaterialType(t) {
            const e = this.parser.json.materials[t];
            return e.extensions && e.extensions[this.name] ? ba : null;
          }
          extendMaterialParams(t, e) {
            const n = this.parser.json.materials[t];
            if (!n.extensions || !n.extensions[this.name])
              return Promise.resolve();
            const s = n.extensions[this.name];
            return (e.ior = void 0 !== s.ior ? s.ior : 1.5), Promise.resolve();
          }
        }
        class wl {
          constructor(t) {
            (this.parser = t), (this.name = hl.KHR_MATERIALS_SPECULAR);
          }
          getMaterialType(t) {
            const e = this.parser.json.materials[t];
            return e.extensions && e.extensions[this.name] ? ba : null;
          }
          extendMaterialParams(t, e) {
            const n = this.parser,
              s = n.json.materials[t];
            if (!s.extensions || !s.extensions[this.name])
              return Promise.resolve();
            const i = [],
              r = s.extensions[this.name];
            (e.specularIntensity =
              void 0 !== r.specularFactor ? r.specularFactor : 1),
              void 0 !== r.specularTexture &&
                i.push(
                  n.assignTexture(e, "specularIntensityMap", r.specularTexture)
                );
            const o = r.specularColorFactor || [1, 1, 1];
            return (
              (e.specularColor = new Oe(o[0], o[1], o[2])),
              void 0 !== r.specularColorTexture &&
                i.push(
                  n
                    .assignTexture(
                      e,
                      "specularColorMap",
                      r.specularColorTexture
                    )
                    .then(function (t) {
                      t.encoding = I;
                    })
                ),
              Promise.all(i)
            );
          }
        }
        class _l {
          constructor(t) {
            (this.parser = t), (this.name = hl.KHR_TEXTURE_BASISU);
          }
          loadTexture(t) {
            const e = this.parser,
              n = e.json,
              s = n.textures[t];
            if (!s.extensions || !s.extensions[this.name]) return null;
            const i = s.extensions[this.name],
              r = n.images[i.source],
              o = e.options.ktx2Loader;
            if (!o) {
              if (
                n.extensionsRequired &&
                n.extensionsRequired.indexOf(this.name) >= 0
              )
                throw new Error(
                  "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
                );
              return null;
            }
            return e.loadTextureImage(t, r, o);
          }
        }
        class bl {
          constructor(t) {
            (this.parser = t),
              (this.name = hl.EXT_TEXTURE_WEBP),
              (this.isSupported = null);
          }
          loadTexture(t) {
            const e = this.name,
              n = this.parser,
              s = n.json,
              i = s.textures[t];
            if (!i.extensions || !i.extensions[e]) return null;
            const r = i.extensions[e],
              o = s.images[r.source];
            let a = n.textureLoader;
            if (o.uri) {
              const t = n.options.manager.getHandler(o.uri);
              null !== t && (a = t);
            }
            return this.detectSupport().then(function (i) {
              if (i) return n.loadTextureImage(t, o, a);
              if (s.extensionsRequired && s.extensionsRequired.indexOf(e) >= 0)
                throw new Error(
                  "THREE.GLTFLoader: WebP required by asset but unsupported."
                );
              return n.loadTexture(t);
            });
          }
          detectSupport() {
            return (
              this.isSupported ||
                (this.isSupported = new Promise(function (t) {
                  const e = new Image();
                  (e.src =
                    "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
                    (e.onload = e.onerror =
                      function () {
                        t(1 === e.height);
                      });
                })),
              this.isSupported
            );
          }
        }
        class Ml {
          constructor(t) {
            (this.name = hl.EXT_MESHOPT_COMPRESSION), (this.parser = t);
          }
          loadBufferView(t) {
            const e = this.parser.json,
              n = e.bufferViews[t];
            if (n.extensions && n.extensions[this.name]) {
              const t = n.extensions[this.name],
                s = this.parser.getDependency("buffer", t.buffer),
                i = this.parser.options.meshoptDecoder;
              if (!i || !i.supported) {
                if (
                  e.extensionsRequired &&
                  e.extensionsRequired.indexOf(this.name) >= 0
                )
                  throw new Error(
                    "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
                  );
                return null;
              }
              return Promise.all([s, i.ready]).then(function (e) {
                const n = t.byteOffset || 0,
                  s = t.byteLength || 0,
                  r = t.count,
                  o = t.byteStride,
                  a = new ArrayBuffer(r * o),
                  c = new Uint8Array(e[0], n, s);
                return (
                  i.decodeGltfBuffer(
                    new Uint8Array(a),
                    r,
                    o,
                    c,
                    t.mode,
                    t.filter
                  ),
                  a
                );
              });
            }
            return null;
          }
        }
        const Sl = "glTF";
        class Tl {
          constructor(t) {
            (this.name = hl.KHR_BINARY_GLTF),
              (this.content = null),
              (this.body = null);
            const e = new DataView(t, 0, 12);
            if (
              ((this.header = {
                magic: cc.decodeText(new Uint8Array(t.slice(0, 4))),
                version: e.getUint32(4, !0),
                length: e.getUint32(8, !0),
              }),
              this.header.magic !== Sl)
            )
              throw new Error(
                "THREE.GLTFLoader: Unsupported glTF-Binary header."
              );
            if (this.header.version < 2)
              throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
            const n = this.header.length - 12,
              s = new DataView(t, 12);
            let i = 0;
            for (; i < n; ) {
              const e = s.getUint32(i, !0);
              i += 4;
              const n = s.getUint32(i, !0);
              if (((i += 4), 1313821514 === n)) {
                const n = new Uint8Array(t, 12 + i, e);
                this.content = cc.decodeText(n);
              } else if (5130562 === n) {
                const n = 12 + i;
                this.body = t.slice(n, n + e);
              }
              i += e;
            }
            if (null === this.content)
              throw new Error("THREE.GLTFLoader: JSON content not found.");
          }
        }
        class El {
          constructor(t, e) {
            if (!e)
              throw new Error(
                "THREE.GLTFLoader: No DRACOLoader instance provided."
              );
            (this.name = hl.KHR_DRACO_MESH_COMPRESSION),
              (this.json = t),
              (this.dracoLoader = e),
              this.dracoLoader.preload();
          }
          decodePrimitive(t, e) {
            const n = this.json,
              s = this.dracoLoader,
              i = t.extensions[this.name].bufferView,
              r = t.extensions[this.name].attributes,
              o = {},
              a = {},
              c = {};
            for (const t in r) {
              const e = zl[t] || t.toLowerCase();
              o[e] = r[t];
            }
            for (const e in t.attributes) {
              const s = zl[e] || e.toLowerCase();
              if (void 0 !== r[e]) {
                const i = n.accessors[t.attributes[e]],
                  r = Nl[i.componentType];
                (c[s] = r), (a[s] = !0 === i.normalized);
              }
            }
            return e.getDependency("bufferView", i).then(function (t) {
              return new Promise(function (e) {
                s.decodeDracoFile(
                  t,
                  function (t) {
                    for (const e in t.attributes) {
                      const n = t.attributes[e],
                        s = a[e];
                      void 0 !== s && (n.normalized = s);
                    }
                    e(t);
                  },
                  o,
                  c
                );
              });
            });
          }
        }
        class Cl {
          constructor() {
            this.name = hl.KHR_TEXTURE_TRANSFORM;
          }
          extendTexture(t, e) {
            return (
              void 0 !== e.texCoord &&
                console.warn(
                  'THREE.GLTFLoader: Custom UV sets in "' +
                    this.name +
                    '" extension not yet supported.'
                ),
              (void 0 === e.offset &&
                void 0 === e.rotation &&
                void 0 === e.scale) ||
                ((t = t.clone()),
                void 0 !== e.offset && t.offset.fromArray(e.offset),
                void 0 !== e.rotation && (t.rotation = e.rotation),
                void 0 !== e.scale && t.repeat.fromArray(e.scale),
                (t.needsUpdate = !0)),
              t
            );
          }
        }
        class Al extends _a {
          constructor(t) {
            super(), (this.isGLTFSpecularGlossinessMaterial = !0);
            const e = [
                "#ifdef USE_SPECULARMAP",
                "\tuniform sampler2D specularMap;",
                "#endif",
              ].join("\n"),
              n = [
                "#ifdef USE_GLOSSINESSMAP",
                "\tuniform sampler2D glossinessMap;",
                "#endif",
              ].join("\n"),
              s = [
                "vec3 specularFactor = specular;",
                "#ifdef USE_SPECULARMAP",
                "\tvec4 texelSpecular = texture2D( specularMap, vUv );",
                "\ttexelSpecular = sRGBToLinear( texelSpecular );",
                "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
                "\tspecularFactor *= texelSpecular.rgb;",
                "#endif",
              ].join("\n"),
              i = [
                "float glossinessFactor = glossiness;",
                "#ifdef USE_GLOSSINESSMAP",
                "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );",
                "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
                "\tglossinessFactor *= texelGlossiness.a;",
                "#endif",
              ].join("\n"),
              r = [
                "PhysicalMaterial material;",
                "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
                "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
                "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
                "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
                "material.roughness += geometryRoughness;",
                "material.roughness = min( material.roughness, 1.0 );",
                "material.specularColor = specularFactor;",
              ].join("\n"),
              o = {
                specular: { value: new Oe().setHex(16777215) },
                glossiness: { value: 1 },
                specularMap: { value: null },
                glossinessMap: { value: null },
              };
            (this._extraUniforms = o),
              (this.onBeforeCompile = function (t) {
                for (const e in o) t.uniforms[e] = o[e];
                t.fragmentShader = t.fragmentShader
                  .replace("uniform float roughness;", "uniform vec3 specular;")
                  .replace(
                    "uniform float metalness;",
                    "uniform float glossiness;"
                  )
                  .replace("#include <roughnessmap_pars_fragment>", e)
                  .replace("#include <metalnessmap_pars_fragment>", n)
                  .replace("#include <roughnessmap_fragment>", s)
                  .replace("#include <metalnessmap_fragment>", i)
                  .replace("#include <lights_physical_fragment>", r);
              }),
              Object.defineProperties(this, {
                specular: {
                  get: function () {
                    return o.specular.value;
                  },
                  set: function (t) {
                    o.specular.value = t;
                  },
                },
                specularMap: {
                  get: function () {
                    return o.specularMap.value;
                  },
                  set: function (t) {
                    (o.specularMap.value = t),
                      t
                        ? (this.defines.USE_SPECULARMAP = "")
                        : delete this.defines.USE_SPECULARMAP;
                  },
                },
                glossiness: {
                  get: function () {
                    return o.glossiness.value;
                  },
                  set: function (t) {
                    o.glossiness.value = t;
                  },
                },
                glossinessMap: {
                  get: function () {
                    return o.glossinessMap.value;
                  },
                  set: function (t) {
                    (o.glossinessMap.value = t),
                      t
                        ? ((this.defines.USE_GLOSSINESSMAP = ""),
                          (this.defines.USE_UV = ""))
                        : (delete this.defines.USE_GLOSSINESSMAP,
                          delete this.defines.USE_UV);
                  },
                },
              }),
              delete this.metalness,
              delete this.roughness,
              delete this.metalnessMap,
              delete this.roughnessMap,
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.specularMap = t.specularMap),
              this.specular.copy(t.specular),
              (this.glossinessMap = t.glossinessMap),
              (this.glossiness = t.glossiness),
              delete this.metalness,
              delete this.roughness,
              delete this.metalnessMap,
              delete this.roughnessMap,
              this
            );
          }
        }
        class Ll {
          constructor() {
            (this.name = hl.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS),
              (this.specularGlossinessParams = [
                "color",
                "map",
                "lightMap",
                "lightMapIntensity",
                "aoMap",
                "aoMapIntensity",
                "emissive",
                "emissiveIntensity",
                "emissiveMap",
                "bumpMap",
                "bumpScale",
                "normalMap",
                "normalMapType",
                "displacementMap",
                "displacementScale",
                "displacementBias",
                "specularMap",
                "specular",
                "glossinessMap",
                "glossiness",
                "alphaMap",
                "envMap",
                "envMapIntensity",
                "refractionRatio",
              ]);
          }
          getMaterialType() {
            return Al;
          }
          extendParams(t, e, n) {
            const s = e.extensions[this.name];
            (t.color = new Oe(1, 1, 1)), (t.opacity = 1);
            const i = [];
            if (Array.isArray(s.diffuseFactor)) {
              const e = s.diffuseFactor;
              t.color.fromArray(e), (t.opacity = e[3]);
            }
            if (
              (void 0 !== s.diffuseTexture &&
                i.push(n.assignTexture(t, "map", s.diffuseTexture)),
              (t.emissive = new Oe(0, 0, 0)),
              (t.glossiness =
                void 0 !== s.glossinessFactor ? s.glossinessFactor : 1),
              (t.specular = new Oe(1, 1, 1)),
              Array.isArray(s.specularFactor) &&
                t.specular.fromArray(s.specularFactor),
              void 0 !== s.specularGlossinessTexture)
            ) {
              const e = s.specularGlossinessTexture;
              i.push(n.assignTexture(t, "glossinessMap", e)),
                i.push(n.assignTexture(t, "specularMap", e));
            }
            return Promise.all(i);
          }
          createMaterial(t) {
            const e = new Al(t);
            return (
              (e.fog = !0),
              (e.color = t.color),
              (e.map = void 0 === t.map ? null : t.map),
              (e.lightMap = null),
              (e.lightMapIntensity = 1),
              (e.aoMap = void 0 === t.aoMap ? null : t.aoMap),
              (e.aoMapIntensity = 1),
              (e.emissive = t.emissive),
              (e.emissiveIntensity = 1),
              (e.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap),
              (e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap),
              (e.bumpScale = 1),
              (e.normalMap = void 0 === t.normalMap ? null : t.normalMap),
              (e.normalMapType = 0),
              t.normalScale && (e.normalScale = t.normalScale),
              (e.displacementMap = null),
              (e.displacementScale = 1),
              (e.displacementBias = 0),
              (e.specularMap = void 0 === t.specularMap ? null : t.specularMap),
              (e.specular = t.specular),
              (e.glossinessMap =
                void 0 === t.glossinessMap ? null : t.glossinessMap),
              (e.glossiness = t.glossiness),
              (e.alphaMap = null),
              (e.envMap = void 0 === t.envMap ? null : t.envMap),
              (e.envMapIntensity = 1),
              (e.refractionRatio = 0.98),
              e
            );
          }
        }
        class Rl {
          constructor() {
            this.name = hl.KHR_MESH_QUANTIZATION;
          }
        }
        class Pl extends Sa {
          constructor(t, e, n, s) {
            super(t, e, n, s);
          }
          copySampleValue_(t) {
            const e = this.resultBuffer,
              n = this.sampleValues,
              s = this.valueSize,
              i = t * s * 3 + s;
            for (let t = 0; t !== s; t++) e[t] = n[i + t];
            return e;
          }
        }
        (Pl.prototype.beforeStart_ = Pl.prototype.copySampleValue_),
          (Pl.prototype.afterEnd_ = Pl.prototype.copySampleValue_),
          (Pl.prototype.interpolate_ = function (t, e, n, s) {
            const i = this.resultBuffer,
              r = this.sampleValues,
              o = this.valueSize,
              a = 2 * o,
              c = 3 * o,
              u = s - e,
              d = (n - e) / u,
              l = d * d,
              h = l * d,
              f = t * c,
              m = f - c,
              p = -2 * h + 3 * l,
              g = h - l,
              x = 1 - p,
              v = g - l + d;
            for (let t = 0; t !== o; t++) {
              const e = r[m + t + o],
                n = r[m + t + a] * u,
                s = r[f + t + o],
                c = r[f + t] * u;
              i[t] = x * e + v * n + p * s + g * c;
            }
            return i;
          });
        const Il = new ht();
        class Dl extends Pl {
          interpolate_(t, e, n, s) {
            const i = super.interpolate_(t, e, n, s);
            return Il.fromArray(i).normalize().toArray(i), i;
          }
        }
        const Nl = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array,
          },
          Ol = { 9728: d, 9729: f, 9984: l, 9985: 1007, 9986: h, 9987: m },
          kl = { 33071: c, 33648: u, 10497: a },
          Ul = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16,
          },
          zl = {
            POSITION: "position",
            NORMAL: "normal",
            TANGENT: "tangent",
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv2",
            COLOR_0: "color",
            WEIGHTS_0: "skinWeight",
            JOINTS_0: "skinIndex",
          },
          Fl = {
            scale: "scale",
            translation: "position",
            rotation: "quaternion",
            weights: "morphTargetInfluences",
          },
          Bl = { CUBICSPLINE: void 0, LINEAR: E, STEP: T };
        function Hl(t, e, n) {
          for (const s in n.extensions)
            void 0 === t[s] &&
              ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
              (e.userData.gltfExtensions[s] = n.extensions[s]));
        }
        function Gl(t, e) {
          void 0 !== e.extras &&
            ("object" == typeof e.extras
              ? Object.assign(t.userData, e.extras)
              : console.warn(
                  "THREE.GLTFLoader: Ignoring primitive type .extras, " +
                    e.extras
                ));
        }
        function Vl(t, e) {
          if ((t.updateMorphTargets(), void 0 !== e.weights))
            for (let n = 0, s = e.weights.length; n < s; n++)
              t.morphTargetInfluences[n] = e.weights[n];
          if (e.extras && Array.isArray(e.extras.targetNames)) {
            const n = e.extras.targetNames;
            if (t.morphTargetInfluences.length === n.length) {
              t.morphTargetDictionary = {};
              for (let e = 0, s = n.length; e < s; e++)
                t.morphTargetDictionary[n[e]] = e;
            } else
              console.warn(
                "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
              );
          }
        }
        function Wl(t) {
          const e = t.extensions && t.extensions[hl.KHR_DRACO_MESH_COMPRESSION];
          let n;
          return (
            (n = e
              ? "draco:" +
                e.bufferView +
                ":" +
                e.indices +
                ":" +
                jl(e.attributes)
              : t.indices + ":" + jl(t.attributes) + ":" + t.mode),
            n
          );
        }
        function jl(t) {
          let e = "";
          const n = Object.keys(t).sort();
          for (let s = 0, i = n.length; s < i; s++)
            e += n[s] + ":" + t[n[s]] + ";";
          return e;
        }
        function Xl(t) {
          switch (t) {
            case Int8Array:
              return 1 / 127;
            case Uint8Array:
              return 1 / 255;
            case Int16Array:
              return 1 / 32767;
            case Uint16Array:
              return 1 / 65535;
            default:
              throw new Error(
                "THREE.GLTFLoader: Unsupported normalized accessor component type."
              );
          }
        }
        class ql {
          constructor(t = {}, e = {}) {
            (this.json = t),
              (this.extensions = {}),
              (this.plugins = {}),
              (this.options = e),
              (this.cache = new ll()),
              (this.associations = new Map()),
              (this.primitiveCache = {}),
              (this.meshCache = { refs: {}, uses: {} }),
              (this.cameraCache = { refs: {}, uses: {} }),
              (this.lightCache = { refs: {}, uses: {} }),
              (this.textureCache = {}),
              (this.nodeNamesUsed = {}),
              "undefined" != typeof createImageBitmap &&
              !1 === /Firefox/.test(navigator.userAgent)
                ? (this.textureLoader = new uc(this.options.manager))
                : (this.textureLoader = new ja(this.options.manager)),
              this.textureLoader.setCrossOrigin(this.options.crossOrigin),
              this.textureLoader.setRequestHeader(this.options.requestHeader),
              (this.fileLoader = new Ga(this.options.manager)),
              this.fileLoader.setResponseType("arraybuffer"),
              "use-credentials" === this.options.crossOrigin &&
                this.fileLoader.setWithCredentials(!0);
          }
          setExtensions(t) {
            this.extensions = t;
          }
          setPlugins(t) {
            this.plugins = t;
          }
          parse(t, e) {
            const n = this,
              s = this.json,
              i = this.extensions;
            this.cache.removeAll(),
              this._invokeAll(function (t) {
                return t._markDefs && t._markDefs();
              }),
              Promise.all(
                this._invokeAll(function (t) {
                  return t.beforeRoot && t.beforeRoot();
                })
              )
                .then(function () {
                  return Promise.all([
                    n.getDependencies("scene"),
                    n.getDependencies("animation"),
                    n.getDependencies("camera"),
                  ]);
                })
                .then(function (e) {
                  const r = {
                    scene: e[0][s.scene || 0],
                    scenes: e[0],
                    animations: e[1],
                    cameras: e[2],
                    asset: s.asset,
                    parser: n,
                    userData: {},
                  };
                  Hl(i, r, s),
                    Gl(r, s),
                    Promise.all(
                      n._invokeAll(function (t) {
                        return t.afterRoot && t.afterRoot(r);
                      })
                    ).then(function () {
                      t(r);
                    });
                })
                .catch(e);
          }
          _markDefs() {
            const t = this.json.nodes || [],
              e = this.json.skins || [],
              n = this.json.meshes || [];
            for (let n = 0, s = e.length; n < s; n++) {
              const s = e[n].joints;
              for (let e = 0, n = s.length; e < n; e++) t[s[e]].isBone = !0;
            }
            for (let e = 0, s = t.length; e < s; e++) {
              const s = t[e];
              void 0 !== s.mesh &&
                (this._addNodeRef(this.meshCache, s.mesh),
                void 0 !== s.skin && (n[s.mesh].isSkinnedMesh = !0)),
                void 0 !== s.camera &&
                  this._addNodeRef(this.cameraCache, s.camera);
            }
          }
          _addNodeRef(t, e) {
            void 0 !== e &&
              (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0),
              t.refs[e]++);
          }
          _getNodeRef(t, e, n) {
            if (t.refs[e] <= 1) return n;
            const s = n.clone(),
              i = (t, e) => {
                const n = this.associations.get(t);
                null != n && this.associations.set(e, n);
                for (const [n, s] of t.children.entries()) i(s, e.children[n]);
              };
            return i(n, s), (s.name += "_instance_" + t.uses[e]++), s;
          }
          _invokeOne(t) {
            const e = Object.values(this.plugins);
            e.push(this);
            for (let n = 0; n < e.length; n++) {
              const s = t(e[n]);
              if (s) return s;
            }
            return null;
          }
          _invokeAll(t) {
            const e = Object.values(this.plugins);
            e.unshift(this);
            const n = [];
            for (let s = 0; s < e.length; s++) {
              const i = t(e[s]);
              i && n.push(i);
            }
            return n;
          }
          getDependency(t, e) {
            const n = t + ":" + e;
            let s = this.cache.get(n);
            if (!s) {
              switch (t) {
                case "scene":
                  s = this.loadScene(e);
                  break;
                case "node":
                  s = this.loadNode(e);
                  break;
                case "mesh":
                  s = this._invokeOne(function (t) {
                    return t.loadMesh && t.loadMesh(e);
                  });
                  break;
                case "accessor":
                  s = this.loadAccessor(e);
                  break;
                case "bufferView":
                  s = this._invokeOne(function (t) {
                    return t.loadBufferView && t.loadBufferView(e);
                  });
                  break;
                case "buffer":
                  s = this.loadBuffer(e);
                  break;
                case "material":
                  s = this._invokeOne(function (t) {
                    return t.loadMaterial && t.loadMaterial(e);
                  });
                  break;
                case "texture":
                  s = this._invokeOne(function (t) {
                    return t.loadTexture && t.loadTexture(e);
                  });
                  break;
                case "skin":
                  s = this.loadSkin(e);
                  break;
                case "animation":
                  s = this.loadAnimation(e);
                  break;
                case "camera":
                  s = this.loadCamera(e);
                  break;
                default:
                  throw new Error("Unknown type: " + t);
              }
              this.cache.add(n, s);
            }
            return s;
          }
          getDependencies(t) {
            let e = this.cache.get(t);
            if (!e) {
              const n = this,
                s = this.json[t + ("mesh" === t ? "es" : "s")] || [];
              (e = Promise.all(
                s.map(function (e, s) {
                  return n.getDependency(t, s);
                })
              )),
                this.cache.add(t, e);
            }
            return e;
          }
          loadBuffer(t) {
            const e = this.json.buffers[t],
              n = this.fileLoader;
            if (e.type && "arraybuffer" !== e.type)
              throw new Error(
                "THREE.GLTFLoader: " + e.type + " buffer type is not supported."
              );
            if (void 0 === e.uri && 0 === t)
              return Promise.resolve(this.extensions[hl.KHR_BINARY_GLTF].body);
            const s = this.options;
            return new Promise(function (t, i) {
              n.load(cc.resolveURL(e.uri, s.path), t, void 0, function () {
                i(
                  new Error(
                    'THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'
                  )
                );
              });
            });
          }
          loadBufferView(t) {
            const e = this.json.bufferViews[t];
            return this.getDependency("buffer", e.buffer).then(function (t) {
              const n = e.byteLength || 0,
                s = e.byteOffset || 0;
              return t.slice(s, s + n);
            });
          }
          loadAccessor(t) {
            const e = this,
              n = this.json,
              s = this.json.accessors[t];
            if (void 0 === s.bufferView && void 0 === s.sparse)
              return Promise.resolve(null);
            const i = [];
            return (
              void 0 !== s.bufferView
                ? i.push(this.getDependency("bufferView", s.bufferView))
                : i.push(null),
              void 0 !== s.sparse &&
                (i.push(
                  this.getDependency("bufferView", s.sparse.indices.bufferView)
                ),
                i.push(
                  this.getDependency("bufferView", s.sparse.values.bufferView)
                )),
              Promise.all(i).then(function (t) {
                const i = t[0],
                  r = Ul[s.type],
                  o = Nl[s.componentType],
                  a = o.BYTES_PER_ELEMENT,
                  c = a * r,
                  u = s.byteOffset || 0,
                  d =
                    void 0 !== s.bufferView
                      ? n.bufferViews[s.bufferView].byteStride
                      : void 0,
                  l = !0 === s.normalized;
                let h, f;
                if (d && d !== c) {
                  const t = Math.floor(u / d),
                    n =
                      "InterleavedBuffer:" +
                      s.bufferView +
                      ":" +
                      s.componentType +
                      ":" +
                      t +
                      ":" +
                      s.count;
                  let c = e.cache.get(n);
                  c ||
                    ((h = new o(i, t * d, (s.count * d) / a)),
                    (c = new Mr(h, d / a)),
                    e.cache.add(n, c)),
                    (f = new Tr(c, r, (u % d) / a, l));
                } else (h = null === i ? new o(s.count * r) : new o(i, u, s.count * r)), (f = new Fe(h, r, l));
                if (void 0 !== s.sparse) {
                  const e = Ul.SCALAR,
                    n = Nl[s.sparse.indices.componentType],
                    a = s.sparse.indices.byteOffset || 0,
                    c = s.sparse.values.byteOffset || 0,
                    u = new n(t[1], a, s.sparse.count * e),
                    d = new o(t[2], c, s.sparse.count * r);
                  null !== i &&
                    (f = new Fe(f.array.slice(), f.itemSize, f.normalized));
                  for (let t = 0, e = u.length; t < e; t++) {
                    const e = u[t];
                    if (
                      (f.setX(e, d[t * r]),
                      r >= 2 && f.setY(e, d[t * r + 1]),
                      r >= 3 && f.setZ(e, d[t * r + 2]),
                      r >= 4 && f.setW(e, d[t * r + 3]),
                      r >= 5)
                    )
                      throw new Error(
                        "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
                      );
                  }
                }
                return f;
              })
            );
          }
          loadTexture(t) {
            const e = this.json,
              n = this.options,
              s = e.textures[t],
              i = e.images[s.source];
            let r = this.textureLoader;
            if (i.uri) {
              const t = n.manager.getHandler(i.uri);
              null !== t && (r = t);
            }
            return this.loadTextureImage(t, i, r);
          }
          loadTextureImage(t, e, n) {
            const s = this,
              i = this.json,
              r = this.options,
              o = i.textures[t],
              c = (e.uri || e.bufferView) + ":" + o.sampler;
            if (this.textureCache[c]) return this.textureCache[c];
            const u = self.URL || self.webkitURL;
            let d = e.uri || "",
              l = !1;
            if (void 0 !== e.bufferView)
              d = s
                .getDependency("bufferView", e.bufferView)
                .then(function (t) {
                  l = !0;
                  const n = new Blob([t], { type: e.mimeType });
                  return (d = u.createObjectURL(n)), d;
                });
            else if (void 0 === e.uri)
              throw new Error(
                "THREE.GLTFLoader: Image " +
                  t +
                  " is missing URI and bufferView"
              );
            const h = Promise.resolve(d)
              .then(function (t) {
                return new Promise(function (e, s) {
                  let i = e;
                  !0 === n.isImageBitmapLoader &&
                    (i = function (t) {
                      const n = new at(t);
                      (n.needsUpdate = !0), e(n);
                    }),
                    n.load(cc.resolveURL(t, r.path), i, void 0, s);
                });
              })
              .then(function (e) {
                !0 === l && u.revokeObjectURL(d),
                  (e.flipY = !1),
                  o.name && (e.name = o.name);
                const n = (i.samplers || {})[o.sampler] || {};
                return (
                  (e.magFilter = Ol[n.magFilter] || f),
                  (e.minFilter = Ol[n.minFilter] || m),
                  (e.wrapS = kl[n.wrapS] || a),
                  (e.wrapT = kl[n.wrapT] || a),
                  s.associations.set(e, { textures: t }),
                  e
                );
              })
              .catch(function () {
                return (
                  console.error("THREE.GLTFLoader: Couldn't load texture", d),
                  null
                );
              });
            return (this.textureCache[c] = h), h;
          }
          assignTexture(t, e, n) {
            const s = this;
            return this.getDependency("texture", n.index).then(function (i) {
              if (
                (void 0 === n.texCoord ||
                  0 == n.texCoord ||
                  ("aoMap" === e && 1 == n.texCoord) ||
                  console.warn(
                    "THREE.GLTFLoader: Custom UV set " +
                      n.texCoord +
                      " for texture " +
                      e +
                      " not yet supported."
                  ),
                s.extensions[hl.KHR_TEXTURE_TRANSFORM])
              ) {
                const t =
                  void 0 !== n.extensions
                    ? n.extensions[hl.KHR_TEXTURE_TRANSFORM]
                    : void 0;
                if (t) {
                  const e = s.associations.get(i);
                  (i = s.extensions[hl.KHR_TEXTURE_TRANSFORM].extendTexture(
                    i,
                    t
                  )),
                    s.associations.set(i, e);
                }
              }
              return (t[e] = i), i;
            });
          }
          assignFinalMaterial(t) {
            const e = t.geometry;
            let n = t.material;
            const s = void 0 === e.attributes.tangent,
              i = void 0 !== e.attributes.color,
              r = void 0 === e.attributes.normal;
            if (t.isPoints) {
              const t = "PointsMaterial:" + n.uuid;
              let e = this.cache.get(t);
              e ||
                ((e = new po()),
                Ae.prototype.copy.call(e, n),
                e.color.copy(n.color),
                (e.map = n.map),
                (e.sizeAttenuation = !1),
                this.cache.add(t, e)),
                (n = e);
            } else if (t.isLine) {
              const t = "LineBasicMaterial:" + n.uuid;
              let e = this.cache.get(t);
              e ||
                ((e = new so()),
                Ae.prototype.copy.call(e, n),
                e.color.copy(n.color),
                this.cache.add(t, e)),
                (n = e);
            }
            if (s || i || r) {
              let t = "ClonedMaterial:" + n.uuid + ":";
              n.isGLTFSpecularGlossinessMaterial &&
                (t += "specular-glossiness:"),
                s && (t += "derivative-tangents:"),
                i && (t += "vertex-colors:"),
                r && (t += "flat-shading:");
              let e = this.cache.get(t);
              e ||
                ((e = n.clone()),
                i && (e.vertexColors = !0),
                r && (e.flatShading = !0),
                s &&
                  (e.normalScale && (e.normalScale.y *= -1),
                  e.clearcoatNormalScale && (e.clearcoatNormalScale.y *= -1)),
                this.cache.add(t, e),
                this.associations.set(e, this.associations.get(n))),
                (n = e);
            }
            n.aoMap &&
              void 0 === e.attributes.uv2 &&
              void 0 !== e.attributes.uv &&
              e.setAttribute("uv2", e.attributes.uv),
              (t.material = n);
          }
          getMaterialType() {
            return _a;
          }
          loadMaterial(t) {
            const e = this,
              n = this.json,
              s = this.extensions,
              i = n.materials[t];
            let r;
            const o = {},
              a = i.extensions || {},
              c = [];
            if (a[hl.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
              const t = s[hl.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
              (r = t.getMaterialType()), c.push(t.extendParams(o, i, e));
            } else if (a[hl.KHR_MATERIALS_UNLIT]) {
              const t = s[hl.KHR_MATERIALS_UNLIT];
              (r = t.getMaterialType()), c.push(t.extendParams(o, i, e));
            } else {
              const n = i.pbrMetallicRoughness || {};
              if (
                ((o.color = new Oe(1, 1, 1)),
                (o.opacity = 1),
                Array.isArray(n.baseColorFactor))
              ) {
                const t = n.baseColorFactor;
                o.color.fromArray(t), (o.opacity = t[3]);
              }
              void 0 !== n.baseColorTexture &&
                c.push(e.assignTexture(o, "map", n.baseColorTexture)),
                (o.metalness =
                  void 0 !== n.metallicFactor ? n.metallicFactor : 1),
                (o.roughness =
                  void 0 !== n.roughnessFactor ? n.roughnessFactor : 1),
                void 0 !== n.metallicRoughnessTexture &&
                  (c.push(
                    e.assignTexture(
                      o,
                      "metalnessMap",
                      n.metallicRoughnessTexture
                    )
                  ),
                  c.push(
                    e.assignTexture(
                      o,
                      "roughnessMap",
                      n.metallicRoughnessTexture
                    )
                  )),
                (r = this._invokeOne(function (e) {
                  return e.getMaterialType && e.getMaterialType(t);
                })),
                c.push(
                  Promise.all(
                    this._invokeAll(function (e) {
                      return (
                        e.extendMaterialParams && e.extendMaterialParams(t, o)
                      );
                    })
                  )
                );
            }
            !0 === i.doubleSided && (o.side = 2);
            const u = i.alphaMode || "OPAQUE";
            if (
              ("BLEND" === u
                ? ((o.transparent = !0), (o.depthWrite = !1))
                : ((o.format = _),
                  (o.transparent = !1),
                  "MASK" === u &&
                    (o.alphaTest =
                      void 0 !== i.alphaCutoff ? i.alphaCutoff : 0.5)),
              void 0 !== i.normalTexture &&
                r !== ke &&
                (c.push(e.assignTexture(o, "normalMap", i.normalTexture)),
                (o.normalScale = new Q(1, 1)),
                void 0 !== i.normalTexture.scale))
            ) {
              const t = i.normalTexture.scale;
              o.normalScale.set(t, t);
            }
            return (
              void 0 !== i.occlusionTexture &&
                r !== ke &&
                (c.push(e.assignTexture(o, "aoMap", i.occlusionTexture)),
                void 0 !== i.occlusionTexture.strength &&
                  (o.aoMapIntensity = i.occlusionTexture.strength)),
              void 0 !== i.emissiveFactor &&
                r !== ke &&
                (o.emissive = new Oe().fromArray(i.emissiveFactor)),
              void 0 !== i.emissiveTexture &&
                r !== ke &&
                c.push(e.assignTexture(o, "emissiveMap", i.emissiveTexture)),
              Promise.all(c).then(function () {
                let n;
                return (
                  (n =
                    r === Al
                      ? s[
                          hl.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS
                        ].createMaterial(o)
                      : new r(o)),
                  i.name && (n.name = i.name),
                  n.map && (n.map.encoding = I),
                  n.emissiveMap && (n.emissiveMap.encoding = I),
                  Gl(n, i),
                  e.associations.set(n, { materials: t }),
                  i.extensions && Hl(s, n, i),
                  n
                );
              })
            );
          }
          createUniqueName(t) {
            const e = bc.sanitizeNodeName(t || "");
            let n = e;
            for (let t = 1; this.nodeNamesUsed[n]; ++t) n = e + "_" + t;
            return (this.nodeNamesUsed[n] = !0), n;
          }
          loadGeometries(t) {
            const e = this,
              n = this.extensions,
              s = this.primitiveCache;
            function i(t) {
              return n[hl.KHR_DRACO_MESH_COMPRESSION]
                .decodePrimitive(t, e)
                .then(function (n) {
                  return Jl(n, t, e);
                });
            }
            const r = [];
            for (let n = 0, o = t.length; n < o; n++) {
              const o = t[n],
                a = Wl(o),
                c = s[a];
              if (c) r.push(c.promise);
              else {
                let t;
                (t =
                  o.extensions && o.extensions[hl.KHR_DRACO_MESH_COMPRESSION]
                    ? i(o)
                    : Jl(new Ze(), o, e)),
                  (s[a] = { primitive: o, promise: t }),
                  r.push(t);
              }
            }
            return Promise.all(r);
          }
          loadMesh(t) {
            const e = this,
              n = this.json,
              s = this.extensions,
              i = n.meshes[t],
              r = i.primitives,
              o = [];
            for (let t = 0, e = r.length; t < e; t++) {
              const e =
                void 0 === r[t].material
                  ? (void 0 === (a = this.cache).DefaultMaterial &&
                      (a.DefaultMaterial = new _a({
                        color: 16777215,
                        emissive: 0,
                        metalness: 1,
                        roughness: 1,
                        transparent: !1,
                        depthTest: !0,
                        side: 0,
                      })),
                    a.DefaultMaterial)
                  : this.getDependency("material", r[t].material);
              o.push(e);
            }
            var a;
            return (
              o.push(e.loadGeometries(r)),
              Promise.all(o).then(function (n) {
                const o = n.slice(0, n.length - 1),
                  a = n[n.length - 1],
                  c = [];
                for (let n = 0, u = a.length; n < u; n++) {
                  const u = a[n],
                    d = r[n];
                  let l;
                  const h = o[n];
                  if (
                    4 === d.mode ||
                    5 === d.mode ||
                    6 === d.mode ||
                    void 0 === d.mode
                  )
                    (l = !0 === i.isSkinnedMesh ? new Xr(u, h) : new pn(u, h)),
                      !0 !== l.isSkinnedMesh ||
                        l.geometry.attributes.skinWeight.normalized ||
                        l.normalizeSkinWeights(),
                      5 === d.mode
                        ? (l.geometry = Zl(l.geometry, 1))
                        : 6 === d.mode && (l.geometry = Zl(l.geometry, 2));
                  else if (1 === d.mode) l = new fo(u, h);
                  else if (3 === d.mode) l = new uo(u, h);
                  else if (2 === d.mode) l = new mo(u, h);
                  else {
                    if (0 !== d.mode)
                      throw new Error(
                        "THREE.GLTFLoader: Primitive mode unsupported: " +
                          d.mode
                      );
                    l = new wo(u, h);
                  }
                  Object.keys(l.geometry.morphAttributes).length > 0 &&
                    Vl(l, i),
                    (l.name = e.createUniqueName(i.name || "mesh_" + t)),
                    Gl(l, i),
                    d.extensions && Hl(s, l, d),
                    e.assignFinalMaterial(l),
                    c.push(l);
                }
                for (let n = 0, s = c.length; n < s; n++)
                  e.associations.set(c[n], { meshes: t, primitives: n });
                if (1 === c.length) return c[0];
                const u = new mr();
                e.associations.set(u, { meshes: t });
                for (let t = 0, e = c.length; t < e; t++) u.add(c[t]);
                return u;
              })
            );
          }
          loadCamera(t) {
            let e;
            const n = this.json.cameras[t],
              s = n[n.type];
            if (s)
              return (
                "perspective" === n.type
                  ? (e = new Mn(
                      K.radToDeg(s.yfov),
                      s.aspectRatio || 1,
                      s.znear || 1,
                      s.zfar || 2e6
                    ))
                  : "orthographic" === n.type &&
                    (e = new qn(
                      -s.xmag,
                      s.xmag,
                      s.ymag,
                      -s.ymag,
                      s.znear,
                      s.zfar
                    )),
                n.name && (e.name = this.createUniqueName(n.name)),
                Gl(e, n),
                Promise.resolve(e)
              );
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
          }
          loadSkin(t) {
            const e = this.json.skins[t],
              n = { joints: e.joints };
            return void 0 === e.inverseBindMatrices
              ? Promise.resolve(n)
              : this.getDependency("accessor", e.inverseBindMatrices).then(
                  function (t) {
                    return (n.inverseBindMatrices = t), n;
                  }
                );
          }
          loadAnimation(t) {
            const e = this.json.animations[t],
              n = [],
              s = [],
              i = [],
              r = [],
              o = [];
            for (let t = 0, a = e.channels.length; t < a; t++) {
              const a = e.channels[t],
                c = e.samplers[a.sampler],
                u = a.target,
                d = void 0 !== u.node ? u.node : u.id,
                l = void 0 !== e.parameters ? e.parameters[c.input] : c.input,
                h = void 0 !== e.parameters ? e.parameters[c.output] : c.output;
              n.push(this.getDependency("node", d)),
                s.push(this.getDependency("accessor", l)),
                i.push(this.getDependency("accessor", h)),
                r.push(c),
                o.push(u);
            }
            return Promise.all([
              Promise.all(n),
              Promise.all(s),
              Promise.all(i),
              Promise.all(r),
              Promise.all(o),
            ]).then(function (n) {
              const s = n[0],
                i = n[1],
                r = n[2],
                o = n[3],
                a = n[4],
                c = [];
              for (let t = 0, e = s.length; t < e; t++) {
                const e = s[t],
                  n = i[t],
                  u = r[t],
                  d = o[t],
                  l = a[t];
                if (void 0 === e) continue;
                let h;
                switch (
                  (e.updateMatrix(), (e.matrixAutoUpdate = !0), Fl[l.path])
                ) {
                  case Fl.weights:
                    h = Pa;
                    break;
                  case Fl.rotation:
                    h = Da;
                    break;
                  default:
                    h = Oa;
                }
                const f = e.name ? e.name : e.uuid,
                  m = void 0 !== d.interpolation ? Bl[d.interpolation] : E,
                  p = [];
                Fl[l.path] === Fl.weights
                  ? e.traverse(function (t) {
                      !0 === t.isMesh &&
                        t.morphTargetInfluences &&
                        p.push(t.name ? t.name : t.uuid);
                    })
                  : p.push(f);
                let g = u.array;
                if (u.normalized) {
                  const t = Xl(g.constructor),
                    e = new Float32Array(g.length);
                  for (let n = 0, s = g.length; n < s; n++) e[n] = g[n] * t;
                  g = e;
                }
                for (let t = 0, e = p.length; t < e; t++) {
                  const e = new h(p[t] + "." + Fl[l.path], n.array, g, m);
                  "CUBICSPLINE" === d.interpolation &&
                    ((e.createInterpolant = function (t) {
                      return new (this instanceof Da ? Dl : Pl)(
                        this.times,
                        this.values,
                        this.getValueSize() / 3,
                        t
                      );
                    }),
                    (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
                      !0)),
                    c.push(e);
                }
              }
              const u = e.name ? e.name : "animation_" + t;
              return new ka(u, void 0, c);
            });
          }
          createNodeMesh(t) {
            const e = this.json,
              n = this,
              s = e.nodes[t];
            return void 0 === s.mesh
              ? null
              : n.getDependency("mesh", s.mesh).then(function (t) {
                  const e = n._getNodeRef(n.meshCache, s.mesh, t);
                  return (
                    void 0 !== s.weights &&
                      e.traverse(function (t) {
                        if (t.isMesh)
                          for (let e = 0, n = s.weights.length; e < n; e++)
                            t.morphTargetInfluences[e] = s.weights[e];
                      }),
                    e
                  );
                });
          }
          loadNode(t) {
            const e = this.json,
              n = this.extensions,
              s = this,
              i = e.nodes[t],
              r = i.name ? s.createUniqueName(i.name) : "";
            return (function () {
              const e = [],
                n = s._invokeOne(function (e) {
                  return e.createNodeMesh && e.createNodeMesh(t);
                });
              return (
                n && e.push(n),
                void 0 !== i.camera &&
                  e.push(
                    s.getDependency("camera", i.camera).then(function (t) {
                      return s._getNodeRef(s.cameraCache, i.camera, t);
                    })
                  ),
                s
                  ._invokeAll(function (e) {
                    return e.createNodeAttachment && e.createNodeAttachment(t);
                  })
                  .forEach(function (t) {
                    e.push(t);
                  }),
                Promise.all(e)
              );
            })().then(function (e) {
              let o;
              if (
                ((o =
                  !0 === i.isBone
                    ? new qr()
                    : e.length > 1
                    ? new mr()
                    : 1 === e.length
                    ? e[0]
                    : new pe()),
                o !== e[0])
              )
                for (let t = 0, n = e.length; t < n; t++) o.add(e[t]);
              if (
                (i.name && ((o.userData.name = i.name), (o.name = r)),
                Gl(o, i),
                i.extensions && Hl(n, o, i),
                void 0 !== i.matrix)
              ) {
                const t = new Wt();
                t.fromArray(i.matrix), o.applyMatrix4(t);
              } else void 0 !== i.translation && o.position.fromArray(i.translation), void 0 !== i.rotation && o.quaternion.fromArray(i.rotation), void 0 !== i.scale && o.scale.fromArray(i.scale);
              return (
                s.associations.has(o) || s.associations.set(o, {}),
                (s.associations.get(o).nodes = t),
                o
              );
            });
          }
          loadScene(t) {
            const e = this.json,
              n = this.extensions,
              s = this.json.scenes[t],
              i = this,
              r = new mr();
            s.name && (r.name = i.createUniqueName(s.name)),
              Gl(r, s),
              s.extensions && Hl(n, r, s);
            const o = s.nodes || [],
              a = [];
            for (let t = 0, n = o.length; t < n; t++) a.push(Yl(o[t], r, e, i));
            return Promise.all(a).then(function () {
              return (
                (i.associations = ((t) => {
                  const e = new Map();
                  for (const [t, n] of i.associations)
                    (t instanceof Ae || t instanceof at) && e.set(t, n);
                  return (
                    t.traverse((t) => {
                      const n = i.associations.get(t);
                      null != n && e.set(t, n);
                    }),
                    e
                  );
                })(r)),
                r
              );
            });
          }
        }
        function Yl(t, e, n, s) {
          const i = n.nodes[t];
          return s
            .getDependency("node", t)
            .then(function (t) {
              if (void 0 === i.skin) return t;
              let e;
              return s
                .getDependency("skin", i.skin)
                .then(function (t) {
                  e = t;
                  const n = [];
                  for (let t = 0, i = e.joints.length; t < i; t++)
                    n.push(s.getDependency("node", e.joints[t]));
                  return Promise.all(n);
                })
                .then(function (n) {
                  return (
                    t.traverse(function (t) {
                      if (!t.isMesh) return;
                      const s = [],
                        i = [];
                      for (let t = 0, r = n.length; t < r; t++) {
                        const r = n[t];
                        if (r) {
                          s.push(r);
                          const n = new Wt();
                          void 0 !== e.inverseBindMatrices &&
                            n.fromArray(e.inverseBindMatrices.array, 16 * t),
                            i.push(n);
                        } else
                          console.warn(
                            'THREE.GLTFLoader: Joint "%s" could not be found.',
                            e.joints[t]
                          );
                      }
                      t.bind(new $r(s, i), t.matrixWorld);
                    }),
                    t
                  );
                });
            })
            .then(function (t) {
              e.add(t);
              const r = [];
              if (i.children) {
                const e = i.children;
                for (let i = 0, o = e.length; i < o; i++) {
                  const o = e[i];
                  r.push(Yl(o, t, n, s));
                }
              }
              return Promise.all(r);
            });
        }
        function Jl(t, e, n) {
          const s = e.attributes,
            i = [];
          function r(e, s) {
            return n.getDependency("accessor", e).then(function (e) {
              t.setAttribute(s, e);
            });
          }
          for (const e in s) {
            const n = zl[e] || e.toLowerCase();
            n in t.attributes || i.push(r(s[e], n));
          }
          if (void 0 !== e.indices && !t.index) {
            const s = n.getDependency("accessor", e.indices).then(function (e) {
              t.setIndex(e);
            });
            i.push(s);
          }
          return (
            Gl(t, e),
            (function (t, e, n) {
              const s = e.attributes,
                i = new gt();
              if (void 0 === s.POSITION) return;
              {
                const t = n.json.accessors[s.POSITION],
                  e = t.min,
                  r = t.max;
                if (void 0 === e || void 0 === r)
                  return void console.warn(
                    "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                  );
                if (
                  (i.set(new ft(e[0], e[1], e[2]), new ft(r[0], r[1], r[2])),
                  t.normalized)
                ) {
                  const e = Xl(Nl[t.componentType]);
                  i.min.multiplyScalar(e), i.max.multiplyScalar(e);
                }
              }
              const r = e.targets;
              if (void 0 !== r) {
                const t = new ft(),
                  e = new ft();
                for (let s = 0, i = r.length; s < i; s++) {
                  const i = r[s];
                  if (void 0 !== i.POSITION) {
                    const s = n.json.accessors[i.POSITION],
                      r = s.min,
                      o = s.max;
                    if (void 0 !== r && void 0 !== o) {
                      if (
                        (e.setX(Math.max(Math.abs(r[0]), Math.abs(o[0]))),
                        e.setY(Math.max(Math.abs(r[1]), Math.abs(o[1]))),
                        e.setZ(Math.max(Math.abs(r[2]), Math.abs(o[2]))),
                        s.normalized)
                      ) {
                        const t = Xl(Nl[s.componentType]);
                        e.multiplyScalar(t);
                      }
                      t.max(e);
                    } else
                      console.warn(
                        "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                      );
                  }
                }
                i.expandByVector(t);
              }
              t.boundingBox = i;
              const o = new Ot();
              i.getCenter(o.center),
                (o.radius = i.min.distanceTo(i.max) / 2),
                (t.boundingSphere = o);
            })(t, e, n),
            Promise.all(i).then(function () {
              return void 0 !== e.targets
                ? (function (t, e, n) {
                    let s = !1,
                      i = !1;
                    for (let t = 0, n = e.length; t < n; t++) {
                      const n = e[t];
                      if (
                        (void 0 !== n.POSITION && (s = !0),
                        void 0 !== n.NORMAL && (i = !0),
                        s && i)
                      )
                        break;
                    }
                    if (!s && !i) return Promise.resolve(t);
                    const r = [],
                      o = [];
                    for (let a = 0, c = e.length; a < c; a++) {
                      const c = e[a];
                      if (s) {
                        const e =
                          void 0 !== c.POSITION
                            ? n.getDependency("accessor", c.POSITION)
                            : t.attributes.position;
                        r.push(e);
                      }
                      if (i) {
                        const e =
                          void 0 !== c.NORMAL
                            ? n.getDependency("accessor", c.NORMAL)
                            : t.attributes.normal;
                        o.push(e);
                      }
                    }
                    return Promise.all([Promise.all(r), Promise.all(o)]).then(
                      function (e) {
                        const n = e[0],
                          r = e[1];
                        return (
                          s && (t.morphAttributes.position = n),
                          i && (t.morphAttributes.normal = r),
                          (t.morphTargetsRelative = !0),
                          t
                        );
                      }
                    );
                  })(t, e.targets, n)
                : t;
            })
          );
        }
        function Zl(t, e) {
          let n = t.getIndex();
          if (null === n) {
            const e = [],
              s = t.getAttribute("position");
            if (void 0 === s)
              return (
                console.error(
                  "THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
                ),
                t
              );
            for (let t = 0; t < s.count; t++) e.push(t);
            t.setIndex(e), (n = t.getIndex());
          }
          const s = n.count - 2,
            i = [];
          if (2 === e)
            for (let t = 1; t <= s; t++)
              i.push(n.getX(0)), i.push(n.getX(t)), i.push(n.getX(t + 1));
          else
            for (let t = 0; t < s; t++)
              t % 2 == 0
                ? (i.push(n.getX(t)),
                  i.push(n.getX(t + 1)),
                  i.push(n.getX(t + 2)))
                : (i.push(n.getX(t + 2)),
                  i.push(n.getX(t + 1)),
                  i.push(n.getX(t)));
          i.length / 3 !== s &&
            console.error(
              "THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
            );
          const r = t.clone();
          return r.setIndex(i), r;
        }
        class $l extends Qc {
          constructor(t) {
            super(),
              (this.sources = t),
              (this.items = {}),
              (this.toLoad = this.sources.length),
              (this.loaded = 0),
              this.setLoaders(),
              this.startLoading();
          }
          setLoaders() {
            (this.loaders = {}),
              (this.loaders.gltfLoader = new dl()),
              (this.loaders.textureLoader = new ja()),
              (this.loaders.cubeTextureLoader = new Wa());
          }
          startLoading() {
            for (const t of this.sources)
              "gltfModel" === t.type
                ? this.loaders.gltfLoader.load(t.path, (e) => {
                    this.sourceLoaded(t, e);
                  })
                : "texture" === t.type
                ? this.loaders.textureLoader.load(t.path, (e) => {
                    this.sourceLoaded(t, e);
                  })
                : "cubeTexture" === t.type &&
                  this.loaders.cubeTextureLoader.load(t.path, (e) => {
                    this.sourceLoaded(t, e);
                  });
          }
          sourceLoaded(t, e) {
            (this.items[t.name] = e),
              this.loaded++,
              this.loaded === this.toLoad && this.trigger("ready");
          }
        }
        const Kl = [
          {
            name: "environmentMapTexture",
            type: "cubeTexture",
            path: [
              "textures/environmentMap/px.jpg",
              "textures/environmentMap/nx.jpg",
              "textures/environmentMap/py.jpg",
              "textures/environmentMap/ny.jpg",
              "textures/environmentMap/pz.jpg",
              "textures/environmentMap/nz.jpg",
            ],
          },
          {
            name: "grassColorTexture",
            type: "texture",
            path: "textures/dirt/color.jpg",
          },
          {
            name: "grassNormalTexture",
            type: "texture",
            path: "textures/dirt/normal.jpg",
          },
          { name: "malume", type: "texture", path: "assets/malume.jpg" },
          { name: "spova", type: "texture", path: "assets/spova.jpg" },
          { name: "keen", type: "texture", path: "assets/keen.jpg" },
          {
            name: "foxModel",
            type: "gltfModel",
            path: "models/Fox/glTF/Fox.gltf",
          },
          {
            name: "halModel",
            type: "gltfModel",
            path: "models/RobotExpressive/RobotExpressive.glb",
          },
          {
            name: "letters",
            type: "gltfModel",
            path: "models/letters/wethinkcode.glb",
          },
          {
            name: "lettersmfundo",
            type: "gltfModel",
            path: "models/letters/mfundo.glb",
          },
          {
            name: "skydome",
            type: "gltfModel",
            path: "models/Sky/skydome.glb",
          },
          {
            name: "trees",
            type: "gltfModel",
            path: "models/Terrain/trees.glb",
          },
          {
            name: "cinema",
            type: "gltfModel",
            path: "models/Terrain/cinema.glb",
          },
        ];
        let Ql = null;
        class th {
          constructor(t) {
            if (Ql) return Ql;
            (Ql = this),
              (window.experience = this),
              (this.canvas = t),
              (this.debug = new Kc()),
              (this.sizes = new tu()),
              (this.time = new eu()),
              (this.scene = new br()),
              (this.resources = new $l(Kl)),
              (this.camera = new ou()),
              (this.renderer = new au()),
              (this.world = new ul()),
              (this.scene.background = new Oe(65535)),
              document.addEventListener("keydown", (t) => {
                console.log(t.keyCode),
                  this.world.player &&
                    (this.world.player.characterControls.keysPressed[
                      t.keyCode
                    ] = !0);
              }),
              document.addEventListener("keyup", (t) => {
                console.log(t.keyCode),
                  this.world.player &&
                    (this.world.player.characterControls.keysPressed[
                      t.keyCode
                    ] = !1);
              }),
              (this.objsToTest = []),
              (this.raycaster = new Ec()),
              (this.mouse = new Q()),
              (this.mouse.x = this.mouse.y = null),
              (this.selectState = !1),
              window.addEventListener("pointermove", (t) => {
                (this.mouse.x = (t.clientX / this.sizes.width) * 2 - 1),
                  (this.mouse.y = (-t.clientY / this.sizes.height) * 2 + 1);
              }),
              window.addEventListener("pointerdown", () => {
                this.selectState = !0;
              }),
              window.addEventListener("pointerup", () => {
                this.selectState = !1;
              }),
              window.addEventListener("touchstart", (t) => {
                (this.selectState = !0),
                  (this.mouse.x =
                    (t.touches[0].clientX / this.sizes.width) * 2 - 1),
                  (this.mouse.y =
                    (-t.touches[0].clientY / this.sizes.height) * 2 + 1);
              }),
              window.addEventListener("touchend", () => {
                (this.selectState = !1),
                  (this.mouse.x = null),
                  (this.mouse.y = null);
              }),
              this.sizes.on("resize", () => {
                this.resize();
              }),
              this.time.on("tick", () => {
                this.update();
              });
          }
          resize() {
            this.camera.resize(), this.renderer.resize();
          }
          raycast() {
            return this.objsToTest.reduce((t, e) => {
              const n = this.raycaster.intersectObject(e, !0);
              return n[0] && (!t || n[0].distance < t.distance)
                ? ((n[0].object = e), n[0])
                : t;
            }, null);
          }
          update() {
            this.camera.update(), this.world.update(), this.renderer.update();
          }
          destroy() {
            this.sizes.off("resize"),
              this.time.off("tick"),
              this.scene.traverse((t) => {
                if (t instanceof pn) {
                  t.geometry.dispose();
                  for (const e in t.material) {
                    const n = t.material[e];
                    n && "function" == typeof n.dispose && n.dispose();
                  }
                }
              }),
              this.camera.controls.dispose(),
              this.renderer.instance.dispose(),
              this.debug.active && this.debug.ui.destroy();
          }
        }
        new th(document.querySelector("canvas.webgl"));
      },
      96: (t, e, n) => {
        t.exports = n.p + "assets/images/0768623c0e131f13.png";
      },
    },
    e = {};
  function n(s) {
    var i = e[s];
    if (void 0 !== i) return i.exports;
    var r = (e[s] = { exports: {} });
    return t[s](r, r.exports, n), r.exports;
  }
  (n.g = (function () {
    if ("object" == typeof globalThis) return globalThis;
    try {
      return this || new Function("return this")();
    } catch (t) {
      if ("object" == typeof window) return window;
    }
  })()),
    (() => {
      var t;
      n.g.importScripts && (t = n.g.location + "");
      var e = n.g.document;
      if (!t && e && (e.currentScript && (t = e.currentScript.src), !t)) {
        var s = e.getElementsByTagName("script");
        s.length && (t = s[s.length - 1].src);
      }
      if (!t)
        throw new Error(
          "Automatic publicPath is not supported in this browser"
        );
      (t = t
        .replace(/#.*$/, "")
        .replace(/\?.*$/, "")
        .replace(/\/[^\/]+$/, "/")),
        (n.p = t);
    })(),
    n(14);
})();
//# sourceMappingURL=bundle.50d3c3356f2ffbfa.js.map
